%%%%% conversion-lemmas.elf
%%%%% lemmas used for proving theorems in conversion-thms.elf
%%%%% Chao Sun
%%%%% July 19, 2010


%%% lemmas about permission operation

%theorem writeshared-can-move-front :
	forall* {PM} {L} {Pi}
	forall  {L2P: oflist2perm PM L Pi}
	exists  {Pi'} {EV: equiv Pi (sharedPerm , Pi')}
	true.
		      
- : writeshared-can-move-front oflist2perm/0 empty EV
     <- equiv-symmetric equiv/identity EV.

- : writeshared-can-move-front (oflist2perm/+ _ L2P) _ EV3
     <- writeshared-can-move-front L2P _ EV
     <- equiv-transitive 
	(equiv/combine equiv/reflexive EV) (equiv/associate) EV1
     <- equiv-transitive EV1 (equiv/combine equiv/commute equiv/reflexive) EV2
     <- equiv-transitive EV2 (equiv/symmetric equiv/associate) EV3.
	      
%worlds (objvar) (writeshared-can-move-front _ _ _).
%total L2P (writeshared-can-move-front L2P _ _).


%theorem clspred-can-be-duplicated :
	forall* {PM} {T} {PF}
	forall  {T2P: nulltp2perm PM T PF}
	exists  {I: {o} implies (PF o) ((PF o) , (PF o))}
        true.

- : clspred-can-be-duplicated
     (nulltp2perm/null) ([_] implies/duplicate).

- : clspred-can-be-duplicated
     (nulltp2perm/norm _ nn2perm/yes)
     ([v] implies/duplicate).

- : clspred-can-be-duplicated 
     (nulltp2perm/norm _ nn2perm/may)
     ([v] (implies/trans
	     (implies/cond-inner 
		(bimplies/reflexive)
		(bimplies/reflexive)
		(implies/equiv (equiv/symmetric equiv/identity))
		(implies/duplicate))
	     (implies/cond-distribute))).

%worlds (objvar) (clspred-can-be-duplicated _ _).
%total  {} (clspred-can-be-duplicated _ _).


%theorem oflist-lookup-implies-clspred :
        forall* {PM} {L} {T} {Pi} 
	forall  {O} {LL: oflist-lookup L O T}
		{L2P: oflist2perm PM L Pi}
        exists  {PF} {T2P: nulltp2perm PM T ([o] PF o)}
		{I: implies Pi ((PF O) , Pi)}
        true.

- : oflist-lookup-implies-clspred O (oflist-lookup/=)
     (oflist2perm/+ T2P L2P) _ T2P
     (implies/trans
	(implies/combine (I O) implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate)))
     <- clspred-can-be-duplicated T2P I.

- : oflist-lookup-implies-clspred O (oflist-lookup/!= L)
     (oflist2perm/+ _ L2P) _ T2P
     (implies/trans4
	(implies/combine implies/reflexive I)
	(implies/equiv equiv/associate)
	(implies/combine (implies/equiv equiv/commute)
	   (implies/reflexive))
	(implies/equiv (equiv/symmetric equiv/associate)))
     <- oflist-lookup-implies-clspred O L L2P _ T2P I.

%worlds (objvar) (oflist-lookup-implies-clspred _ _ _ _ _ _).
%total  LP (oflist-lookup-implies-clspred _ LP _ _ _ _).


%theorem clspred-remove-cond :
        forall* {NN} {PF}
        forall  {PD} {O} {NP: nn2perm NN PF}
        exists  {I: implies
		     (unitperm
			(nonlinear (neg (objequal O null))) , (PF PD O))
		     (unitperm
			(nonlinear
			   (conj (neg (objequal O null))
			      (conj (nestInShared O) 
				 (predcall PD (predargs/1 O)))))) }
	true.		

- : clspred-remove-cond _ _ nn2perm/yes	
     (implies/trans3
	(implies/combine
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
	   (implies/reflexive))
	(implies/equiv equiv/commute)
	(implies/equiv equiv/identity)).

- : clspred-remove-cond _ _ nn2perm/may
     (implies/trans4
	(implies/combine
	   (implies/duplicate)
	   (implies/cond-neg))
	(implies/equiv (equiv/symmetric equiv/associate))
	(implies/combine implies/reflexive implies/cond-elim)
	(implies/combine2conj)).

%worlds (objvar) (clspred-remove-cond _ _ _ _).
%total  {} (clspred-remove-cond _ _ _ _).


%theorem clspred-implies-empty :
        forall* {PM} {PF} {T} 
        forall  {T2P: nulltp2perm PM T PF}
        exists  {I: {r} implies (PF r) empty}
	true.

- : clspred-implies-empty
     nulltp2perm/null
     ([_] implies/trans
	(implies/nonlinear (bimplies/tt)) 
	(implies/true2empty)).

- : clspred-implies-empty
     (nulltp2perm/norm _ nn2perm/yes)
     ([r] (implies/trans
	     (implies/nonlinear bimplies/tt)
	     (implies/true2empty))).

- : clspred-implies-empty
     (nulltp2perm/norm _ nn2perm/may)
     ([r] implies/trans
	(implies/cond-inner
	   (bimplies/reflexive)
	   (bimplies/reflexive)
	   (implies/reflexive)
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
	(implies/cond-equal)).

%worlds (objvar) (clspred-implies-empty _ _).
%total  {} (clspred-implies-empty _ _).
                

%theorem lookup-fldperm/LL :
        forall* {PM} {NN} {C} {F} {G} 
        forall  {V:void}
        exists  {PF} {PD} {F2P: fldnn2perm F NN PF}
                {L: predmap`lookup PM C PD}
                {I: {o} implies (unitperm (nonlinear (G o)))
		       (unitperm (nonlinear (nested (PF PD o) null own)))}
        true.

%worlds (objvar) (lookup-fldperm/LL _ _ _ _ _ _).
%total  {} (lookup-fldperm/LL _ _ _ _ _ _).


%theorem lookup-fldperm/L :
        forall* {CM} {PM} {FM} {G} {F} {C} {NN}
        forall  {F2C: fldmap2conj CM PM FM ([r] G r) PM}
                {L: fldmap`lookup FM F (nulltp/norm C NN)}
        exists  {PF} {PD} {FN2P: fldnn2perm F NN PF}
                {L: predmap`lookup PM C PD}
                {I: {o} implies (unitperm (nonlinear (G o)))
			  (unitperm (nonlinear (nested (PF PD o) null own)))}
        true.

- : lookup-fldperm/L (fldmap2conj/null F2C FM-SH) 
     (fldmap`lookup/> FM-L P) PF PD FNN2P PM-L I
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
     <- lookup-fldperm/L F2C FM-L' PF PD FNN2P PM-L I.

- : lookup-fldperm/L (fldmap2conj/norm/in _ FNN2P _ PM-L) 
     (fldmap`lookup/= _) _ _ FNN2P PM-L 
     ([o] implies/trans3
	(implies/conj2combine)
	(implies/combine
	   (implies/reflexive)
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
	(implies/equiv equiv/identity)).

- : lookup-fldperm/L (fldmap2conj/norm/in F2C _ FM-SH _)
     (fldmap`lookup/> FM-L P) PF PD FNN2P PM-L
     ([o] implies/trans4
	(implies/conj2combine)
	(implies/combine 
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
	   (I o))
	(implies/equiv equiv/commute)
	(implies/equiv equiv/identity))
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
     <- lookup-fldperm/L F2C FM-L' PF PD FNN2P PM-L I.

- : lookup-fldperm/L 
     (fldmap2conj/norm/out F2C
	(F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _) 
	([f] PM-U f) _ _ _ PM-FS) _ PF PD FNN2P PM-L I
     <- predmap`size-total SZ-PM
     <- predmap`fresh-update-increases-size
	SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
     <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
     <- predmap`size-total SZ-PMF
     <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
     <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
     <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
     <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
     <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
     <- nat`gt-anti-reflexive SZ-PM>PM F
     <- lookup-fldperm/LL F PF PD FNN2P PM-L I.

%worlds (objvar) (lookup-fldperm/L _ _ _ _ _ _ _).
%total  F2C (lookup-fldperm/L F2C _ _ _ _ _ _).


% TODO: null case should be handled here

%theorem lookup-fldperm :
	forall* {CM} {PM} {FM} {C} {D} {F} {CJ} {NN}
	forall  {CM2PM: clsmap2predmap CM PM}
		{PM-L: predmap`lookup PM C (conj2pred CJ)}
		{CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (nulltp/norm D NN)}
	exists  {PF} {PD} 
                {F2C: fldmap2conj CM PM FM (CJ (conj2pred CJ)) PM}
                {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM D PD}
		{I: {o} implies 
		       (unitperm
			  (nonlinear (predcall (conj2pred CJ) (predargs/1 o))))
		       (unitperm (nonlinear ((nested (PF PD o) null own))))}
	true.

- : lookup-fldperm CM2PM PM-L CM-L FM-L PF PD F2C FNN2P PM-L' 
     ([o] implies/trans 
	(implies/nonlinear
	   (bimplies/trans
	      (bimplies/predcall/Y/inline)
	      (bimplies/trans
		 (bimplies/predcall/+/inline o)
		 (bimplies/predcall/0/inline))))
	(I o))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PM-L CM-L F2C
     <- lookup-fldperm/L F2C FM-L PF PD FNN2P PM-L' I.

%worlds (objvar) (lookup-fldperm _ _ _ _ _ _ _ _ _ _).
%total  {} (lookup-fldperm _ _ _ _ _ _ _ _ _ _).


%theorem get-precise-exists :
        forall* {PM} {PF} {PD} {F} {C} {NN} {Pi}
        forall  {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM C PD}
        exists  {FF} {NN2P: nn2perm NN FF}
                {I: {o} implies
		       (combine 
			  (unitperm 
			     (nonlinear
				(nested (PF PD o) null own)))
			  (sharedPerm , Pi))
		       (combine
			  (unitperm 
			     (precise-exists o F 
				([r] (FF PD r))))
			  (combine
			     (unitperm
				(encumbered 
				   (unitperm
				      (precise-exists o F
					 ([r] (FF PD r))))
				   (sharedPerm)))
			     (Pi)))}
	true.       
				 
- : get-precise-exists
     fldnn2perm/yes _ _ nn2perm/yes
     ([o] implies/trans3
	(implies/equiv equiv/associate)
	(implies/combine implies/carve implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate))).

- : get-precise-exists 
     fldnn2perm/may _ _ nn2perm/may
     ([o] implies/trans3
	(implies/equiv equiv/associate)
	(implies/combine implies/carve implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate))).

%worlds (objvar) (get-precise-exists _ _ _ _ _).
%total  {} (get-precise-exists _ _ _ _ _).



%%% conversion helper theorems

%theorem clsmap-nulltp-implies-nulltp2perm :
	forall* {CM} {PM} {T}
	forall  {CM2PM: clsmap2predmap CM PM}	     
	        {CM-T: clsmap-nulltp CM T}
	exists  {PF} {T2P: nulltp2perm PM T ([o] PF o)}
	true.		

- : clsmap-nulltp-implies-nulltp2perm
     CM2PM clsmap-nulltp/null _ nulltp2perm/null.

- : clsmap-nulltp-implies-nulltp2perm
     CM2PM (clsmap-nulltp/norm IN) _ (nulltp2perm/norm PM-LP NN2P)
     <- clsmap`in-implies-lookup IN _ CM-LP
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP
     <- nn2perm-total _ _ NN2P.

%worlds () (clsmap-nulltp-implies-nulltp2perm _ _ _ _).
%total  CM-T (clsmap-nulltp-implies-nulltp2perm _ CM-T _ _).
     

%theorem conversion-helper/and/L :
        forall* {PM} {G} {Pi} {Rslt} {Out1}
        forall  {CPO: perm-output PM Pi Rslt Out1}
        exists  {Out2} {Out3} 
                {AH2: andHelp2 G Out1 Pi Out2}
                {T: transform Out2 Out3}
                {CPO: perm-output PM Pi Rslt Out3}
        true.

- : conversion-helper/and/L
     perm-output/cond _ _ andHelp2/base 
     (transform/cond
	(bimplies/reflexive)
	(bimplies/reflexive)
	(implies/reflexive)
	(implies/cond-equal))
     perm-output/cond.

- : conversion-helper/and/L 
     (perm-output/exists ([v] (CPO1 v)))
     (output/exists ([v] (Out2 v)))
     (output/exists ([v] (Out3 v)))
     (andHelp2/exists ([v] AH2 v))
     (transform/inside ([v] (T v)))
     (perm-output/exists ([v] (CPO3 v)))
     <- ({v:object} conversion-helper/and/L
	   (CPO1 v) (Out2 v) (Out3 v) (AH2 v) (T v) (CPO3 v)).

%worlds (objvar) (conversion-helper/and/L _ _ _ _ _ _).
%total CPO (conversion-helper/and/L CPO _ _ _ _ _).


%theorem conversion-helper/and :
        forall* {W} {Pi} {PM} {Out1} {Out2} {C}
        forall  {CPO: perm-output PM Pi result/cond Out1}
                {TYP: typing W Pi C Out2}
        exists  {Out3} {Out4} 
                {AH: andHelp1 W Out1 C Out3} 
                {T: transform Out3 Out4}
                {CPO: perm-output PM Pi result/cond Out4}
        true.

- : conversion-helper/and
     perm-output/cond TYP Out3 Out4 (andHelp1/base TYP AH2) T CPO
     <- conversion-helper/and/L perm-output/cond Out3 Out4 AH2 T CPO.

- : conversion-helper/and
     (perm-output/exists ([v] CPO v)) TYP (output/exists ([v] Out3 v))
     (output/exists ([v] Out4 v)) (andHelp1/exists ([v] (AH1 v)))
     (transform/inside ([v] T v)) (perm-output/exists ([v] CPO' v))
     <- ({v} conversion-helper/and
	   (CPO v) TYP (Out3 v) (Out4 v) (AH1 v) (T v) (CPO' v)).

%worlds (objvar) (conversion-helper/and _ _ _ _ _ _ _).
%trustme %total CPO (conversion-helper/and CPO _ _ _ _ _ _).


%theorem conversion-helper/not/L :
        forall* {PM} {Pi} {Out}
        forall  {CPO: perm-output PM Pi result/cond Out}
        exists  {Out'} {N: notEnv Out Out'}
		{CPO: perm-output PM Pi result/cond Out'}		    
        true.

- : conversion-helper/not/L
     perm-output/cond _ notEnv/base perm-output/cond.

- : conversion-helper/not/L (perm-output/exists ([v] CPO v)) 
     (output/exists ([v] Out' v)) (notEnv/exists ([v] NV v))
     (perm-output/exists ([v] CPO' v))
     <- ({v:object} conversion-helper/not/L (CPO v) (Out' v) (NV v) (CPO' v)).
     
%worlds (objvar) (conversion-helper/not/L _ _ _ _).
%total C (conversion-helper/not/L C _ _ _).


%theorem conversion-helper/not :
        forall* {W} {PM} {Pi} {C} {COut} 
        forall  {TYP: typing W Pi C COut}
                {CPO: perm-output PM Pi result/cond COut}
        exists  {COut'} {TYP: typing W Pi (not C) COut'}
                {CPO: perm-output PM Pi result/cond COut'}
        true.

- : conversion-helper/not TYP CPO Out (tNot TYP NV) CPO'
     <- conversion-helper/not/L CPO Out NV CPO'.

%worlds (objvar) (conversion-helper/not _ _ _ _ _).
%total  {} (conversion-helper/not _ _ _ _ _).


%theorem conversion-helper/if :
        forall* {W} {PM} {Pi} {E1} {E2} 
                {COut} {EOut:output exprk} {CRslt:result condk} {ERslt} 
        forall  {TYP: typing W Pi E1 EOut}
                {TYP: typing W Pi E2 EOut}
                {EPO: perm-output PM Pi ERslt EOut}
                {CPO: perm-output PM Pi CRslt COut}
        exists  {EOut'} {TYP: ifTyping W COut E1 E2 EOut'}
                {T: transform EOut' EOut}
        true.

- : conversion-helper/if
     TYP1 TYP2 P-O perm-output/cond _ 
     (ifTyping/base TYP1 TYP2) transform/reflexive.

- : conversion-helper/if
     TYP1 TYP2 EPO (perm-output/exists ([v] CPO v))
     (output/exists ([v] EOut v)) (ifTyping/exists ([v] IFT v)) 
     (transform/trans
	(transform/inside ([v] T v))
	(transform/rem-unused))
     <- ({v:object} conversion-helper/if
	TYP1 TYP2 EPO (CPO v) (EOut v) (IFT v) (T v)).

%worlds (objvar) (conversion-helper/if _ _ _ _ _ _ _).
%total  (PO) (conversion-helper/if _ _ _ PO _ _ _).


%theorem conversion-helper/while :
	forall* {PM} {W} {Pi} {COut} {E} 
	forall  {TYP: typing W Pi E (output/exists ([v] (output/expr v Pi)))}
                {CPO: perm-output PM Pi result/cond COut}
	exists  {Out1} {Out2} {Out4}
                {WT: whileTyping W COut E Out1 Out2}
                {D: discard-value Out1 Out4}
		{T: transform Out4 (output/expr null Pi)}	    
		{T: transform Out2 (output/expr null Pi)}		    
        true.

- : conversion-helper/while TYP perm-output/cond _ _ _ 
     (whileTyping/base TYP)
     (discard-value/exists ([v] (discard-value/base)))
     (transform/rem-unused)
     (transform/reflexive).

- : conversion-helper/while TYP (perm-output/exists ([v] CPO v)) _ _ _
     (whileTyping/exists ([v] WT v))
     (discard-value/exists ([v] DV v))
     (transform/trans (transform/inside ([v] T1 v)) (transform/rem-unused))
     (transform/trans (transform/inside ([v] T2 v)) (transform/rem-unused))
     <- ({v:object} conversion-helper/while TYP (CPO v) _ _ _ 
	   (WT v) (DV v) (T1 v) (T2 v)).
	   
%worlds (objvar) (conversion-helper/while _ _ _ _ _ _ _ _ _).
%total  CPO (conversion-helper/while _ CPO _ _ _ _ _ _ _).    


%theorem conversion-helper/subL :
        forall* {NN1} {NN2}
	        {PF1} {PF2} {PD1} {PD2}
        forall  {SUB: nn`subtype NN1 NN2}
		{EQ: nullpred`eq PD1 PD2}		   
	        {NN2P: nn2perm NN1 ([p][r] PF1 p r)}
		{NN2P: nn2perm NN2 ([p][r] PF2 p r)}
	exists  {T: {r} implies (PF1 PD1 r) (PF2 PD2 r)}
 	true.
		   
- : conversion-helper/subL nn`subtype/ref nullpred`eq/
     NN2P NN2P ([_] implies/reflexive).

- : conversion-helper/subL nn`subtype/my nullpred`eq/
     nn2perm/yes nn2perm/may 
     ([_] (implies/trans
       (implies/conj2combine) (implies/cond-intro-neg))).

%worlds () (conversion-helper/subL _ _ _ _ _).
%total SB (conversion-helper/subL SB _ _ _ _).


%theorem conversion-helper/sub :
	forall* {PM} {T} {T'} {PF} {PF'}
	forall  {SUB: subtype T T'}
	        {T2P: nulltp2perm PM T PF}
		{T2P: nulltp2perm PM T' PF'}
        exists  {T: transform
		     (output/exists ([r] (output/expr r (PF r))))
		     (output/exists ([r] (output/expr r (PF' r)))) }
	true.			  

- : conversion-helper/sub 
     subtype/uu nulltp2perm/null nulltp2perm/null transform/reflexive.

- : conversion-helper/sub
     subtype/uo nulltp2perm/null (nulltp2perm/norm _ nn2perm/may)
     (transform/inside [r]
	(transform/implies
	   (implies/trans
	      (implies/equiv
		 (equiv/symmetric equiv/identity))
	      (implies/cond-intro)))).

- : conversion-helper/sub
     (subtype/oo NN1<=NN2)
     (nulltp2perm/norm (PM-LP1) NN2P1) 
     (nulltp2perm/norm (PM-LP2) NN2P2)
     (transform/inside [r] (transform/implies (I r)))
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ EQ
     <- conversion-helper/subL NN1<=NN2 EQ NN2P1 NN2P2 I.
			  
%worlds () (conversion-helper/sub _ _ _ _).
%total SB (conversion-helper/sub SB _ _ _).


%%% I need this lemma for converting function call

%theorem typing-oflist-imply :
        forall* {CM} {MM} {PM} {L} {E} {T} {Pi} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {L2P: oflist2perm PM L Pi}
                {NTYP: nullTyping CM MM L E (result/expr T)}
        exists  {O} {PF} {T2P: nulltp2perm PM T ([o] PF o)} 
                {I: implies Pi ((PF O) , Pi)}
        true.
     
%worlds (objvar) (typing-oflist-imply _ _ _ _ _ _ _).
%trustme %total NTYP (typing-oflist-imply _ _ NTYP _ _ _ _).


%theorem no-variable-lookup :
	forall* {PM} {C} {PDF: object -> nullpred} 
	forall  {PMLP: {o} predmap`lookup PM C (PDF o)}
	exists  {PD} {PMLP: predmap`lookup PM C PD}
                {EQ: {o} predicate`eq (PDF o) PD}
	true.		       
			  
- : no-variable-lookup ([_] predmap`lookup/= N1=N2) 
     _ (predmap`lookup/= N1=N2) ([_] predicate`eq/).

- : no-variable-lookup ([o] predmap`lookup/> (PMLP o) P)
     PD (predmap`lookup/> PMLP' P) EQF
     <- no-variable-lookup PMLP PD PMLP' EQF.

%worlds (objvar) (no-variable-lookup _ _ _ _).
%total  PMLP (no-variable-lookup PMLP _ _ _).


%theorem predicate-eq-implies-environment-eq :
        forall* {FF} {NN} {PDF:object -> nullpred} {PD} {Pi1} {Pi2}
        forall  {PEQ: {o} predicate`eq (PDF o) PD}
		{NN2P: nn2perm NN FF}		
                {PEQ: permission`eq Pi1 Pi2}
        exists  {OEQ: {o} environment`eq
		       (output/exists ([r] (output/expr r ((FF (PDF o) r) , Pi1))))
		       (output/exists ([r] (output/expr r ((FF PD r) , Pi2))))}
	true.

- : predicate-eq-implies-environment-eq
     ([_] predicate`eq/) _ permission`eq/ ([_] environment`eq/). 

%worlds (objvar) (predicate-eq-implies-environment-eq _ _ _ _).
%total  {} (predicate-eq-implies-environment-eq _ _ _ _).


%%% We need more information about Pi, that is, given
%%% nulltp2perm PM T PF, we have Pi => (Pi, (PF o)).
%%% This is why the theorem typing-oflist-imply come from.

%%% I have to prove in this awkward way - for the inductive case,
%%% twelf thought all outputs should contain variable occurance,
%%% however, some shouldn't. So I have to prove the previous
%%% two trivial lemmas in order to make the theorem check.

%theorem permission-combine-deterministic :
        forall* {Pi1} {Pi1'} {Pi2} {Pi2'}
        forall  {E: permission`eq Pi1 Pi1'}
                {E: permission`eq Pi2 Pi2'}
        exists  {E: permission`eq (Pi1 , Pi2) (Pi1' , Pi2')}
        true.

- : permission-combine-deterministic 
     permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (permission-combine-deterministic _ _ _).
%total  {} (permission-combine-deterministic _ _ _).


%theorem conversion-helper/call/L1 :
        forall* {PM} {CM} {MM} {MT} {PT} 
                {Pi} {W} {T}
                {ARslt} {AOut} {L} {A}
	forall  {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}		   
		{L2P: oflist2perm PM L Pi}   
		{NTYPA: nullTyping CM MM L A ARslt}
	        {NTYPC: nullCallTyping CM MM ARslt MT (result/expr T)}
	        {MT2PT: methtp2proctype PM MT PT}
                {APO: perm-output PM Pi ARslt AOut}
	exists  {AOut'} {Out} {PF} 
                {TA: transform AOut AOut'}
		{CTYP: callTyping W AOut' PT Out}	
		{T2P: nulltp2perm PM T PF}	     
		{TE: transform Out
		      (output/exists ([r] (output/expr r ((PF r) , Pi))))}
	true.	   

- : conversion-helper/call/L1 CM2PM MM2W L2P 
     (nulltArgs/+ NTYPA NTYPE) 
     (nullCallTyping/arg ([o] NTYPC o))
     (methtp2proctype/arg ([o] MT2PT o))
     (perm-output/args/+ APO) _ _ _
     (transform/inside ([o] (transform/args/+ (TA o))))
     (callTyping/exists ([o] (callTyping/arg o (CTYP o)))) 
     (nulltp2perm/norm PM-LP NN2P) 
     (transform/trans (transform/inside [r] (TE' r)) (transform/rem-unused))
     <- ({o} conversion-helper/call/L1 CM2PM MM2W L2P 
	   NTYPA (NTYPC o) (MT2PT o) APO _ _ _
	   (TA o) (CTYP o) (nulltp2perm/norm (PM-LPF o) NN2P) (TE o))
     <- no-variable-lookup PM-LPF _ PM-LP EQF
     <- predicate-eq-implies-environment-eq EQF NN2P permission`eq/ OUT-EQF
     <- ({o} transform-respects-eq
     	   (TE o) (environment`eq/) (OUT-EQF o) (TE' o)).

- : conversion-helper/call/L1 CM2PM MM2W L2P 
     (nulltArgs/+ NTYPA NTYPE) 
     (nullCallTyping/arg ([o] NTYPC o))
     (methtp2proctype/arg ([o] MT2PT o))
     (perm-output/args/+ APO) _ _ _
     (transform/inside ([o] (transform/args/+ (TA o))))
     (callTyping/exists ([o] (callTyping/arg o (CTYP o)))) 
     (nulltp2perm/null)
     (transform/trans (transform/inside [r] (TE r)) (transform/rem-unused))
     <- ({o} conversion-helper/call/L1 CM2PM MM2W L2P 
	   NTYPA (NTYPC o) (MT2PT o) APO _ _ _
	   (TA o) (CTYP o) (nulltp2perm/null) (TE o)).

- : conversion-helper/call/L1 _ _ L2P 
     nulltArgs/0 nullCallTyping/call (methtp2proctype/base T2P)
     perm-output/args/0 _ _ _
     (transform/args/0 (implies/equiv EQV))
     (callTyping/call (envadd/exists ([_] (envadd/expr)))) T2P
     (transform/inside [_] 
	(transform/implies
	   (implies/trans3
	      (implies/equiv equiv/associate)
	      (implies/combine
		 (implies/trans
		    (implies/equiv equiv/commute)
		    (implies/equiv (equiv/symmetric EQV)))
		 (implies/reflexive))
	      (implies/equiv equiv/commute))))
     <- writeshared-can-move-front L2P _ EQV.

%worlds (objvar) (conversion-helper/call/L1 _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total MT2PT (conversion-helper/call/L1 _ _ _ _ _ _ MT2PT _ _ _ _ _ _ _).


%%% Main theorem: in this case, Pi1 is empty

%theorem conversion-helper/call :
        forall* {PM} {CM} {MM} {MT} {PT} {Pi} {W}
                {ARslt} {Rslt} {AOut} {L} {A}
	forall  {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}		   
		{L2P: oflist2perm PM L Pi}   
		{NTYPA: nullTyping CM MM L A ARslt}
	        {NTYPC: nullCallTyping CM MM ARslt MT Rslt}
	        {MT2PT: methtp2proctype PM MT PT}
                {APO: perm-output PM Pi ARslt AOut}
	exists  {AOut'} {Out} {Out'}
                {T: transform AOut AOut'}
		{CTYP: callTyping W AOut' PT Out}
		{T: transform Out Out'}
                {PO: perm-output PM Pi Rslt Out'}		   
	true.	   

- : conversion-helper/call
     CM2PM MM2W L2P NTYPA NTYPC MT2PT APO
     _ _ _ TA CTYP TE (perm-output/expr T2P)
     <- writeshared-can-move-front L2P _ EQV
     <- conversion-helper/call/L1
	CM2PM MM2W L2P NTYPA NTYPC MT2PT APO _ _ _ TA CTYP T2P TE.
     
%worlds (objvar) (conversion-helper/call _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  {} (conversion-helper/call _ _ _ _ _ _ _ _ _ _ _ _ _ _).

