%%%%% conversion-lemmas.elf
%%%%% lemmas used for proving theorems in conversion-thms.elf
%%%%% $Id: conversion-lemmas.elf,v 1.14 2010/10/25 14:56:20 csun Exp csun $
%%%%% Created at July 19, 2010

%theorem conversion-helper/let3 :
        forall* {PM} {T} {PFF:object -> object -> permission}
        forall  {T2P: {o} nulltp2perm PM T ([o1] PFF o o1)}
        exists  {PF: object -> permission} 
                {EQ: {o}{o1} permission`eq (PFF o o1) (PF o1)}
	        {T2P: nulltp2perm PM T ([o1] PF o1)}
        true.

%worlds (objvar) (conversion-helper/let3 _ _ _ _ ).
%trustme %total  {} (conversion-helper/let3 _ _ _ _).


%theorem conversion-helper/let4 :
        forall* {W} {P1:object -> permission} {P2} {PF} {F} {PFF}
        forall  {EQ: {o}{o1} permission`eq (PFF o o1) (PF o1)}
                {TYPF: {o} typing W (combine (P1 o) P2) (F o)
			(output/exists [r] 
			   (output/expr r
			      (combine (PFF o r) (combine (P1 o) P2))))}
	 exists {TYPF: {o} typing W (combine (P1 o) P2) (F o)
			(output/exists [r] 
			   (output/expr r
			      (combine (PF r) (combine (P1 o) P2))))}
         true.
					      
%worlds (objvar) (conversion-helper/let4 _ _ _).
%trustme %total  {} (conversion-helper/let4 _ _ _).


%%% lemmas about permission operation

%theorem writeshared-can-move-front :
	forall* {PM} {L} {Pi}
	forall  {L2P: oflist2perm PM L Pi}
	exists  {Pi'} {EV: equiv Pi (sharedPerm , Pi')}
	true.
		      
- : writeshared-can-move-front oflist2perm/0 empty EV
     <- equiv-symmetric equiv/identity EV.

- : writeshared-can-move-front (oflist2perm/+ _ L2P) _ EV3
     <- writeshared-can-move-front L2P _ EV
     <- equiv-transitive 
	(equiv/combine equiv/reflexive EV) (equiv/associate) EV1
     <- equiv-transitive EV1 (equiv/combine equiv/commute equiv/reflexive) EV2
     <- equiv-transitive EV2 (equiv/symmetric equiv/associate) EV3.
	      
%worlds (objvar) (writeshared-can-move-front _ _ _).
%total L2P (writeshared-can-move-front L2P _ _).


%theorem clspred-can-be-duplicated :
	forall* {PM} {T} {PF}
	forall  {T2P: nulltp2perm PM T PF}
	exists  {I: {o} implies (PF o) ((PF o) , (PF o))}
        true.

- : clspred-can-be-duplicated
     (nulltp2perm/null) ([_] implies/duplicate).

- : clspred-can-be-duplicated
     (nulltp2perm/norm _ nn2perm/yes)
     ([v] implies/duplicate).

- : clspred-can-be-duplicated 
     (nulltp2perm/norm _ nn2perm/may)
     ([v] (implies/trans
	     (implies/cond-inner 
		(bimplies/reflexive)
		(bimplies/reflexive)
		(implies/equiv (equiv/symmetric equiv/identity))
		(implies/duplicate))
	     (implies/cond-distribute))).

%worlds (objvar) (clspred-can-be-duplicated _ _).
%total  {} (clspred-can-be-duplicated _ _).


%theorem oflist-lookup-implies-clspred :
        forall* {PM} {L} {T} {Pi} 
	forall  {O} {LL: oflist-lookup L O T}
		{L2P: oflist2perm PM L Pi}
        exists  {PF} {T2P: nulltp2perm PM T ([o] PF o)}
		{I: implies Pi ((PF O) , Pi)}
        true.

- : oflist-lookup-implies-clspred O (oflist-lookup/=)
     (oflist2perm/+ T2P L2P) _ T2P
     (implies/trans
	(implies/combine (I O) implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate)))
     <- clspred-can-be-duplicated T2P I.

- : oflist-lookup-implies-clspred O (oflist-lookup/!= L)
     (oflist2perm/+ _ L2P) _ T2P
     (implies/trans4
	(implies/combine implies/reflexive I)
	(implies/equiv equiv/associate)
	(implies/combine (implies/equiv equiv/commute)
	   (implies/reflexive))
	(implies/equiv (equiv/symmetric equiv/associate)))
     <- oflist-lookup-implies-clspred O L L2P _ T2P I.

%worlds (objvar) (oflist-lookup-implies-clspred _ _ _ _ _ _).
%total  LP (oflist-lookup-implies-clspred _ LP _ _ _ _).


%theorem clspred-remove-cond :
        forall* {NN} {PF} {PM} {C} {PD}
        forall  {PM-LP: predmap`lookup PM C PD}
                {NN2P: nn2perm NN PF}
        exists  {I: {o} implies
		     (unitperm
			(nonlinear (neg (objequal o null))) , (PF PD o))
		     (unitperm
			(nonlinear
			   (conj (neg (objequal o null))
			      (conj (nestInShared o) 
				 (predcall PD (predargs/1 o)))))) }
	true.		

- : clspred-remove-cond _ nn2perm/yes	
     ([o] implies/trans3
	(implies/combine
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
	   (implies/reflexive))
	(implies/equiv equiv/commute)
	(implies/equiv equiv/identity)).

- : clspred-remove-cond _ nn2perm/may
     ([o] implies/trans4
	(implies/combine
	   (implies/duplicate)
	   (implies/cond-neg))
	(implies/equiv (equiv/symmetric equiv/associate))
	(implies/combine implies/reflexive implies/cond-elim)
	(implies/combine2conj)).

%worlds (objvar) (clspred-remove-cond _ _ _).
%total {} (clspred-remove-cond _ _ _).


%theorem clspred-implies-empty :
        forall* {PM} {PF} {T} 
        forall  {T2P: nulltp2perm PM T PF}
        exists  {I: {r} implies (PF r) empty}
	true.

- : clspred-implies-empty
     nulltp2perm/null
     ([_] implies/trans
	(implies/nonlinear (bimplies/tt)) 
	(implies/true2empty)).

- : clspred-implies-empty
     (nulltp2perm/norm _ nn2perm/yes)
     ([r] (implies/trans
	     (implies/nonlinear bimplies/tt)
	     (implies/true2empty))).

- : clspred-implies-empty
     (nulltp2perm/norm _ nn2perm/may)
     ([r] implies/trans
	(implies/cond-inner
	   (bimplies/reflexive)
	   (bimplies/reflexive)
	   (implies/reflexive)
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
	(implies/cond-equal)).

%worlds (objvar) (clspred-implies-empty _ _).
%total  {} (clspred-implies-empty _ _).
                

%theorem lookup-fldperm/LL :
        forall* {PM} {NN} {C} {F} {G} 
        forall  {V:void}
        exists  {PF} {PD} {F2P: fldnn2perm F NN PF}
                {L: predmap`lookup PM C PD}
                {I: {o} implies (unitperm (nonlinear (G o)))
		       (unitperm (nonlinear (nested (PF PD o) null own)))}
        true.

%worlds (objvar) (lookup-fldperm/LL _ _ _ _ _ _).
%total  {} (lookup-fldperm/LL _ _ _ _ _ _).


%theorem lookup-fldperm/L :
        forall* {CM} {PM} {FM} {G} {F} {C} {NN}
        forall  {F2C: fldmap2conj CM PM FM ([r] G r) PM}
                {L: fldmap`lookup FM F (nulltp/norm C NN)}
        exists  {PF} {PD} {FN2P: fldnn2perm F NN PF}
                {L: predmap`lookup PM C PD}
                {I: {o} implies (unitperm (nonlinear (G o)))
			  (unitperm (nonlinear (nested (PF PD o) null own)))}
        true.

- : lookup-fldperm/L (fldmap2conj/null F2C FM-SH) 
     (fldmap`lookup/> FM-L P) PF PD FNN2P PM-L I
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
     <- lookup-fldperm/L F2C FM-L' PF PD FNN2P PM-L I.

- : lookup-fldperm/L (fldmap2conj/norm/in _ FNN2P _ PM-L) 
     (fldmap`lookup/= _) _ _ FNN2P PM-L 
     ([o] implies/trans3
	(implies/conj2combine)
	(implies/combine
	   (implies/reflexive)
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty)))
	(implies/equiv equiv/identity)).

- : lookup-fldperm/L (fldmap2conj/norm/in F2C _ FM-SH _)
     (fldmap`lookup/> FM-L P) PF PD FNN2P PM-L
     ([o] implies/trans4
	(implies/conj2combine)
	(implies/combine 
	   (implies/trans
	      (implies/nonlinear bimplies/tt)
	      (implies/true2empty))
	   (I o))
	(implies/equiv equiv/commute)
	(implies/equiv equiv/identity))
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- fldmap`shift-preserves-lookup* FM-L FM-SH P'' FM-L'
     <- lookup-fldperm/L F2C FM-L' PF PD FNN2P PM-L I.

- : lookup-fldperm/L 
     (fldmap2conj/norm/out F2C
	(F2CF:{f} fldmap2conj _ _ _ ([r] CJ f r) _) 
	([f] PM-U f) _ _ _ PM-FS) _ PF PD FNN2P PM-L I
     <- predmap`size-total SZ-PM
     <- predmap`fresh-update-increases-size
	SZ-PM PM-FS (PM-U (conj2pred CJ)) SZ-PME
     <- fldmap2conj-implies-predmap-leq (F2CF (conj2pred CJ)) PME<=PMF
     <- predmap`size-total SZ-PMF
     <- predmap`leq-implies-size-le PME<=PMF SZ-PME SZ-PMF SZ-PMF>=PME
     <- fldmap2conj-implies-predmap-leq F2C PMF<=PM
     <- predmap`leq-implies-size-le PMF<=PM SZ-PMF SZ-PM SZ-PM>=PMF
     <- nat`ge-transitive SZ-PM>=PMF SZ-PMF>=PME SZ-PM>=PME
     <- nat`ge-transitive-gt SZ-PM>=PME nat`gt/1 SZ-PM>PM
     <- nat`gt-anti-reflexive SZ-PM>PM F
     <- lookup-fldperm/LL F PF PD FNN2P PM-L I.

%worlds (objvar) (lookup-fldperm/L _ _ _ _ _ _ _).
%total  F2C (lookup-fldperm/L F2C _ _ _ _ _ _).


% TODO: null case should be handled here

%theorem lookup-fldperm :
	forall* {CM} {PM} {FM} {C} {D} {F} {CJ} {NN}
	forall  {CM2PM: clsmap2predmap CM PM}
		{PM-L: predmap`lookup PM C (conj2pred CJ)}
		{CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (nulltp/norm D NN)}
	exists  {PF} {PD} 
                {F2C: fldmap2conj CM PM FM (CJ (conj2pred CJ)) PM}
                {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM D PD}
		{I: {o} implies 
		       (unitperm
			  (nonlinear (predcall (conj2pred CJ) (predargs/1 o))))
		       (unitperm (nonlinear ((nested (PF PD o) null own))))}
	true.

- : lookup-fldperm CM2PM PM-L CM-L FM-L PF PD F2C FNN2P PM-L' 
     ([o] implies/trans 
	(implies/nonlinear
	   (bimplies/trans
	      (bimplies/predcall/Y/inline)
	      (bimplies/trans
		 (bimplies/predcall/+/inline o)
		 (bimplies/predcall/0/inline))))
	(I o))
     <- clsmap2predmap-implies-fldmap2conj CM2PM PM-L CM-L F2C
     <- lookup-fldperm/L F2C FM-L PF PD FNN2P PM-L' I.

%worlds (objvar) (lookup-fldperm _ _ _ _ _ _ _ _ _ _).
%total  {} (lookup-fldperm _ _ _ _ _ _ _ _ _ _).

%theorem lookup-fldperm-converse :
	forall* {CM} {PM} {FM} {C} {D} {F} {CJ} {NN} {PD} 
	forall  {CM2PM: clsmap2predmap CM PM}
		{PM-L: predmap`lookup PM C (conj2pred CJ)}
		{CM-L: clsmap`lookup CM C FM}
                {FM-L: fldmap`lookup FM F (nulltp/norm D NN)}
                {PM-L: predmap`lookup PM D PD}
	exists  {PF} {FNN2P: fldnn2perm F NN PF}
                {F2C: fldmap2conj CM PM FM (CJ (conj2pred CJ)) PM}
		{I: {o} implies 
		       (unitperm
			  (nonlinear (predcall (conj2pred CJ) (predargs/1 o))))
		       (unitperm (nonlinear ((nested (PF PD o) null own))))}
	true.

%worlds (objvar) (lookup-fldperm-converse _ _ _ _ _ _ _ _ _).
%trustme %total  {} (lookup-fldperm-converse _ _ _ _ _ _ _ _ _).


%theorem get-precise-exists-converse :
        forall* {PM} {PF} {PD} {F} {C} {NN} {Pi} {FF}
        forall  {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM C PD}
                {NN2P: nn2perm NN FF}
        exists  {I: {o} implies
		       (combine 
			  (unitperm 
			     (nonlinear
				(nested (PF PD o) null own)))
			  (sharedPerm , Pi))
		       (combine
			  (unitperm 
			     (precise-exists o F 
				([r] (FF PD r))))
			  (combine
			     (unitperm
				(encumbered 
				   (unitperm
				      (precise-exists o F
					 ([r] (FF PD r))))
				   (sharedPerm)))
			     (Pi)))}
	true.       
      
%worlds () (get-precise-exists-converse _ _ _ _).
%trustme %total  {} (get-precise-exists-converse _ _ _ _).


%theorem get-precise-exists-single :
        forall* {PM} {NN} {F} {PF} {PD} {C} {FF}
        forall  {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM C PD}
		{NN2P: nn2perm NN FF}		      
        exists  {I: {o} implies
		     (combine
			(unitperm (nonlinear (nested (PF PD o) null own)))
			(sharedPerm))
		     (combine
			(unitperm (precise-exists o F ([r] (FF PD r))))
			(unitperm
			   (encumbered
			      (unitperm (precise-exists o F ([r] (FF PD r))))
			      (sharedPerm))))}
         true.
     
%worlds (objvar) (get-precise-exists-single _ _ _ _).
%trustme %total  {} (get-precise-exists-single _ _ _ _).


%theorem get-precise-exists :
        forall* {PM} {PF} {PD} {F} {C} {NN} {Pi}
        forall  {FNN2P: fldnn2perm F NN PF}
                {PM-L: predmap`lookup PM C PD}
        exists  {FF} {NN2P: nn2perm NN FF}
                {I: {o} implies
		       (combine 
			  (unitperm 
			     (nonlinear
				(nested (PF PD o) null own)))
			  (sharedPerm , Pi))
		       (combine
			  (unitperm 
			     (precise-exists o F 
				([r] (FF PD r))))
			  (combine
			     (unitperm
				(encumbered 
				   (unitperm
				      (precise-exists o F
					 ([r] (FF PD r))))
				   (sharedPerm)))
			     (Pi)))}
	true.       
				 
- : get-precise-exists
     fldnn2perm/yes _ _ nn2perm/yes
     ([o] implies/trans3
	(implies/equiv equiv/associate)
	(implies/combine implies/carve implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate))).

- : get-precise-exists 
     fldnn2perm/may _ _ nn2perm/may
     ([o] implies/trans3
	(implies/equiv equiv/associate)
	(implies/combine implies/carve implies/reflexive)
	(implies/equiv (equiv/symmetric equiv/associate))).

%worlds (objvar) (get-precise-exists _ _ _ _ _).
%total  {} (get-precise-exists _ _ _ _ _).



%theorem output/expr-format :
        forall* {PM} {Out} {PF} {Pi} {T} 
        forall  {PO: perm-output PM Pi (result/expr T) Out}
                {T2P: nulltp2perm PM T ([o] PF o)}
        exists  {E: environment`eq Out (output/exists [o] (output/expr o ((PF o) , Pi)))}
                {PO: perm-output PM Pi (result/expr T)
		      (output/exists [o] (output/expr o ((PF o) , Pi)))}
        true.

- : output/expr-format (perm-output/expr T2P1) T2P2 EEQ (perm-output/expr T2P2)
     <- nulltp2perm-deterministic T2P1 T2P2 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (EQ o))
     <- output/exists-preserves-eq EQ EEQ.

%worlds (objvar) (output/expr-format _ _ _ _).
%total  {} (output/expr-format _ _ _ _).


%%% conversion helper theorems

%theorem clsmap-nulltp-implies-nulltp2perm :
	forall* {CM} {PM} {T}
	forall  {CM2PM: clsmap2predmap CM PM}	     
	        {CM-T: clsmap-nulltp CM T}
	exists  {PF} {T2P: nulltp2perm PM T ([o] PF o)}
	true.		

- : clsmap-nulltp-implies-nulltp2perm
     CM2PM clsmap-nulltp/null _ nulltp2perm/null.

- : clsmap-nulltp-implies-nulltp2perm
     CM2PM (clsmap-nulltp/norm IN) _ (nulltp2perm/norm PM-LP NN2P)
     <- clsmap`in-implies-lookup IN _ CM-LP
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP
     <- nn2perm-total _ _ NN2P.

%worlds (objvar) (clsmap-nulltp-implies-nulltp2perm _ _ _ _).
%total  CM-T (clsmap-nulltp-implies-nulltp2perm _ CM-T _ _).
     

%theorem conversion-helper/write :
        forall* {W} {Pi} {E1} {E2} {PF1} {PF2}
        forall  {TYP1: typing W Pi E1
			(output/exists [r1] (output/expr r1 ((PF1 r1) , Pi)))}
                {TYP2: typing W Pi E2
			(output/exists [r2] (output/expr r2 ((PF2 r2) , Pi)))}
        exists  {TYP3: {r1} typing W ((PF1 r1) , Pi) E2
			(output/exists [r2]
			   (output/expr r2 ((PF1 r1) , ((PF2 r2) , Pi))))}
        true.

- : conversion-helper/write TYP1 TYP2 TYP3
     <- ({r1} typing-frame* TYP2 (envadd/exists [r2] (envadd/expr)) (TYP3 r1)).

%worlds (objvar) (conversion-helper/write _ _ _).
%total  {} (conversion-helper/write _ _ _).


%theorem conversion-helper/write3 :
        forall* {PF} {F: object -> permission} {Pi} {W} {E} {PM} {T}
        forall  {T2P: nulltp2perm PM T F}
                {TYP: typing W Pi E
		       (output/exists [r] (output/expr r ((PF r) , Pi)))}
        exists  {TYP: {r1} typing W ((F r1) , Pi) E
		       (output/exists [r2] 
			  (output/expr r2 ((F r1) , ((PF r2) , Pi))))}
        true.

- : conversion-helper/write3 _ TYPin TYPout
     <- ({r1} typing-frame* TYPin (envadd/exists [r2] (envadd/expr)) (TYPout r1)).

%worlds (objvar) (conversion-helper/write3 _ _ _).
%total  {} (conversion-helper/write3 _ _ _).


%theorem conversion-helper/write2/L :
	forall* {PF1} {PD1} {PD2} {PF2:nullpred -> object -> permission} 
        forall  {IMP: {o} implies (PF1 PD1 o) (combine (PF1 PD1 o) (PF1 PD1 o))}
		{EQ: {p}{o} permission`eq (PF1 p o) (PF2 p o)} 		       
                {EQ: predicate`eq PD1 PD2}
        exists  {IMP: {o} implies (PF1 PD1 o) (combine (PF2 PD2 o) (PF1 PD1 o))}
        true.

- : conversion-helper/write2/L I ([_][_] permission`eq/) predicate`eq/ I.

%worlds (objvar) (conversion-helper/write2/L _ _ _ _).
%total  {} (conversion-helper/write2/L _ _ _ _).


%theorem conversion-helper/write2 :
        forall* {PF:nullpred -> object -> permission} {PD} {Pi} {C} {NN} {PM} 
        forall  {NN2P: nn2perm NN ([p][o] PF p o)}
                {PM-FLP: predmap`lookup PM C PD}
                {T2P: nulltp2perm PM (nulltp/norm C NN) Pi}
        exists  {IMP: {o} implies (Pi o) (combine (PF PD o) (Pi o))}
        true.

- : conversion-helper/write2
     NN2P2 PM-FLP2 (nulltp2perm/norm PM-FLP1 NN2P1) IMP2
     <- predmap`lookup-deterministic PM-FLP1 PM-FLP2 predmap`eq/ nat`eq/ PDEQ
     <- nn2perm-deterministic NN2P1 NN2P2 nn`eq/ NNEQ
     <- clspred-can-be-duplicated (nulltp2perm/norm PM-FLP1 NN2P1) IMP1
     <- conversion-helper/write2/L IMP1 NNEQ PDEQ IMP2.

%worlds (objvar) (conversion-helper/write2 _ _ _ _).
%total  {} (conversion-helper/write2 _ _ _ _).


%theorem conversion-helper/let/L :
        forall* {PM} {T} {PF} 
        forall  {T2PF: {x:object} nulltp2perm PM T ([v] PF v)}
        exists  {T2P: nulltp2perm PM T ([v] PF v)}
        true.

- : conversion-helper/let/L ([_] nulltp2perm/null) nulltp2perm/null.

%worlds (objvar) (conversion-helper/let/L _ _).
%trustme %total  T2PF (conversion-helper/let/L T2PF _).


%theorem conversion-helper/let :
        forall* {PM} {PF:object -> permission} {Pi} {PF1} {PF2} {PF3} {Rslt}
        forall  {PO: {x} perm-output PM ((PF x) , Pi) Rslt 
		      (output/exists [o] (output/expr o ((PF1 o) , ((PF2 x o) , (PF3 o)))))}
        exists  {PO: perm-output PM Pi Rslt
		      (output/exists [o] (output/expr o ((PF1 o) , (PF3 o))))}
        true.

- : conversion-helper/let ([x] perm-output/expr (T2PF x)) (perm-output/expr T2P)
     <- conversion-helper/let/L T2PF T2P.


%worlds (objvar) (conversion-helper/let _ _).
%total  {} (conversion-helper/let _ _).


%theorem conversion-helper/let2/L :
        forall* {PDF:object -> nullpred} {PD} {NN}
                {PNF:nullpred -> object -> permission}
        forall  {NN2P: nn2perm NN PNF}
                {EQ: {o} predicate`eq (PDF o) PD}
        exists  {EQ: {r}{o} permission`eq (PNF (PDF o) r) (PNF PD r)}
        true.

- : conversion-helper/let2/L _ ([_] predicate`eq/) ([_][_] permission`eq/).

%worlds (objvar) (conversion-helper/let2/L _ _ _).
%total  {} (conversion-helper/let2/L _ _ _).


%theorem conversion-helper/let2 :
        forall* {PNF:nullpred -> object -> permission} {NN}
                {E} {W} {Pi: object -> permission} {PDF} {PD} 
        forall  {NN2P: nn2perm NN PNF}
                {EQ: {o} predicate`eq (PDF o) PD}
                {TYP: {o} typing W (Pi o) E 
		       (output/exists [r] 
			  (output/expr r ((PNF (PDF o) r) , (Pi o))))}
        exists  {TYP: {o} typing W (Pi o) E 
		       (output/exists [r] (output/expr r ((PNF PD r) , (Pi o))))}
        true.

- : conversion-helper/let2 NN2P ([o] EQF o) ([o] TYP o) ([o] TYP2 o)
     <- conversion-helper/let2/L NN2P ([o] EQF o) ([r][o] EQF2 r o)
     <- ({r}{o} combine-preserves-eq (EQF2 r o) permission`eq/ (CBEQ r o))
     <- ({r}{o} output/expr-preserves-eq object`eq/ (CBEQ r o) (OEQ r o))
     <- ({r} output/exists-preserves-eq ([o] OEQ o r) (EEQ r))
     <- ({o} typing-respects-eq (TYP o) progtype`eq/ permission`eq/
	   term`eq/ (EEQ o) (TYP2 o)).

%worlds (objvar) (conversion-helper/let2 _ _ _ _).
%total  {} (conversion-helper/let2 _ _ _ _).


%theorem conversion-helper/and/L :
        forall* {PM} {G} {Pi} {Rslt} {Out1}
        forall  {CPO: perm-output PM Pi Rslt Out1}
        exists  {Out2} {Out3} 
                {AH2: andHelp2 G Out1 Pi Out2}
                {T: transform Out2 Out3}
                {CPO: perm-output PM Pi Rslt Out3}
        true.

- : conversion-helper/and/L
     perm-output/cond _ _ andHelp2/base 
     (transform/cond
	(bimplies/reflexive)
	(bimplies/reflexive)
	(implies/reflexive)
	(implies/cond-equal))
     perm-output/cond.

- : conversion-helper/and/L 
     (perm-output/exists ([v] (CPO1 v)))
     (output/exists ([v] (Out2 v)))
     (output/exists ([v] (Out3 v)))
     (andHelp2/exists ([v] AH2 v))
     (transform/inside ([v] (T v)))
     (perm-output/exists ([v] (CPO3 v)))
     <- ({v:object} conversion-helper/and/L
	   (CPO1 v) (Out2 v) (Out3 v) (AH2 v) (T v) (CPO3 v)).

%worlds (objvar) (conversion-helper/and/L _ _ _ _ _ _).
%total CPO (conversion-helper/and/L CPO _ _ _ _ _).


%theorem conversion-helper/and :
        forall* {W} {Pi} {PM} {Out1} {Out2} {C}
        forall  {CPO: perm-output PM Pi result/cond Out1}
                {TYP: typing W Pi C Out2}
        exists  {Out3} {Out4} 
                {AH: andHelp1 W Out1 C Out3} 
                {T: transform Out3 Out4}
                {CPO: perm-output PM Pi result/cond Out4}
        true.

- : conversion-helper/and
     perm-output/cond TYP Out3 Out4 (andHelp1/base TYP AH2) T CPO
     <- conversion-helper/and/L perm-output/cond Out3 Out4 AH2 T CPO.

- : conversion-helper/and
     (perm-output/exists ([v] CPO v)) TYP (output/exists ([v] Out3 v))
     (output/exists ([v] Out4 v)) (andHelp1/exists ([v] (AH1 v)))
     (transform/inside ([v] T v)) (perm-output/exists ([v] CPO' v))
     <- ({v} conversion-helper/and
	   (CPO v) TYP (Out3 v) (Out4 v) (AH1 v) (T v) (CPO' v)).

%worlds (objvar) (conversion-helper/and _ _ _ _ _ _ _).
%trustme %total CPO (conversion-helper/and CPO _ _ _ _ _ _).


%theorem conversion-helper/not/L :
        forall* {PM} {Pi} {Out}
        forall  {CPO: perm-output PM Pi result/cond Out}
        exists  {Out'} {N: notEnv Out Out'}
		{CPO: perm-output PM Pi result/cond Out'}		    
        true.

- : conversion-helper/not/L
     perm-output/cond _ notEnv/base perm-output/cond.

- : conversion-helper/not/L (perm-output/exists ([v] CPO v)) 
     (output/exists ([v] Out' v)) (notEnv/exists ([v] NV v))
     (perm-output/exists ([v] CPO' v))
     <- ({v:object} conversion-helper/not/L (CPO v) (Out' v) (NV v) (CPO' v)).
     
%worlds (objvar) (conversion-helper/not/L _ _ _ _).
%total C (conversion-helper/not/L C _ _ _).


%theorem conversion-helper/not :
        forall* {W} {PM} {Pi} {C} {COut} 
        forall  {TYP: typing W Pi C COut}
                {CPO: perm-output PM Pi result/cond COut}
        exists  {COut'} {TYP: typing W Pi (not C) COut'}
                {CPO: perm-output PM Pi result/cond COut'}
        true.

- : conversion-helper/not TYP CPO Out (tNot TYP NV) CPO'
     <- conversion-helper/not/L CPO Out NV CPO'.

%worlds (objvar) (conversion-helper/not _ _ _ _ _).
%total  {} (conversion-helper/not _ _ _ _ _).


%theorem conversion-helper/if :
        forall* {W} {PM} {Pi} {E1} {E2} 
                {COut} {EOut:output exprk} {CRslt:result condk} {ERslt} 
        forall  {TYP: typing W Pi E1 EOut}
                {TYP: typing W Pi E2 EOut}
                {EPO: perm-output PM Pi ERslt EOut}
                {CPO: perm-output PM Pi CRslt COut}
        exists  {EOut'} {TYP: ifTyping W COut E1 E2 EOut'}
                {T: transform EOut' EOut}
        true.

- : conversion-helper/if
     TYP1 TYP2 P-O perm-output/cond _ 
     (ifTyping/base TYP1 TYP2) transform/reflexive.

- : conversion-helper/if
     TYP1 TYP2 EPO (perm-output/exists ([v] CPO v))
     (output/exists ([v] EOut v)) (ifTyping/exists ([v] IFT v)) 
     (transform/trans
	(transform/inside ([v] T v))
	(transform/rem-unused))
     <- ({v:object} conversion-helper/if
	TYP1 TYP2 EPO (CPO v) (EOut v) (IFT v) (T v)).

%worlds (objvar) (conversion-helper/if _ _ _ _ _ _ _).
%total  (PO) (conversion-helper/if _ _ _ PO _ _ _).


%theorem conversion-helper/while :
	forall* {PM} {W} {Pi} {COut} {E} 
	forall  {TYP: typing W Pi E (output/exists ([v] (output/expr v Pi)))}
                {CPO: perm-output PM Pi result/cond COut}
	exists  {Out1} {Out2} {Out4}
                {WT: whileTyping W COut E Out1 Out2}
                {D: discard-value Out1 Out4}
		{T: transform Out4 (output/expr null Pi)}	    
		{T: transform Out2 (output/expr null Pi)}		    
        true.

- : conversion-helper/while TYP perm-output/cond _ _ _ 
     (whileTyping/base TYP)
     (discard-value/exists ([v] (discard-value/base)))
     (transform/rem-unused)
     (transform/reflexive).

- : conversion-helper/while TYP (perm-output/exists ([v] CPO v)) _ _ _
     (whileTyping/exists ([v] WT v))
     (discard-value/exists ([v] DV v))
     (transform/trans (transform/inside ([v] T1 v)) (transform/rem-unused))
     (transform/trans (transform/inside ([v] T2 v)) (transform/rem-unused))
     <- ({v:object} conversion-helper/while TYP (CPO v) _ _ _ 
	   (WT v) (DV v) (T1 v) (T2 v)).
	   
%worlds (objvar) (conversion-helper/while _ _ _ _ _ _ _ _ _).
%total  CPO (conversion-helper/while _ CPO _ _ _ _ _ _ _).    


%theorem conversion-helper/subL :
        forall* {NN1} {NN2}
	        {PF1} {PF2} {PD1} {PD2}
        forall  {SUB: nn`subtype NN1 NN2}
		{EQ: nullpred`eq PD1 PD2}		   
	        {NN2P: nn2perm NN1 ([p][r] PF1 p r)}
		{NN2P: nn2perm NN2 ([p][r] PF2 p r)}
	exists  {T: {r} implies (PF1 PD1 r) (PF2 PD2 r)}
 	true.
		   
- : conversion-helper/subL nn`subtype/ref nullpred`eq/
     NN2P NN2P ([_] implies/reflexive).

- : conversion-helper/subL nn`subtype/my nullpred`eq/
     nn2perm/yes nn2perm/may 
     ([_] (implies/trans
       (implies/conj2combine) (implies/cond-intro-neg))).

%worlds (objvar) (conversion-helper/subL _ _ _ _ _).
%total SB (conversion-helper/subL SB _ _ _ _).


%theorem conversion-helper/sub :
	forall* {PM} {T} {T'} {PF} {PF'}
	forall  {SUB: sub T T'}
	        {T2P: nulltp2perm PM T PF}
                {T2P: nulltp2perm PM T' PF'}
        exists  {T: {o} implies (PF o) (PF' o)}
	true.			  

- : conversion-helper/sub 
     sub/uu nulltp2perm/null nulltp2perm/null ([_] implies/reflexive).

- : conversion-helper/sub
     sub/uo nulltp2perm/null (nulltp2perm/norm _ nn2perm/may)
     ([_] implies/trans
	(implies/equiv
	   (equiv/symmetric equiv/identity))
	(implies/cond-intro)).

- : conversion-helper/sub
     (sub/oo NN1<=NN2)
     (nulltp2perm/norm (PM-LP1) NN2P1) 
     (nulltp2perm/norm (PM-LP2) NN2P2) I
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ EQ
     <- conversion-helper/subL NN1<=NN2 EQ NN2P1 NN2P2 ([o] I o).
			  
%worlds (objvar) (conversion-helper/sub _ _ _ _).
%total SB (conversion-helper/sub SB _ _ _).


%theorem conversion-helper/callmeth/L :
        forall* {PM} {CM} {MM} {MT} {PT} {Pi} {Pi1} {Pi2}
                {ARslt} {AOut} {W} {T} {PF}
	forall  {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W} 
                {T2P: nulltp2perm PM T PF}		   
                {I: implies Pi (Pi1 , Pi)}
		{EQV: equiv Pi (sharedPerm , Pi2)}			 
	        {NTYPC: nullCallTyping CM MM ARslt MT (result/expr T)}
                {APO: perm-output PM Pi ARslt AOut}
                {MT2PT: methtp2proctype* PM Pi1 MT PT}
	exists  {AOut'} {TA: transform AOut AOut'}
		{Out} {CTYP: callTyping W AOut' PT Out}	
		{TE: transform Out (output/exists ([r] (output/expr r ((PF r) , Pi))))}
	true.	   
- : conversion-helper/callmeth/L
     CM2PM MM2W T2P1 I EQV nullCallTyping/call perm-output/args/0
     (methtp2proctype*/base T2P2) %{=>}% 
     _ (transform/args/0
	(implies/trans4
	   (I)
	   (implies/combine implies/reflexive (implies/equiv EQV))
	   (implies/equiv equiv/roll2)
	   (implies/equiv equiv/associate)))
     _ (callTyping/call (envadd/exists ([_] envadd/expr))) 
     (transform/inside [o]
	(transform/implies
	   (implies/trans5
	      (implies/equiv equiv/roll2)
	      (implies/equiv equiv/associate)
	      (implies/combine
		 (implies/equiv (equiv/symmetric EQV))
		 (implies/reflexive))
	      (implies/equiv equiv/commute)
	      (implies/combine
		 (implies/equiv (EQV2 o)) 
		 (implies/reflexive)))))
     <- nulltp2perm-deterministic T2P2 T2P1 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} permission`eq-implies-equiv (PFEQ o) (EQV2 o)).

- : conversion-helper/callmeth/L
     CM2PM MM2W T2Pout I EQV (nullCallTyping/arg ([o] NTYPC o))
     (perm-output/args/+ ([o] APO o) T2P1) 
     (methtp2proctype*/arg ([o] MT2PT2 o) T2P2) %{=>}% 
     _ (transform/inside ([o] (transform/args/+ (TA o))))
     _ (callTyping/exists ([o] (callTyping/arg o (CTYP o))))
     (transform/trans
	(transform/inside [r]
	   (transform/trans
	      (TE r)
	      (transform/inside [o]
		 (transform/implies
		    (implies/combine 
		       (implies/reflexive)
		       (implies/trans3
			  (implies/combine (EP r) implies/reflexive)
			  (implies/equiv equiv/commute)
			  (implies/equiv equiv/identity)))))))
	(transform/rem-unused))
     <- clspred-can-be-duplicated T2P1 ([o] DP o)
     <- clspred-implies-empty T2P1 ([o] EP o)
     <- nulltp2perm-deterministic T2P2 T2P1 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} methtp2proctype-respects-eq*
	   (MT2PT2 o) predmap`eq/ (PEQ o) methtp`eq/ proctype`eq/ (MT2PT1 o))
     <- ({o} conversion-helper/callmeth/L
	   CM2PM MM2W T2Pout
	   (implies/trans4
	      (implies/combine (DP o) I)
	      (implies/equiv (equiv/symmetric equiv/associate))
	      (implies/combine implies/reflexive (implies/equiv equiv/roll2))
	      (implies/equiv equiv/associate))
	   (equiv/transitive 
	      (equiv/combine equiv/reflexive EQV)
	      (equiv/roll2)) %{ Now the new 'Pi2' is ((PF o) , Pi2) }%
	   (NTYPC o) (APO o) (MT2PT1 o) _ (TA o) _ (CTYP o) (TE o)).

%worlds (objvar) (conversion-helper/callmeth/L _ _ _ _ _ _ _ _ _ _ _ _ _).
%total NTYPA (conversion-helper/callmeth/L _ _ _ _ _ _ NTYPA _ _ _ _ _ _).


%%% Main theorem: in this case, Pi1 is empty

%theorem conversion-helper/callmeth :
        forall* {PM} {CM} {MM} {MT} {PT} {Pi} {W}
                {ARslt} {T} {AOut} {L} 
	forall  {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}		   
                {CM-MT: clsmap-methtp CM MT}
		{L2P: oflist2perm PM L Pi}   
	        {NTYPC: nullCallTyping CM MM ARslt MT (result/expr T)}
                {APO: perm-output PM Pi ARslt AOut}
                {MT2PT: methtp2proctype PM MT PT}
	exists  {AOut'} {TA: transform AOut AOut'}
		{Out} {CTYP: callTyping W AOut' PT Out}
		{PF} {TS: transform Out
			   (output/exists ([r] (output/expr r ((PF r) , Pi))))}
		{T2P: nulltp2perm PM T ([r] PF r)}		       
	true.	   

- : conversion-helper/callmeth
     CM2PM MM2W CM-MT L2P NTYPC APO MT2PT
     %{=>}% _ TA _ CTYP _ TS T2P
     <- writeshared-can-move-front L2P _ EQV
     <- clsmap-methtp-implies-clsmap-nulltp CM-MT NTYPC CM-T
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T _ T2P
     <- conversion-helper/callmeth/L CM2PM MM2W T2P 
	(implies/equiv
	   (equiv/transitive 
	      (equiv/symmetric equiv/identity)
	      (equiv/commute)))
	EQV NTYPC APO MT2PT _ TA _ CTYP TS.
     
%worlds (objvar) (conversion-helper/callmeth _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  {} (conversion-helper/callmeth _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem fldmap-domain-implies-allocfields/L :
        forall* {FM} {S}
        forall  {N} {SZ: fldmap`size FM N} {FM-DM: fldmap`domain FM S}
        exists  {OS} {AF: {t} allocFields t S (OS t)}
        true.

- : fldmap-domain-implies-allocfields/L z _ fldmap`domain/0 _ ([_] allocFields/0).
     
- : fldmap-domain-implies-allocfields/L (s N) (fldmap`size/+ SZ)
     (fldmap`domain/+ FM-DM) _ ([t] allocFields/+ SH (AF t))
     <- fldmap`shift-total FM-SH
     <- fldmap`shift-preserves-size SZ FM-SH SZ'
     <- fldmap`shift-preserves-domain FM-DM FM-SH _ SH FM-DM'
     <- fldmap-domain-implies-allocfields/L N SZ' FM-DM' _ ([t] AF t).
	
%worlds (objvar) (fldmap-domain-implies-allocfields/L _ _ _ _ _).
%total (N) (fldmap-domain-implies-allocfields/L N _ _ _ _).


%theorem fldmap-domain-implies-allocfields :
        forall* {FM} {S}
        forall  {DM: fldmap`domain FM S}
        exists  {OS} {AF: {t} allocFields t S (OS t)}
        true.

- : fldmap-domain-implies-allocfields DM OS ([t] AF t)
     <- fldmap`size-total SZ
     <- fldmap-domain-implies-allocfields/L _ SZ DM OS ([t] AF t).

%worlds (objvar) (fldmap-domain-implies-allocfields _ _ _).
%total  {} (fldmap-domain-implies-allocfields _ _ _).


%theorem envadd-alloc-fields :
        forall* {W} {Pi} {S} {A} {C} {OS} {OA}
        forall  {AF: {t} allocFields t S (OS t)}
                {TYP: typing W Pi A OA}
        exists  {OA'} {EA: {t} envadd (OS t) OA (OA' t)}
		{TYP: typing W Pi (args/+ (alloc C S set/0) A) 
		       (output/exists [t] (output/args/+ t (OA' t)))}
        true.

- : envadd-alloc-fields AF TYP _ ([t] EA t)
     (tArgs1
	(tTrans2 (tAlloc ([t] AF t))
	   (transform/inside [t]
	      (transform/implies
		 (implies/equiv equiv/commute))))
	(letTyping/exists [t]
	   (letTyping/base t (tArgs (TYP2 t)))))
     <- ({t} typing-frame TYP _ (EA t) (TYP2 t)).

%worlds () (envadd-alloc-fields _ _ _ _ _).
%total  {} (envadd-alloc-fields _ _ _ _ _).


%theorem conversion-helper/callconst/L :
        forall* {CM} {PM} {MM} {W} {Pi} {Pi2} {Pi1}
                {OS:object -> permission} {PTF}
                {OA} {OA'} {RA} {MTF} {T} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
		{EA: {t} envadd (OS t) OA (OA' t)}
                {I: {t} implies ((OS t) , Pi) ((Pi1 t) , Pi)}
                {EQV: equiv Pi (sharedPerm , Pi2)}
                {APO: perm-output PM Pi RA OA}
                {NTYP: {t} nullCallTyping CM MM RA (MTF t) (result/expr T)}
                {CT2PT: {t} methtp2proctype* PM (Pi1 t) (MTF t) (PTF t)}
        exists  {OA''} {TA: {t} transform (OA' t) (OA'' t)}
                {OP} {CTYP: {t} callTyping W (OA'' t) (PTF t) (OP t)}
                {PF} {T2P: nulltp2perm PM T PF}
                {TE: {t} transform (OP t)
		      (output/exists [rt] (output/expr rt ((PF rt) , Pi))) }
        true.

- : conversion-helper/callconst/L _ _
     ([t] envadd/args/0) ([t] IMP t) EQV perm-output/args/0
     ([t] nullCallTyping/call) ([t] methtp2proctype*/base (T2PF t))
     %{=>}% 
     _ ([t] transform/args/0
	  (implies/trans4
	     (IMP t)
	     (implies/combine 
		(implies/reflexive) 
		(implies/equiv EQV))
	     (implies/equiv equiv/roll2)
	     (implies/equiv equiv/associate)))
     _ ([t] callTyping/call (envadd/exists [rt] (envadd/expr)))
     _ T2P
     ([t] (transform/inside [rt]
	(transform/implies
	   (implies/trans5
	      (implies/equiv equiv/roll2)
	      (implies/equiv equiv/associate)
	      (implies/combine
		 (implies/equiv (equiv/symmetric EQV))
		 (implies/reflexive))
	      (implies/equiv equiv/commute)
	      (implies/combine
		 (implies/equiv (EQV2 t rt)) 
		 (implies/reflexive))))))
     <- conversion-helper/let3 ([r] T2PF r) _ ([r][o] EQF r o) T2P
     <- ({r}{o} permission`eq-implies-equiv (EQF r o) (EQV2 r o)).

- : conversion-helper/callconst/L
     CM2PM MM2W ([t] (envadd/exists [o] (envadd/args/+ (EA t o)))) ([t] I t) EQV
     (perm-output/args/+ ([o] APO o) T2P1)
     ([t] nullCallTyping/arg ([o] (NCTYP t o)))  
     ([t] methtp2proctype*/arg (CT2PT2 t) (T2P2F t)) %{=>}%
     _ ([t] transform/inside ([o] transform/args/+ (TA t o))) 
     _ ([t] callTyping/exists ([o] (callTyping/arg o (CTYP t o))))
     _ T2Pout
     ([t] transform/trans
	(transform/inside [o]
	   (transform/trans
	      (TE t o)
	      (transform/inside [rt]
		 (transform/implies
		    (implies/combine
		       (implies/equiv (EQV2 o rt))
		       (implies/trans3
			  (implies/combine (EP o) implies/reflexive)
			  (implies/equiv equiv/commute)
			  (implies/equiv equiv/identity)))))))
	(transform/rem-unused))
     <- clspred-can-be-duplicated T2P1 ([o] DP o)
     <- clspred-implies-empty T2P1 ([o] EP o)
     <- ({t} nulltp2perm-deterministic
	   (T2P2F t) T2P1 predmap`eq/ nulltp`eq/ ([o] PFEQ t o))
     <- ({t}{o} combine-preserves-eq (PFEQ t o) permission`eq/ (PEQ t o))
     <- ({t}{o} methtp2proctype-respects-eq*
	   (CT2PT2 t o) predmap`eq/ (PEQ t o) methtp`eq/ proctype`eq/ (CT2PT1 t o))
     <- ({o} conversion-helper/callconst/L
	   CM2PM MM2W ([t] EA t o) 
	   ([t] implies/trans5
	      (implies/equiv equiv/roll2)
	      (implies/combine (DP o) (I t))
	      (implies/equiv (equiv/symmetric equiv/associate))
	      (implies/combine 
		 (implies/reflexive)
		 (implies/equiv equiv/roll2))
	      (implies/equiv equiv/associate))
	   (equiv/transitive 
	      (equiv/combine equiv/reflexive EQV)
	      (equiv/roll2))
	   (APO o) ([t] NCTYP t o) ([t] CT2PT1 t o)
	   _ ([t] TA t o) _ ([t] CTYP t o) _ (T2PoutF o) ([t] TE t o))
     <- conversion-helper/let3 ([r] T2PoutF r) _ ([r][o] EQF r o) T2Pout
     <- ({r}{o} permission`eq-implies-equiv (EQF r o) (EQV2 r o)).

%worlds (objvar) (conversion-helper/callconst/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total A (conversion-helper/callconst/L _ _ _ _ _ _ A _ _ _ _ _ _ _ _).
