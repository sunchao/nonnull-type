%%%%% conversion-thms.elf
%%%%% Theorems about conversion
%%%%% $Id: conversion-thms.elf,v 1.15 2010/11/24 04:59:04 csun Exp csun $

%theorem convert/expr-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {T} {E: term exprk} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL E (result/expr T)}
        exists  {PF} {T2P: nulltp2perm PM T ([r] PF r)}
                {TYP: typing W Pi E
		       (output/exists [r] (output/expr r ((PF r) , Pi)))}
        true.

%theorem convert/cond-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {C: term condk} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL C result/cond}
        exists  {Out: output condk} {TYP: typing W Pi C Out}
                {PM: perm-output PM Pi result/cond Out}
        true.

%theorem convert/args-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {A: term argsk} {ARslt}
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL A ARslt}
        exists  {AOut: output argsk} {TYP: typing W Pi A AOut}
                {PM: perm-output PM Pi ARslt AOut}
        true.

- : convert/cond-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltNot NTYP) _ TYP' CPO'
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP _ TYP CPO
     <- conversion-helper/not TYP CPO _ TYP' CPO'.

- : convert/cond-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltAnd NTYP1 NTYP2) _
     (tTrans2 (tAnd TYP1 AH) T) CPO4
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP1 _ TYP1 CPO1
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP2 _ TYP2 CPO2
     <- conversion-helper/and CPO1 TYP2 _ Out4 AH T CPO4.

- : convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltEql NTYPE1 NTYPE2) _ 
     (tEql1
	TYPE1
	(letTyping/exists [v1]
	   (letTyping/base v1
	      (tEql2
		 (TYPE2' v1)
		 (letTyping/exists [v2]
		    (letTyping/base v2
		       (tTrans2
			  (tEql:typing _ _ (eql (lit v1) (lit v2)) _)
			  (transform/cond
			     (bimplies/reflexive)
			     (bimplies/reflexive)
			     (implies/trans3
				(implies/combine
				   (implies/trans
				      (implies/nonlinear bimplies/tt)
				      (implies/true2empty))
				   (implies/trans5
				      (implies/combine
					 (REM1 v1) 
					 (implies/combine
					    (REM2 v2)
					    (implies/reflexive)))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)))
				(implies/equiv equiv/commute)
				(implies/equiv equiv/identity))
			     (implies/trans3
				(implies/combine
				   (implies/trans
				      (implies/nonlinear bimplies/tt)
				      (implies/true2empty))
				   (implies/trans5
				      (implies/combine
					 (REM1 v1) 
					 (implies/combine
					    (REM2 v2)
					    (implies/reflexive)))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)))
				(implies/equiv equiv/commute)
				(implies/equiv equiv/identity))))))))))
     (perm-output/exists ([v1] (perm-output/exists ([v2] (perm-output/cond)))))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE1 _ T2P1 TYPE1
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE2 _ T2P2 TYPE2
     <- conversion-helper/write3 T2P1 TYPE2 ([v] TYPE2' v)
     <- clspred-implies-empty T2P1 ([r] REM1 r)
     <- clspred-implies-empty T2P2 ([r] REM2 r).

- : convert/expr-ok _ _ _ _ _ L2P (nulltLit L) _ T2P 
     (tTrans2 tObjLoc 
	(transform/trans
	   (transform/implies I)
	   (transform/gen-exists _)))
   <- oflist-lookup-implies-clspred _ L L2P _ T2P I.

- : convert/expr-ok _ _ _ _ _ _ nulltNull _ nulltp2perm/null
     (tTrans2 tObjLoc 
	(transform/trans
	   (transform/implies
	      (implies/trans3
		 (implies/equiv (equiv/symmetric equiv/identity))
		 (implies/equiv equiv/commute)
		 (implies/combine
		    (implies/trans
		       (implies/empty2true)
		       (implies/nonlinear bimplies/objequal-reflexive))
		    (implies/reflexive))))
	   (transform/gen-exists null))).

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-OFL MM2W L2P (nulltLet ([o] NTYPF o) NTYPE)
     _ T2POut 
     (tTrans2
	(tLet 
	   TYPE
	   (letTyping/exists [x]
	      (letTyping/base x
		 (tTrans2
		    (TYPF2 x)
		    (transform/inside [r]
		       (transform/implies
			  (implies/trans4
			     (implies/equiv equiv/roll2)
			     (implies/combine
				(I x)
				(implies/reflexive))
			     (implies/equiv equiv/commute)
			     (implies/equiv equiv/identity))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W L2P NTYPE _ T2P TYPE
     <- typing-implies-clsmap-nulltp CM-CM CM-MM CM-OFL NTYPE CM-T
     <- ({o} convert/expr-ok CM2PM CM-CM CM-MM 
	   (clsmap-oflist/+ CM-T CM-OFL) MM2W (oflist2perm/+ T2P L2P)
	   (NTYPF o) _ (T2POutF o) (TYPF o))
     <- conversion-helper/let3 ([o] T2POutF o) PF ([o][o1] EQ o o1) T2POut
     <- conversion-helper/let4 EQ TYPF TYPF2
     <- clspred-implies-empty T2P ([r] I r).
	   
- : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltWhile NTYPE NTYPC) _ nulltp2perm/null
     (tTrans2 (tWhile (transform/reflexive) (letTyping/base null TYPC) WT DV T1) 
	(transform/trans3 T2
	   (transform/implies
	      (implies/trans3
		 (implies/equiv (equiv/symmetric equiv/identity))
		 (implies/equiv equiv/commute)
		 (implies/combine
		    (implies/trans
		       (implies/empty2true)
		       (implies/nonlinear bimplies/objequal-reflexive))
		    (implies/reflexive))))
	   (transform/gen-exists null)))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE _ _ TYPE
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPC _ TYPC CPO
     <- conversion-helper/while
	(tTrans2 TYPE (transform/inside ([v] transform/drop))) 
	CPO _ _ _ WT DV T1 T2.

- : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltSub NTYPE CM-T' SUB) _ T2P'
     (tTrans2 
	TYPE
	(transform/inside [r]
	   (transform/implies
	      (implies/combine
		 (I r)
		 (implies/reflexive)))))
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T' _ T2P'
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE _ T2P TYPE 
     <- conversion-helper/sub SUB T2P T2P' ([o] I o).

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltIf NTYPE2 NTYPE1 NTYPC) 
     PF2 T2P2 (tTrans2 (tIf TYPC IFTYP) T) 
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPC XX TYPC CPO
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE1 PF1 T2P1 TYP1 
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE2 PF2 T2P2 TYP2
     <- nulltp2perm-deterministic T2P1 T2P2 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- output/exists-preserves-eq OEQ OEQ'
     <- typing-respects-eq TYP1 progtype`eq/ permission`eq/ term`eq/ OEQ' TYP1'
     <- conversion-helper/if TYP1' TYP2 (perm-output/expr T2P2) CPO YY IFTYP T.


- : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltIfNotNull NTYP1 NTYP2 (OF-LP:oflist-lookup _ O _)) _ T2P2
     (tIf 
	(tTrans2 (tNot tEql notEnv/base)
	   (transform/cond
	      (bimplies/reflexive)
	      (bimplies/reflexive)
	      (implies/trans3
		 (implies/combine implies/reflexive I1)
		 (implies/equiv equiv/associate)
		 (implies/combine
		    (I2 O)
		    (implies/reflexive)))
	      (implies/trans3
		 (implies/combine
		    (implies/trans
		       (implies/nonlinear bimplies/tt)
		       (implies/true2empty))
		    (implies/reflexive))
		 (implies/equiv equiv/commute)
		 (implies/equiv equiv/identity))))
	(ifTyping/base 
	   (tTrans2 TYP1'
	      (transform/inside [_]
		 (transform/implies
		    (implies/combine
		       (implies/reflexive)
		       (implies/trans3
			  (implies/combine
			     (implies/trans
				(implies/nonlinear bimplies/tt)
				(implies/true2empty))
			     (implies/reflexive))
			  (implies/equiv equiv/commute)
			  (implies/equiv equiv/identity))))))
	   TYP2))
     <- oflist-lookup-implies-clsmap-nulltp CM-L OF-LP (clsmap-nulltp/norm IN)
     <- oflist-lookup-implies-clspred _ OF-LP L2P _ (nulltp2perm/norm PM-LP NN2P) I1
     <- clspred-remove-cond PM-LP NN2P ([o] I2 o)
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP2 PF2 T2P2 TYP2
     <- convert/expr-ok CM2PM CM-CM CM-MM
	(clsmap-oflist/+ (clsmap-nulltp/norm IN) CM-L) 
	MM2W (oflist2perm/+ (nulltp2perm/norm PM-LP nn2perm/yes) L2P) 
	NTYP1 PF1 T2P1 TYP1
     <- nulltp2perm-deterministic T2P1 T2P2 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- output/exists-preserves-eq OEQ OEQ'
     <- typing-respects-eq TYP1 progtype`eq/ permission`eq/ term`eq/ OEQ' TYP1'.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltCallMeth NTYPC NTYPA MM-LP CM-FS) 
     PF T2P (tTrans2 (tCall W-LP (tTrans2 TYPA TA) TYPC) TO) 
     <- lookup-implies-clsmap-methtp CM-MM MM-LP CM-MT
     <- methmap2progtype-implies-methtp2proctype MM2W CM-FS MM-LP PT W-LP MT2PT
     <- convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPA _ TYPA APO
     <- conversion-helper/callmeth 
	CM2PM MM2W CM-MT L2P NTYPC APO MT2PT AOut' TA Out TYPC PF TO T2P.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P 
     (nulltCallConst FM-DM1 ([t] NTYPC t) NTYPA MM-LP CM-LP) _ T2P
     (tTrans2
	(tCall W-LP
	   (tTrans2
	      (tArgs1
		 (tTrans2 (tAlloc ([t] AF1 t))
		    (transform/inside [t]
		       (transform/implies
			  (implies/equiv equiv/commute))))
		 (letTyping/exists [t]
		    (letTyping/base t (tArgs (TYP2 t)))))
	      (transform/inside [t]
		 (transform/args/+ (TA t))))
	   (callTyping/exists [t]
	      (callTyping/arg t (CTYP t))))
	(transform/trans
	   (transform/inside [t] (TE t))
	   (transform/rem-unused)))
     <- methmap2progtype-implies-constp2proctype 
	MM2W CM-LP MM-LP _ W-LP (constp2proctype/ ([t] MT2PT t) ([t] AF2 t) FM-DM2)
     <- fldmap`domain-deterministic FM-DM2 FM-DM1 fldmap`eq/ SEQ
     <- allocFields-respects-eq ([t] AF2 t) SEQ ([t] permission`eq/) ([t] AF1 t)
     <- convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPA _ TYPA APO
     <- ({t} typing-frame TYPA _ (EA t) (TYP2 t))
     <- writeshared-can-move-front L2P _ EQV
     <- conversion-helper/callconst/L 
	CM2PM MM2W EA ([t] implies/reflexive) EQV APO ([t] NTYPC t)
	([t] MT2PT t) _ ([t] TA t) _ ([t] CTYP t) _ T2P TE.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P
     (nulltRead FM-LP CM-LP NTYP) _ (nulltp2perm/norm PM-FLP NN2P)
     (tTrans2
	(tRead1 
	   TYPE'
	   (letTyping/exists [v]
	      (letTyping/base v
		 (tTrans
		    (transform/trans3 
		       (transform/implies
			  (implies/trans3
			     (implies/combine
				(implies/trans6
				   (implies/conj2combine)
				   (implies/trans3
				      (implies/combine
					 (implies/trans
					    (implies/nonlinear bimplies/tt)
					    (implies/true2empty))
					 (implies/reflexive))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity))
				   (implies/conj2combine)
				   (implies/combine
				      (implies/trans
					 (implies/nonlinear bimplies/tt)
					 (implies/true2empty))
				      (I1 v))
				   (implies/equiv equiv/commute)
				   (implies/equiv equiv/identity))
				(implies/equiv EQV))
			     (I2 v) 
			     (implies/combine 
				(implies/equiv (equiv/symmetric equiv/one))
				(implies/reflexive))))
		       (transform/skolem) 
		       (transform/inside 
			  ([r] 
			     (transform/implies
				(implies/trans
				   (implies/combine
				      (implies/equiv equiv/distribute)
				      (implies/reflexive))
				   (implies/equiv
				      (equiv/symmetric equiv/associate)))))))
		    (letTyping/exists 
		       ([r] 
			  (letTyping/base null
			     (tRead:typing _ _ (read (lit v) _) _))))
		    (transform/inside
		       ([r] 
			  (transform/implies
			     (implies/trans8
				(implies/equiv equiv/associate)
				(implies/combine
				   (implies/trans5
				      (implies/equiv
					 (equiv/symmetric equiv/distribute))
				      (implies/equiv equiv/one)
				      (implies/combine
					 (implies/reflexive)
					 (DUP r))
				      (implies/equiv equiv/associate)
				      (implies/combine
					 (implies/pack r) (implies/reflexive)))
				   (implies/reflexive))
				(implies/equiv
				   (equiv/symmetric equiv/associate))
				(implies/combine
				   (implies/reflexive)
				   (implies/equiv equiv/roll2))
				(implies/equiv equiv/associate)
				(implies/combine
				   (implies/linear-modus-ponens) 
				   (implies/reflexive))
				(implies/equiv equiv/roll2)
				(implies/combine
				   (implies/reflexive)
				   (implies/equiv (equiv/symmetric EQV)))))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP 
	_ (nulltp2perm/norm PM-LP1 nn2perm/yes) TYPE
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP2
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ PEQ
     <- typing-preserves-eq nn2perm/yes PEQ TYPE TYPE'
     <- writeshared-can-move-front OFL2P _ EQV
     <- lookup-fldperm CM2PM PM-LP2 CM-LP FM-LP _ _ _ FNN2P PM-FLP I1
     <- get-precise-exists FNN2P PM-FLP _ NN2P I2
     <- clspred-can-be-duplicated (nulltp2perm/norm PM-FLP NN2P) DUP.

%%% for lookup-fldperm, I assume it will get a (conj2pred CJ), however, 
%%% PM-LP doesn't know this, it gave a more generic result.

- : convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P
     (nulltWrite FM-LP CM-LP NTYPE2 NTYPE1) _ (nulltp2perm/norm PM-FLP1 NN2P1)
     (tTrans2
	(tWrite1
	   TYPE1'
	   (letTyping/exists [v]
	      (letTyping/base v
		 (tWrite2
		    (TYPE3 v)  %{ PF1 , (PF2 , Pi) }%
		    (letTyping/exists [v']
		       (letTyping/base v'
			  (tTrans
			     (transform/trans3
				(transform/implies
				   (implies/trans5
				      (implies/combine
					 (implies/trans6
					    (implies/conj2combine)
					    (implies/trans3
					       (implies/combine
						  (implies/trans
						     (implies/nonlinear bimplies/tt)
						     (implies/true2empty))
						  (implies/reflexive))
					       (implies/equiv equiv/commute)
					       (implies/equiv equiv/identity))
					    (implies/conj2combine)
					    (implies/combine
					       (implies/trans
						  (implies/nonlinear bimplies/tt)
						  (implies/true2empty))
					       (IMP v))
					    (implies/equiv equiv/commute)
					    (implies/equiv equiv/identity))
					 (implies/trans3
					    (implies/equiv equiv/commute)
					    (implies/combine
					       (implies/equiv EQV)
					       (implies/reflexive))
					    (implies/equiv
					       (equiv/symmetric equiv/associate))))
				      (implies/equiv equiv/associate)
				      (implies/combine (IMP2 v) implies/reflexive)
				      (implies/equiv (equiv/symmetric equiv/associate))
				      (implies/combine
					 (implies/equiv (equiv/symmetric equiv/one))
					 (implies/reflexive))))
				(transform/skolem)
				(transform/inside
				   ([r]
				      (transform/implies
					 (implies/trans
					    (implies/combine
					       (implies/equiv equiv/one)
					       (implies/reflexive))
					    (implies/equiv 
					       (equiv/symmetric equiv/associate)))))))
			     (letTyping/exists
				([r]
				   (letTyping/base null
				      (tWrite:typing _ _ (write (lit v) _ (lit v')) _))))
 			     (transform/trans %{ BC, PC, EC, Pi2, PF2 }%
				(transform/inside
				   ([r]
				      (transform/implies
					 (implies/trans10
					    (implies/combine
					       (implies/reflexive)
					       (implies/trans3
						  (implies/combine
						     (REM r)
						     (implies/combine
							(implies/reflexive)
							(implies/equiv
							   equiv/commute)))
						  (implies/equiv equiv/commute)
						  (implies/equiv equiv/identity)))
					    (implies/combine %{ BC, EC, PF2, Pi2 }%
					       (implies/reflexive)
					       (implies/equiv equiv/roll2))
					    (implies/equiv equiv/associate)
					    (implies/combine
					       (implies/trans3
						  (implies/combine
						     (implies/reflexive)
						     (DUP v'))
						  (implies/equiv equiv/associate)
						  (implies/combine
						     (implies/pack v')
						     (implies/reflexive)))
					       (implies/reflexive))
					    (implies/equiv  %{ PC, PF2, EC, Pi2 }%
					       (equiv/symmetric equiv/associate))
					    (implies/combine
					       (implies/reflexive)
					       (implies/equiv equiv/roll2))
					    (implies/equiv equiv/associate)
					    (implies/combine %{ WS, PF2, Pi2 }%
					       (implies/linear-modus-ponens)
					       (implies/reflexive))
					    (implies/equiv equiv/roll2)
					    (implies/combine
					       (implies/reflexive)
					       (implies/equiv (equiv/symmetric EQV)))))))
				(transform/rem-unused)))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYPE1
     	_ (nulltp2perm/norm PM-LP1 nn2perm/yes) TYPE1 
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP2
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ PEQ
     <- typing-preserves-eq nn2perm/yes PEQ TYPE1 TYPE1'
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYPE2 _
	(nulltp2perm/norm PM-FLP1 NN2P1) TYPE2
     <- conversion-helper/write3 (nulltp2perm/norm PM-LP2 nn2perm/yes) TYPE2 ([r] TYPE3 r)
     <- writeshared-can-move-front OFL2P _ EQV
     <- lookup-fldperm-converse CM2PM PM-LP2 CM-LP FM-LP PM-FLP1 _ FNN2P _ IMP
     <- get-precise-exists-single FNN2P PM-FLP1 NN2P1 IMP2
     <- clspred-implies-empty (nulltp2perm/norm PM-FLP1 NN2P1) ([r] REM r)
     <- conversion-helper/write2 NN2P1 PM-FLP1 (nulltp2perm/norm PM-FLP1 NN2P1) DUP.

- : convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P nulltArgs/0 
     _ tArgs0 perm-output/args/0.

- : convert/args-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltArgs/+ ([o] NTYPA o) NTYP) _ 
     (tArgs1 (TYP) (letTyping/exists [v] (letTyping/base v (tArgs (TYPA v))))) 
     (perm-output/args/+ APO T2P)
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP _ T2P TYP 
     <- typing-implies-clsmap-nulltp CM-CM CM-MM CM-L NTYP CM-T
     <- ({o} convert/args-ok CM2PM CM-CM CM-MM (clsmap-oflist/+ CM-T CM-L) 
	   MM2W (oflist2perm/+ T2P L2P) (NTYPA o) _ (TYPA o) (APO o)).

%worlds (objvar) 
(convert/expr-ok _ _ _ _ _ _ _ _ _ _)
(convert/cond-ok _ _ _ _ _ _ _ _ _ _)
(convert/args-ok _ _ _ _ _ _ _ _ _ _).
%total (T1 T2 T3)
(convert/expr-ok _ _ _ _ _ _ T1 _ _ _)
(convert/cond-ok _ _ _ _ _ _ T2 _ _ _)
(convert/args-ok _ _ _ _ _ _ T3 _ _ _).


%theorem methtpmatch-implies-proctypematch* :
        forall* {CM} {MM} {PM} {MT} {W} {F} {OFL} {Pi} {Pi2}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MT: clsmap-methtp CM MT}
                {CM2PM: clsmap2predmap CM PM}
		{CM-OFL: clsmap-oflist CM OFL}			       
		{MM2W: methmap2progtype PM CM MM W}			      
                {OFL2P: oflist2perm PM OFL Pi}
                {EQV: equiv Pi (sharedPerm , Pi2)}
                {MC: methtpmatch* CM MM OFL F MT}
        exists  {PT} {MT2PT: methtp2proctype* PM Pi2 MT PT}
                {PC: proctypematch W F PT}
        true.                

- : methtpmatch-implies-proctypematch* 
     CM-CM CM-MM _ CM2PM CM-OFL MM2W OFL2P EQV (methtpmatch*/base NTYP)
     %{=>}% _ (methtp2proctype*/base T2P) 
     (proctypematch/base
	(tTrans
	   (transform/implies
	      (implies/equiv (equiv/symmetric EQV)))
	   (letTyping/base null TYP)
	   (transform/inside [ret]
	      (transform/trans
		 (transform/implies
		    (implies/trans3
		       (implies/combine 
			  (implies/reflexive)
			  (implies/trans
			     (implies/equiv EQV)
			     (implies/equiv equiv/commute)))
		       (implies/equiv equiv/commute)
		       (implies/equiv (equiv/symmetric equiv/associate))))
		 (transform/drop)))))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP _ T2P TYP.

- : methtpmatch-implies-proctypematch*
     CM-CM CM-MM (clsmap-methtp/arg ([o] (CM-MT o)) CM-T)
     CM2PM CM-OFL MM2W OFL2P EQV (methtpmatch*/args ([o] MC o)) %{=>}%
     _ (methtp2proctype*/arg ([o] MT2PT o) T2P) (proctypematch/arg ([o] PC o))
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T _ T2P
     <- ({o} methtpmatch-implies-proctypematch* 
	   CM-CM CM-MM (CM-MT o) CM2PM (clsmap-oflist/+ CM-T CM-OFL) MM2W 
	   (oflist2perm/+ T2P OFL2P)
	   (equiv/transitive
	      (equiv/combine (equiv/reflexive) EQV)
	      (equiv/roll2))
	   (MC o) _ (MT2PT o) (PC o)).
	   
%worlds (objvar) (methtpmatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _).
%total MC (methtpmatch-implies-proctypematch* _ _ _ _ _ _ _ _ MC _ _ _).


%theorem methtpmatch-implies-proctypematch :
        forall* {CM} {MM} {PM} {MT} {W} {F}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MT: clsmap-methtp CM MT}
                {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}			      
                {MC: methtpmatch CM MM F MT}
        exists  {PT} {MT2PT: methtp2proctype PM MT PT}
                {PC: proctypematch W F PT}
        true.                

- : methtpmatch-implies-proctypematch 
     CM-CM CM-MM CM-MT CM2PM MM2W MC PT MT2PT PC
     <- methtpmatch-implies-proctypematch*
	CM-CM CM-MM CM-MT CM2PM clsmap-oflist/0 MM2W oflist2perm/0
	(equiv/symmetric equiv/identity) MC PT MT2PT PC.

%worlds () (methtpmatch-implies-proctypematch _ _ _ _ _ _ _ _ _).
%total  {} (methtpmatch-implies-proctypematch _ _ _ _ _ _ _ _ _).


%theorem allocFields-gives-fldperm :
        forall* {PM} {CM} {MM} {W} {Pi} {NN} {PF}
	        {C} {PD} {L} {E} {F} {FF}
        forall  {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {PM-L: predmap`lookup PM C PD}
                {NN2P: nn2perm NN PF}
                {FNN2P: fldnn2perm F NN ([p][r] FF p r)}
                {TYP: typing W Pi E (output/exists [r]
				       (output/expr r ((PF PD r) , Pi)))}
        exists  {TYP: {t} typing W ((unitperm (basic t F null)) , Pi)
		       (write (lit t) F E) 
		       (output/exists [r] (output/expr r ((FF PD r) , Pi)))}
	true.


%theorem fldmap-filt-nnflds : 
        forall* {FM} {S} {N} {C}
        forall  {FN: filt-nnflds FM S}
                {L: fldmap`lookup FM N (nulltp/norm C nn/yes)}
        exists  {MB: set`member S N}
        true.

%worlds (objvar) (fldmap-filt-nnflds _ _ _).
%trustme %total {} (fldmap-filt-nnflds _ _ _).


%theorem nulltyping-sub :
        forall* {CM} {MM} {L} {E} {C} 
        forall  {NN} {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {NTYP: nullTyping CM MM L E (result/expr (nulltp/norm C NN))}
        exists  {NTYP: nullTyping CM MM L E (result/expr (nulltp/norm C nn/may))}
        true.

- : nulltyping-sub nn/may _ _ _ NTYP NTYP.

- : nulltyping-sub nn/yes CM-CM CM-MM CM-OFL NTYP 
     (nulltSub NTYP (clsmap-nulltp/norm IN) (sub/oo nn`subtype/my))
     <- typing-implies-clsmap-nulltp
	CM-CM CM-MM CM-OFL NTYP (clsmap-nulltp/norm IN).

%worlds () (nulltyping-sub _ _ _ _ _ _).
%total  NN (nulltyping-sub NN _ _ _ _ _).


%abbrev set-notin = [S][N] set`not-member S N.
%abbrev set-unit-union = [S1][N][S2] set`union S1 (set/+ N set/0) S2.

%%% bijection between raw field permissions and set members

set-rawfldperm : set -> (object -> permission) -> type.

set-rawfldperm/0 : set-rawfldperm set/0 ([_] empty).

set-rawfldperm/+ 
   : set-rawfldperm S ([t] (unitperm (basic t F null)) , (B t))
      <- set-unit-union S1 F S
      <- set-notin S1 F.

%%% bijection between assembled field permissions and set members

set-fldpred : predmap -> fldmap -> set -> (object -> permission) -> type.

set-fldpred/0 : set-fldpred _ _ set/0 ([_] empty).

set-fldpred/+ 
   : set-fldpred PM FM S ([t] (unitperm (basic t F (W P t) , (R t))
      <- fldmap`lookup FM F (nulltp/norm C NN)
      <- nn2perm NN W
      <- predmap`lookup PM C P
      <- set-unit-union S1 F S
      <- set-notin S1 F
      <- set-fldpred PM FM S1 ([t] R t).


set-expr : set -> (object -> expr) -> type.

set-expr/0 : set-expr _ ([t] lit t).

set-expr/+
   : set-expr S ([t] (seq (write (lit t) F _)) (B t))
      <- set-in S F
      <- set-expr S B.

nonnull-set : fldmap -> set -> type.

nonnull-set/0 : nonnull-set _ set/0.

nonnull-set/+ 
   : nonnull-set FM S
      <- set-unit-union S1 F S
      <- set-notin S1 F
      <- fldmap`lookup FM F (nulltp/norm _ nn/yes)
      <- nonnull-set FM S1.

%%% R - bare field permissions
%%% Q - assembled field permissions

%theorem diff-lookup-implies-ne :
        forall* {FM} {N1} {N2} {C1} {C2}
        forall  {L1:fldmap`lookup FM N1 (nulltp/norm C1 nn/may)}
                {L2:fldmap`lookup FM N2 (nulltp/norm C2 nn/yes)}
        exists  {NE: nat`ne N1 N2}
        true.

- : diff-lookup-implies-ne (fldmap`lookup/= EQ) (fldmap`lookup/> _ P) (nat`ne/< GT')
     <- nat`plus-implies-gt P nat`eq/ GT
     <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> _ P) (fldmap`lookup/= EQ) (nat`ne/> GT')
     <- nat`plus-implies-gt P nat`eq/ GT
     <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> L1 P1) (fldmap`lookup/> L2 P2) PNE
     <- diff-lookup-implies-ne L1 L2 NE
     <- nat`succ-preserves-ne NE SNE
     <- nat`plus-right-preserves-ne* SNE P1 P2 PNE.
     
%worlds () (diff-lookup-implies-ne _ _ _).
%total L1 (diff-lookup-implies-ne L1 _ _).


%theorem no-maybenull-in-nonnull-set :
        forall* {FM} {S} {F} {C}
        forall  {NNS: nonnull-set FM S}
                {L: fldmap`lookup FM F (nulltp/norm C nn/may)}
        exists  {NM: set`not-member S F}
        true.

- : no-maybenull-in-nonnull-set nonnull-set/0 LP set`not-member/0.

- : no-maybenull-in-nonnull-set 
     (nonnull-set/+ NNS LN N/S1 S1UN=S) LF F/S
     <- no-maybenull-in-nonnull-set NNS LF F/S1
     <- diff-lookup-implies-ne LF LN F!=N
     <- nat`ne-symmetric F!=N N!=F
     <- set`ne-implies-unit-map-not-member N!=F NM
     <- set`union-preserves-not-member* F/S1 NM S1UN=S F/S.
	
%worlds () (no-maybenull-in-nonnull-set _ _ _).
%total NNS (no-maybenull-in-nonnull-set NNS _ _).


%theorem precise-exists-implies-fldperm :
        forall* {PM} {C} {P} {NN} {W} {F}
        forall  {PM-L: predmap`lookup PM C P}
                {FNN2P: fldnn2perm F NN ([p][o] W p o)}
        exists  {O} {IMP: {t} implies (W P t) (unitperm (basic t F O))}  
        true.

- : precise-exists-implies-fldperm _ fldnn2perm/yes
     


%theorem set-fldpred-reorder :
        forall* {PM} {FM} {FP} {S} {F} 
        forall  {S-FP: set-fldpred PM FM S ([t] FP t)}
                {IN: set-in S F}
        exists  {RP} {EQV: {t} equiv (FP t) ((unitperm (basic t F null)) , (RP t))}
                {S1} {U: set-unit-union S1 F S} {NM: set-notin S1 F}
                {S1-RP: set-fldpred PM FM S1 ([t] RP t)}
        true.

%theorem set-fldpred-reorder/L :
        forall* {PM} {FM} {S} {F} 
                {S1} {N} {R} {W} {P} {D} {NN} 
        forall  {C} {CMP: nat`compare N F C}
                {S1-R: set-fldpred PM FM S1 ([t] R t)}
                {N/S1: set-notin S1 N}
                {U: set-unit-union S1 N S}
                {IN: set`member S F}
                {PM-L: predmap`lookup PM D P}
                {FNN2P: fldnn2perm N NN ([p][o] W p o)}
                {FM-L: fldmap`lookup FM N (nulltp/norm D NN)}
        exists  {RP} {O}
                {EQV: {t} equiv ((W P t) , (R t)) (unitperm (basic t F O) , (RP t))}
                {S2} {U: set-unit-union S2 F S} {NM: set-notin S2 F}
                {S2-RP: set-fldpred PM FM S2 ([t] RP t)}
        true.

- : set-fldpred-reorder/L equal _ S1-R N/S1 S1UN=S _ PM-L FNN2P FM-L
     _ _ 
     (equiv
     _ _ _
     

%theorem constyping-implies-typing/L :
        forall* {PM} {CM} {MM} {FM} {E} {W}
                {S} {S1} {S2} {L} {Pi} {R0} {Q0}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S1 L ([t] E t)}
                {NNS: nonnull-set FM S1}
                {S/S1=S2: set`remove S S1 S2}
                {S1US2: set`union S1 S2 S}
                {S-E: set-expr S E}
		{S1-R0: set-rawfldperm S1 R0}			
                {S2-Q0: set-fldpred PM FM S2 Q0}
        exists  {Q1} 
                {TYP: {t} typing W ((R0 t) , ((Q0 t) , Pi)) (E t) 
		       (output/expr t ((Q1 t) , Pi))}
                {S-Q1: set-fldpred PM FM S Q1}
        true.

- : constyping-implies-typing/L 
     _ _ _ _ _ _ constyping/0 _ _ _
     set-expr/0 set-rawfldperm/0 S-Q _ 
     ([_] tTrans2
	(tObjLoc)
	(transform/implies
	   (implies/equiv
	      (equiv/transitive
		 (equiv/commute) 
		 (equiv/identity))))) S-Q.

- : constyping-implies-typing/L
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P 
     (constyping/mn CTYP NTYP FM-LP) NNS S/S1=S2 S1XS2 
     (set-expr/+ F-in-S S-B) S1-R0 S2-Q0 Q1 _ _
     <- no-maybenull-in-nonnull-set NNS FM-LP F/S1

%worlds () (constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  CTYP (constyping-implies-typing/L _ _ _ _ _ _ CTYP _ _ _ _ _ _ _ _).




%%% This theorem is not valid

%theorem constyping-implies-typing/L :
        forall* {PM} {CM} {MM} {FM} {E} {W}
                {S} {S0} {L} {Pi} {R0}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S L ([t] E t)}
		{S0-R0: set-rawfldperm S0 R0}
                {R0-E: rawfldperm-expr R0 E}
        exists  {R1} {H} 
                {TYP: {t} typing W ((R0 t) , Pi) (E t) 
		       (output/expr t ((R1 t) , ((H t) , Pi)))}
                {S1} {S1-R1: set-rawfldperm S1 R1}
                {S2} {S2-H: set-fldpred PM FM S2 H}
                {S<=S2: set`leq S S2}
                {U: set`union S1 S2 S0}
        true.

- : constyping-implies-typing/L _ _ _ _ _ _
     (constyping/0) S0-R0 rawfldperm-expr/0 _ _  
     ([t] tTrans2
	(tObjLoc)
	(transform/implies
	   (implies/combine
	      (implies/reflexive)
	      (implies/equiv
		 (equiv/transitive
		    (equiv/symmetric equiv/identity)
		    (equiv/commute))))))
     _ S0-R0 set/0 set-fldpred/0 set`leq/0 set`union/R.

- : constyping-implies-typing/L CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P 
     (constyping/mn CTYP NTYP FM-LP) 
     (set-rawfldperm/+ T0-R0 T0UF=S0 F-notin-T0)
     (rawfldperm-expr/+ R0-E) _ _ %{=>}%
     ([t] tTrans2
	(tLet
	   (tWrite2
	      (tTrans2
		 (TYPE' t)
		 (transform/inside [r]
		    (transform/implies
		       (implies/equiv
			  (equiv/symmetric equiv/associate)))))
	      (letTyping/exists [r]
		 (letTyping/base r
		    (tTrans2
		       (tWrite)
		       (transform/implies
			  (implies/trans3
			     (implies/combine
				(implies/reflexive) 
				(implies/equiv equiv/roll2))
			     (implies/equiv equiv/associate)
			     (implies/combine (I t r) (implies/reflexive))))))))
	   (letTyping/exists [r]
	      (letTyping/base r
		 (tTrans2
		    (TYPB' t)
		    (transform/implies
		       (implies/trans
			  (implies/equiv equiv/roll2)
			  (implies/combine
			     (implies/reflexive)
			     (implies/equiv equiv/associate))))))))
	(transform/rem-unused))
     _ S1-R1 _
     (set-fldpred/+ T2-H T2UF=S2 F-notin-T2 PM-LP FNN2P FM-LP) S<=S2 S1US2=S0
     <- nulltyping-sub _ CM-CM CM-MM CM-OFL NTYP NTYP'
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP'
	_ (nulltp2perm/norm PM-LP NN2P) TYPE
     <- constyping-implies-typing/L
	CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP T0-R0 R0-E 
	_ _ ([t] TYPB t) S1 S1-R1 T2 T2-H S<=T2 S1UT2=T0
     <- can-assemble-fldperm NN2P PM-LP _ FNN2P ([t][r] I t r)
     <- set`union-associative S1UT2=T0 T0UF=S0 S2 T2UF=S2 S1US2=S0
     <- set`union-preserves-not-member-converse*
	F-notin-T0 S1UT2=T0 F-notin-S1 F-notin-T2
     <- set`union-implies-leq T2UF=S2 T2<=S2 _
     <- set`leq-transitive S<=T2 T2<=S2 S<=S2
     <- ({t} typing-frame* TYPE (envadd/exists ([r] envadd/expr)) (TYPE' t))
     <- ({t} typing-frame* (TYPB t) (envadd/expr) (TYPB' t)).

- : constyping-implies-typing/L CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P
     (constyping/nn CTYP NTYP S/F=T FM-LP) 
     (set-rawfldperm/+ T0-R0 T0UF=S0 F-notin-T0)
     (rawfldperm-expr/+ R0-E) %{=>}% _ _ 
     ([t] tTrans2
	(tLet
	   (tWrite2
	      (tTrans2
		 (TYPE' t)
		 (transform/inside [r]
		    (transform/implies
		       (implies/equiv
			  (equiv/symmetric equiv/associate)))))
	      (letTyping/exists [r]
		 (letTyping/base r
		    (tTrans2
		       (tWrite)
		       (transform/implies
			  (implies/trans3
			     (implies/combine
				(implies/reflexive) 
				(implies/equiv equiv/roll2))
			     (implies/equiv equiv/associate)
			     (implies/combine (I t r) (implies/reflexive))))))))
	   (letTyping/exists [r]
	      (letTyping/base r
		 (tTrans2
		    (TYPB' t)
		    (transform/implies
		       (implies/trans
			  (implies/equiv equiv/roll2)
			  (implies/combine
			     (implies/reflexive)
			     (implies/equiv equiv/associate))))))))
	(transform/rem-unused))
     S1 S1-R1 S2
     (set-fldpred/+ T2-H T2UF=S2 F-notin-T2 PM-LP FNN2P FM-LP) S<=S2 S1US2=S0
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP
	_ (nulltp2perm/norm PM-LP nn2perm/yes) TYPE
     <- constyping-implies-typing/L 
	CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP T0-R0 R0-E 
	_ _ ([t] TYPB t) S1 S1-R1 T2 T2-H T<=T2 S1UT2=T0
     <- can-assemble-fldperm nn2perm/yes PM-LP _ FNN2P ([t][r] I t r)
     <- set`union-associative S1UT2=T0 T0UF=S0 S2 T2UF=S2 S1US2=S0
     <- set`union-preserves-not-member-converse*
	F-notin-T0 S1UT2=T0 F-notin-S1 F-notin-T2
     <- set`union-implies-leq T2UF=S2 T2<=S2 F<=S2
     <- set`leq-transitive T<=T2 T2<=S2 T<=S2
     <- set`union-total FUT=S1
     <- set`remove-implies-leq-union S/F=T FUT=S1 S<=S1
     <- set`leq-implies-union F<=S2 FUS2=S2
     <- set`union-left-preserves-leq* T<=S2 FUT=S1 FUS2=S2 S1<=S2
     <- set`leq-transitive S<=S1 S1<=S2 S<=S2
     <- ({t} typing-frame* TYPE (envadd/exists ([r] envadd/expr)) (TYPE' t))
     <- ({t} typing-frame* (TYPB t) (envadd/expr) (TYPB' t)).

%worlds () (constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  TP (constyping-implies-typing/L _ _ _ _ _ _ TP _ _ _ _ _ _ _ _ _ _ _).


%theorem allocfields-implies-set-rawfldperm :
        forall* {S} {R}
        forall  {AF: {t} allocFields t S (R t)}
        exists  {Q} {EQV: {t} equiv (R t) (Q t)} {SR: set-rawfldperm S Q}
        true.

- : allocfields-implies-set-rawfldperm
     ([_] allocFields/0) _ ([_] equiv/reflexive)  set-rawfldperm/0.

- : allocfields-implies-set-rawfldperm
     ([t] (allocFields/+ SH (AF t))) _ 
     ([t] (equiv/transitive equiv/commute (equiv/combine equiv/reflexive (EQV t))))
     (set-rawfldperm/+ SR U NM)
     <- set`shift-implies-not-member SH NM
     <- set`can-construct-unit-union SH U
     <- allocfields-implies-set-rawfldperm AF _ EQV SR.

%worlds () (allocfields-implies-set-rawfldperm _ _ _ _).
%total  AF (allocfields-implies-set-rawfldperm AF _ _ _).


%theorem allocfields-implies-fieldperm/L :
        forall* {F1} {F2}
        forall  {EQ: nat`eq F1 F2}
        exists  {EQV: {t} equiv
		       (unitperm (basic t F1 null)) (unitperm (basic t F2 null))}
        true.

- : allocfields-implies-fieldperm/L nat`eq/ ([_] equiv/reflexive).

%worlds () (allocfields-implies-fieldperm/L _ _).
%total  {} (allocfields-implies-fieldperm/L _ _).


%theorem allocfields-implies-fieldperm :
        forall* {S} {F} {R} 
        forall  {SR: set-rawfldperm S R}
                {MB: set`member S F} 
        exists  {B} {EQV: {t} equiv (R t) ((unitperm (basic t F null)) , (B t))}
        true.

- : allocfields-implies-fieldperm
     (set-rawfldperm/+ TR set`union/L set`not-member/0)
     (set`lookup/= EQ) _ ([_] equiv/reflexive).

%%% union/R is not possibe

%worlds () (allocfields-implies-fieldperm _ _ _ _).
%trustme %total AF (allocfields-implies-fieldperm AF _ _ _).


%%% we need to prove that given allocFields, we can always
%%% get the rawfldperm-expr relation. This is necessary whether
%%% we use set to like rawfldperm & clspred or not.

%theorem fldmap-expr-implies-rawfldperm-expr :
        forall* {CM} {MM} {FM} {S0} {L} {E} {S} {R}
        forall  {CTYP: constyping CM MM FM S0 L ([t] E t)}
                {FM-DM: fldmap`domain FM S}
                {AF: {t} allocFields t S (R t)}
        exists  {Q} {EQV: {t} equiv (R t) (Q t)}
                {QE: rawfldperm-expr Q E}
        true.

set-expr/+
   : set-expr S ([t] (seq (write (lit t) F _)) (B t))
      <- set`not-member S1 F
      <- set`union S1 (set/+ F set/0) S
      <- set-expr S1 B.

%theorem can-construct-clspred :
        forall* {PM} {CM} {FM} {C} {FP} {S} {S0} {S1} {R}
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-LP: clsmap`lookup CM C FM}
                {DM: fldmap`domain FM S0}
                {NS: filt-nnflds FM S}
                {SP: set-fldpred PM FM S FP}
                {RM: set`remove S0 S S1}
        exists  {SR: set-rawfldperm S1 R}
                {G} {EV: {t} implies ((R t) , (FP t)) (unitperm (nonlinear (G t)))}
                {F2C: fldmap2conj CM PM FM ([t] G t) PM}
        true.


%theorem constyping-implies-typing :
        forall* {PM} {CM} {MM} {FM} {E} {W} 
                {S} {S0} {S1} {L} {OS} {Pi} {C}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CM-L: clsmap`lookup CM C FM}
                {DM: fldmap`domain FM S}
                {AF: {t} allocFields t S (OS t)}
                {FNN: filt-nnflds FM S0}
                {SR: set`remove S S0 S1}
                {CTYP: constyping CM MM FM S0 L ([t] E t)}
        exists  {PF} {NN2P: nn2perm nn/yes PF}
                {PD} {PM: predmap`lookup PM C PD} 
                {TYP: {t} typing W ((OS t) , Pi) (E t)
		       (output/expr t (sharedPerm , (PF PD t)))}
        true.

- : constyping-implies-typing CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P
     CM-L DM AF FNN SR CTYP _ _ TYP PM NN2P
     <- constyping-implies-typing CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP
	_ _ TYP S1 S1-R1 S2 S2-H S<=S2 U
     <- %%% fields in S0 are all assembled


%theorem constyping-implies-typing/L :
        forall* {PM} {CM} {MM} {FM} {E} {W}
                {S} {S0} {L} {Pi} {R0}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S L ([t] E t)}
		{S0-R0: set-rawfldperm S0 R0}
                {R0-E: rawfldperm-expr R0 E}
        exists  {R1} {H} 
                {TYP: {t} typing W ((R0 t) , Pi) (E t) 
		       (output/expr t ((R1 t) , ((H t) , Pi)))}
                {S1} {S1-R1: set-rawfldperm S1 R1}
                {S2} {S2-H: set-fldpred PM FM S2 H}
                {S<=S2: set`leq S S2}
                {U: set`union S1 S2 S0}
        true.
     
%theorem constpmatch-implies-proctypematch* :
        forall* {CM} {MM} {PM} {FM} {CTF} {W} {F} {OFL} {Pi} {Pi2} {S}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM2PM: clsmap2predmap CM PM}
		{CM-OFL: clsmap-oflist CM OFL}			       
		{MM2W: methmap2progtype PM CM MM W}			      
                {OFL2P: oflist2perm PM OFL Pi}
                {EQV: equiv Pi (sharedPerm , Pi2)}
                {MC: constypematch* CM MM FM S OFL F CTF}
        exists  {PTF} {MT2PT: constp2proctype PM FM CTF PTF}
                {PC: proctypematch W (func/+ F) (proctype/arg PTF)}
        true.                

     

