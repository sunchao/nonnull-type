%%%%% conversion-thms.elf
%%%%% Theorems about conversion
%%%%% $Id: conversion-thms.elf,v 1.23 2011/02/13 23:33:58 csun Exp csun $

%theorem convert/expr-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {T} {E: term exprk} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL E (result/expr T)}
        exists  {PF} {T2P: nulltp2perm PM T ([r] PF r)}
                {TYP: typing W Pi E
		       (output/exists [r] (output/expr r ((PF r) , Pi)))}
        true.

%theorem convert/cond-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {C: term condk} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL C result/cond}
        exists  {Out: output condk} {TYP: typing W Pi C Out}
                {PM: perm-output PM Pi result/cond Out}
        true.

%theorem convert/args-ok :
        forall* {PM} {CM} {MM} {OFL} {W} {Pi} {A: term argsk} {ARslt}
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM OFL}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM OFL Pi}
		{NTYP: nullTyping CM MM OFL A ARslt}
        exists  {AOut: output argsk} {TYP: typing W Pi A AOut}
                {PM: perm-output PM Pi ARslt AOut}
        true.

- : convert/cond-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltNot NTYP) _ TYP' CPO'
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP _ TYP CPO
     <- conversion-helper/not TYP CPO _ TYP' CPO'.

- : convert/cond-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltAnd NTYP1 NTYP2) _
     (tTrans2 (tAnd TYP1 AH) T) CPO4
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP1 _ TYP1 CPO1
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP2 _ TYP2 CPO2
     <- conversion-helper/and CPO1 TYP2 _ Out4 AH T CPO4.

- : convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltEql NTYPE1 NTYPE2) _ 
     (tEql1
	TYPE1
	(letTyping/exists [v1]
	   (letTyping/base v1
	      (tEql2
		 (TYPE2' v1)
		 (letTyping/exists [v2]
		    (letTyping/base v2
		       (tTrans2
			  (tEql:typing _ _ (eql (lit v1) (lit v2)) _)
			  (transform/cond
			     (bimplies/reflexive)
			     (bimplies/reflexive)
			     (implies/trans3
				(implies/combine
				   (implies/trans
				      (implies/nonlinear bimplies/tt)
				      (implies/true2empty))
				   (implies/trans5
				      (implies/combine
					 (REM1 v1) 
					 (implies/combine
					    (REM2 v2)
					    (implies/reflexive)))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)))
				(implies/equiv equiv/commute)
				(implies/equiv equiv/identity))
			     (implies/trans3
				(implies/combine
				   (implies/trans
				      (implies/nonlinear bimplies/tt)
				      (implies/true2empty))
				   (implies/trans5
				      (implies/combine
					 (REM1 v1) 
					 (implies/combine
					    (REM2 v2)
					    (implies/reflexive)))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity)))
				(implies/equiv equiv/commute)
				(implies/equiv equiv/identity))))))))))
     (perm-output/exists ([v1] (perm-output/exists ([v2] (perm-output/cond)))))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE1 _ T2P1 TYPE1
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE2 _ T2P2 TYPE2
     <- conversion-helper/write3 T2P1 TYPE2 ([v] TYPE2' v)
     <- clspred-implies-empty T2P1 ([r] REM1 r)
     <- clspred-implies-empty T2P2 ([r] REM2 r).

- : convert/expr-ok _ _ _ _ _ L2P (nulltLit L) _ T2P 
     (tTrans2 tObjLoc 
	(transform/trans
	   (transform/implies I)
	   (transform/gen-exists _)))
   <- oflist-lookup-implies-clspred _ L L2P _ T2P I.

- : convert/expr-ok _ _ _ _ _ _ nulltNull _ nulltp2perm/null
     (tTrans2 tObjLoc 
	(transform/trans
	   (transform/implies
	      (implies/trans3
		 (implies/equiv (equiv/symmetric equiv/identity))
		 (implies/equiv equiv/commute)
		 (implies/combine
		    (implies/trans
		       (implies/empty2true)
		       (implies/nonlinear bimplies/objequal-reflexive))
		    (implies/reflexive))))
	   (transform/gen-exists null))).

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-OFL MM2W L2P (nulltLet ([o] NTYPF o) NTYPE)
     _ T2POut 
     (tTrans2
	(tLet 
	   TYPE
	   (letTyping/exists [x]
	      (letTyping/base x
		 (tTrans2
		    (TYPF2 x)
		    (transform/inside [r]
		       (transform/implies
			  (implies/trans4
			     (implies/equiv equiv/roll2)
			     (implies/combine
				(I x)
				(implies/reflexive))
			     (implies/equiv equiv/commute)
			     (implies/equiv equiv/identity))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W L2P NTYPE _ T2P TYPE
     <- typing-implies-clsmap-nulltp CM-CM CM-MM CM-OFL NTYPE CM-T
     <- ({o} convert/expr-ok CM2PM CM-CM CM-MM 
	   (clsmap-oflist/+ CM-T CM-OFL) MM2W (oflist2perm/+ T2P L2P)
	   (NTYPF o) _ (T2POutF o) (TYPF o))
     <- conversion-helper/let3 ([o] T2POutF o) PF ([o][o1] EQ o o1) T2POut
     <- conversion-helper/let4 EQ TYPF TYPF2
     <- clspred-implies-empty T2P ([r] I r).
	   
- : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltWhile NTYPE NTYPC) _ nulltp2perm/null
     (tTrans2 (tWhile (transform/reflexive) (letTyping/base null TYPC) WT DV T1) 
	(transform/trans3 T2
	   (transform/implies
	      (implies/trans3
		 (implies/equiv (equiv/symmetric equiv/identity))
		 (implies/equiv equiv/commute)
		 (implies/combine
		    (implies/trans
		       (implies/empty2true)
		       (implies/nonlinear bimplies/objequal-reflexive))
		    (implies/reflexive))))
	   (transform/gen-exists null)))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE _ _ TYPE
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPC _ TYPC CPO
     <- conversion-helper/while
	(tTrans2 TYPE (transform/inside ([v] transform/drop))) 
	CPO _ _ _ WT DV T1 T2.

% - : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
%      (nulltSub NTYPE CM-T' SUB) _ T2P'
%      (tTrans2 
% 	TYPE
% 	(transform/inside [r]
% 	   (transform/implies
% 	      (implies/combine
% 		 (I r)
% 		 (implies/reflexive)))))
%      <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T' _ T2P'
%      <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE _ T2P TYPE 
%      <- conversion-helper/sub SUB T2P T2P' ([o] I o).

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltIf NTYPE2 NTYPE1 NTYPC) 
     PF2 T2P2 (tTrans2 (tIf TYPC IFTYP) T) 
     <- convert/cond-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPC XX TYPC CPO
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE1 PF1 T2P1 TYP1 
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPE2 PF2 T2P2 TYP2
     <- nulltp2perm-deterministic T2P1 T2P2 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- envadd-deterministic/exists OEQ OEQ'
     <- typing-respects-eq TYP1 progtype`eq/ permission`eq/ term`eq/ OEQ' TYP1'
     <- conversion-helper/if TYP1' TYP2 (perm-output/expr T2P2) CPO YY IFTYP T.


- : convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltIfNotNull NTYP1 NTYP2 (OF-LP:oflist-lookup _ O _)) _ T2P2
     (tIf 
	(tTrans2 (tNot tEql notEnv/base)
	   (transform/cond
	      (bimplies/reflexive)
	      (bimplies/reflexive)
	      (implies/trans3
		 (implies/combine implies/reflexive I1)
		 (implies/equiv equiv/associate)
		 (implies/combine
		    (I2 O)
		    (implies/reflexive)))
	      (implies/trans3
		 (implies/combine
		    (implies/trans
		       (implies/nonlinear bimplies/tt)
		       (implies/true2empty))
		    (implies/reflexive))
		 (implies/equiv equiv/commute)
		 (implies/equiv equiv/identity))))
	(ifTyping/base 
	   (tTrans2 TYP1'
	      (transform/inside [_]
		 (transform/implies
		    (implies/combine
		       (implies/reflexive)
		       (implies/trans3
			  (implies/combine
			     (implies/trans
				(implies/nonlinear bimplies/tt)
				(implies/true2empty))
			     (implies/reflexive))
			  (implies/equiv equiv/commute)
			  (implies/equiv equiv/identity))))))
	   TYP2))
     <- oflist-lookup-implies-clsmap-nulltp CM-L OF-LP (clsmap-nulltp/norm IN)
     <- oflist-lookup-implies-clspred _ OF-LP L2P _ (nulltp2perm/norm PM-LP NN2P) I1
     <- clspred-remove-cond PM-LP NN2P ([o] I2 o)
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP2 PF2 T2P2 TYP2
     <- convert/expr-ok CM2PM CM-CM CM-MM
	(clsmap-oflist/+ (clsmap-nulltp/norm IN) CM-L) 
	MM2W (oflist2perm/+ (nulltp2perm/norm PM-LP nn2perm/yes) L2P) 
	NTYP1 PF1 T2P1 TYP1
     <- nulltp2perm-deterministic T2P1 T2P2 predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) permission`eq/ (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- envadd-deterministic/exists OEQ OEQ'
     <- typing-respects-eq TYP1 progtype`eq/ permission`eq/ term`eq/ OEQ' TYP1'.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltCallMeth NTYPC NTYPA MM-LP CM-FS) 
     PF T2P (tTrans2 (tCall W-LP (tTrans2 TYPA TA) TYPC) TO) 
     <- lookup-implies-clsmap-methtp CM-MM MM-LP CM-MT
     <- methmap2progtype-implies-methtp2proctype MM2W CM-FS MM-LP PT W-LP MT2PT
     <- convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPA _ TYPA APO
     <- conversion-helper/callmeth 
	CM2PM MM2W CM-MT L2P NTYPC APO MT2PT AOut' TA Out TYPC PF TO T2P.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P
     (nulltCallConst FM-DM1 ([t] NTYPC t) NTYPA MM-LP CM-LP) _ T2P _
     <- methmap2progtype-implies-constp2proctype MM2W CML MML _ WL CT2PT 
     <- convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPA _ TYPA APO
 
- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P 
     (nulltCallConst FM-DM1 ([t] NTYPC t) NTYPA MM-LP CM-LP) _ T2P
     (tTrans2
	(tCall W-LP
	   (tTrans2
	      (tArgs1
		 (tTrans2 (tAlloc ([t] AF1 t))
		    (transform/inside [t]
		       (transform/implies
			  (implies/equiv equiv/commute))))
		 (letTyping/exists [t]
		    (letTyping/base t (tArgs (TYP2 t)))))
	      (transform/inside [t]
		 (transform/args/+ (TA t))))
	   (callTyping/exists [t]
	      (callTyping/arg t (CTYP t))))
	(transform/trans
	   (transform/inside [t] (TE t))
	   (transform/rem-unused)))
     <- methmap2progtype-implies-constp2proctype 
	MM2W CM-LP MM-LP _ W-LP (constp2proctype/ ([t] MT2PT t) ([t] AF2 t) FM-DM2)
     <- fldmap`domain-deterministic FM-DM2 FM-DM1 fldmap`eq/ SEQ
     <- allocFields-respects-eq ([t] AF2 t) SEQ ([t] permission`eq/) ([t] AF1 t)
     <- convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYPA _ TYPA APO
     <- ({t} typing-frame TYPA _ (EA t) (TYP2 t))
     <- writeshared-can-move-front L2P _ EQV
     <- conversion-helper/callconst/L 
	CM2PM MM2W EA ([t] implies/reflexive) EQV APO ([t] NTYPC t)
	([t] MT2PT t) _ ([t] TA t) _ ([t] CTYP t) _ T2P TE.

- : convert/expr-ok
     CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P
     (nulltRead FM-LP CM-LP NTYP) _ (nulltp2perm/norm PM-FLP NN2P)
     (tTrans2
	(tRead1 
	   TYPE'
	   (letTyping/exists [v]
	      (letTyping/base v
		 (tTrans
		    (transform/trans3 
		       (transform/implies
			  (implies/trans3
			     (implies/combine
				(implies/trans6
				   (implies/conj2combine)
				   (implies/trans3
				      (implies/combine
					 (implies/trans
					    (implies/nonlinear bimplies/tt)
					    (implies/true2empty))
					 (implies/reflexive))
				      (implies/equiv equiv/commute)
				      (implies/equiv equiv/identity))
				   (implies/conj2combine)
				   (implies/combine
				      (implies/trans
					 (implies/nonlinear bimplies/tt)
					 (implies/true2empty))
				      (I1 v))
				   (implies/equiv equiv/commute)
				   (implies/equiv equiv/identity))
				(implies/equiv EQV))
			     (I2 v) 
			     (implies/combine 
				(implies/equiv (equiv/symmetric equiv/one))
				(implies/reflexive))))
		       (transform/skolem) 
		       (transform/inside 
			  ([r] 
			     (transform/implies
				(implies/trans
				   (implies/combine
				      (implies/equiv equiv/distribute)
				      (implies/reflexive))
				   (implies/equiv
				      (equiv/symmetric equiv/associate)))))))
		    (letTyping/exists 
		       ([r] 
			  (letTyping/base null
			     (tRead:typing _ _ (read (lit v) _) _))))
		    (transform/inside
		       ([r] 
			  (transform/implies
			     (implies/trans8
				(implies/equiv equiv/associate)
				(implies/combine
				   (implies/trans5
				      (implies/equiv
					 (equiv/symmetric equiv/distribute))
				      (implies/equiv equiv/one)
				      (implies/combine
					 (implies/reflexive)
					 (DUP r))
				      (implies/equiv equiv/associate)
				      (implies/combine
					 (implies/pack r) (implies/reflexive)))
				   (implies/reflexive))
				(implies/equiv
				   (equiv/symmetric equiv/associate))
				(implies/combine
				   (implies/reflexive)
				   (implies/equiv equiv/roll2))
				(implies/equiv equiv/associate)
				(implies/combine
				   (implies/linear-modus-ponens) 
				   (implies/reflexive))
				(implies/equiv equiv/roll2)
				(implies/combine
				   (implies/reflexive)
				   (implies/equiv (equiv/symmetric EQV)))))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP 
	_ (nulltp2perm/norm PM-LP1 nn2perm/yes) TYPE
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP2
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ PEQ
     <- typing-preserves-eq nn2perm/yes PEQ TYPE TYPE'
     <- writeshared-can-move-front OFL2P _ EQV
     <- lookup-fldperm CM2PM PM-LP2 CM-LP FM-LP _ _ _ FNN2P PM-FLP I1
     <- get-precise-exists FNN2P PM-FLP _ NN2P I2
     <- clspred-can-be-duplicated (nulltp2perm/norm PM-FLP NN2P) DUP.

%%% for lookup-fldperm, I assume it will get a (conj2pred CJ), however, 
%%% PM-LP doesn't know this, it gave a more generic result.

- : convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P
     (nulltWrite FM-LP CM-LP NTYPE2 NTYPE1) _ (nulltp2perm/norm PM-FLP1 NN2P1)
     (tTrans2
	(tWrite1
	   TYPE1'
	   (letTyping/exists [v]
	      (letTyping/base v
		 (tWrite2
		    (TYPE3 v)  %{ PF1 , (PF2 , Pi) }%
		    (letTyping/exists [v']
		       (letTyping/base v'
			  (tTrans
			     (transform/trans3
				(transform/implies
				   (implies/trans5
				      (implies/combine
					 (implies/trans6
					    (implies/conj2combine)
					    (implies/trans3
					       (implies/combine
						  (implies/trans
						     (implies/nonlinear bimplies/tt)
						     (implies/true2empty))
						  (implies/reflexive))
					       (implies/equiv equiv/commute)
					       (implies/equiv equiv/identity))
					    (implies/conj2combine)
					    (implies/combine
					       (implies/trans
						  (implies/nonlinear bimplies/tt)
						  (implies/true2empty))
					       (IMP v))
					    (implies/equiv equiv/commute)
					    (implies/equiv equiv/identity))
					 (implies/trans3
					    (implies/equiv equiv/commute)
					    (implies/combine
					       (implies/equiv EQV)
					       (implies/reflexive))
					    (implies/equiv
					       (equiv/symmetric equiv/associate))))
				      (implies/equiv equiv/associate)
				      (implies/combine (IMP2 v) implies/reflexive)
				      (implies/equiv (equiv/symmetric equiv/associate))
				      (implies/combine
					 (implies/equiv (equiv/symmetric equiv/one))
					 (implies/reflexive))))
				(transform/skolem)
				(transform/inside
				   ([r]
				      (transform/implies
					 (implies/trans
					    (implies/combine
					       (implies/equiv equiv/one)
					       (implies/reflexive))
					    (implies/equiv 
					       (equiv/symmetric equiv/associate)))))))
			     (letTyping/exists
				([r]
				   (letTyping/base null
				      (tWrite:typing _ _ (write (lit v) _ (lit v')) _))))
 			     (transform/trans %{ BC, PC, EC, Pi2, PF2 }%
				(transform/inside
				   ([r]
				      (transform/implies
					 (implies/trans10
					    (implies/combine
					       (implies/reflexive)
					       (implies/trans3
						  (implies/combine
						     (REM r)
						     (implies/combine
							(implies/reflexive)
							(implies/equiv
							   equiv/commute)))
						  (implies/equiv equiv/commute)
						  (implies/equiv equiv/identity)))
					    (implies/combine %{ BC, EC, PF2, Pi2 }%
					       (implies/reflexive)
					       (implies/equiv equiv/roll2))
					    (implies/equiv equiv/associate)
					    (implies/combine
					       (implies/trans3
						  (implies/combine
						     (implies/reflexive)
						     (DUP v'))
						  (implies/equiv equiv/associate)
						  (implies/combine
						     (implies/pack v')
						     (implies/reflexive)))
					       (implies/reflexive))
					    (implies/equiv  %{ PC, PF2, EC, Pi2 }%
					       (equiv/symmetric equiv/associate))
					    (implies/combine
					       (implies/reflexive)
					       (implies/equiv equiv/roll2))
					    (implies/equiv equiv/associate)
					    (implies/combine %{ WS, PF2, Pi2 }%
					       (implies/linear-modus-ponens)
					       (implies/reflexive))
					    (implies/equiv equiv/roll2)
					    (implies/combine
					       (implies/reflexive)
					       (implies/equiv (equiv/symmetric EQV)))))))
				(transform/rem-unused)))))))))
	(transform/rem-unused))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYPE1
     	_ (nulltp2perm/norm PM-LP1 nn2perm/yes) TYPE1 
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP2
     <- predmap`lookup-deterministic PM-LP1 PM-LP2 predmap`eq/ nat`eq/ PEQ
     <- typing-preserves-eq nn2perm/yes PEQ TYPE1 TYPE1'
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYPE2 _
	(nulltp2perm/norm PM-FLP1 NN2P1) TYPE2
     <- conversion-helper/write3 (nulltp2perm/norm PM-LP2 nn2perm/yes) TYPE2 ([r] TYPE3 r)
     <- writeshared-can-move-front OFL2P _ EQV
     <- lookup-fldperm-converse CM2PM PM-LP2 CM-LP FM-LP PM-FLP1 _ FNN2P _ IMP
     <- get-precise-exists-single FNN2P PM-FLP1 NN2P1 IMP2
     <- clspred-implies-empty (nulltp2perm/norm PM-FLP1 NN2P1) ([r] REM r)
     <- conversion-helper/write2 NN2P1 PM-FLP1 (nulltp2perm/norm PM-FLP1 NN2P1) DUP.

- : convert/args-ok CM2PM CM-CM CM-MM CM-L MM2W L2P nulltArgs/0 
     _ tArgs0 perm-output/args/0.

- : convert/args-ok
     CM2PM CM-CM CM-MM CM-L MM2W L2P (nulltArgs/+ ([o] NTYPA o) NTYP) _ 
     (tArgs1 (TYP) (letTyping/exists [v] (letTyping/base v (tArgs (TYPA v))))) 
     (perm-output/args/+ APO T2P)
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-L MM2W L2P NTYP _ T2P TYP 
     <- typing-implies-clsmap-nulltp CM-CM CM-MM CM-L NTYP CM-T
     <- ({o} convert/args-ok CM2PM CM-CM CM-MM (clsmap-oflist/+ CM-T CM-L) 
	   MM2W (oflist2perm/+ T2P L2P) (NTYPA o) _ (TYPA o) (APO o)).

%worlds (objvar) 
(convert/expr-ok _ _ _ _ _ _ _ _ _ _)
(convert/cond-ok _ _ _ _ _ _ _ _ _ _)
(convert/args-ok _ _ _ _ _ _ _ _ _ _).
%trustme %total (T1 T2 T3)
(convert/expr-ok _ _ _ _ _ _ T1 _ _ _)
(convert/cond-ok _ _ _ _ _ _ T2 _ _ _)
(convert/args-ok _ _ _ _ _ _ T3 _ _ _).


%theorem methtpmatch-implies-proctypematch* :
        forall* {CM} {MM} {PM} {MT} {W} {F} {OFL} {Pi} {Pi2}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MT: clsmap-methtp CM MT}
                {CM2PM: clsmap2predmap CM PM}
		{CM-OFL: clsmap-oflist CM OFL}			       
		{MM2W: methmap2progtype PM CM MM W}			      
                {OFL2P: oflist2perm PM OFL Pi}
                {EQV: equiv Pi (sharedPerm , Pi2)}
                {MC: methtpmatch* CM MM OFL F MT}
        exists  {PT} {MT2PT: methtp2proctype* PM Pi2 MT PT}
                {PC: proctypematch W F PT}
        true.                

- : methtpmatch-implies-proctypematch* 
     CM-CM CM-MM _ CM2PM CM-OFL MM2W OFL2P EQV (methtpmatch*/base NTYP)
     %{=>}% _ (methtp2proctype*/base T2P) 
     (proctypematch/base
	(tTrans
	   (transform/implies
	      (implies/equiv (equiv/symmetric EQV)))
	   (letTyping/base null TYP)
	   (transform/inside [ret]
	      (transform/trans
		 (transform/implies
		    (implies/trans3
		       (implies/combine 
			  (implies/reflexive)
			  (implies/trans
			     (implies/equiv EQV)
			     (implies/equiv equiv/commute)))
		       (implies/equiv equiv/commute)
		       (implies/equiv (equiv/symmetric equiv/associate))))
		 (transform/drop)))))
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP _ T2P TYP.

- : methtpmatch-implies-proctypematch*
     CM-CM CM-MM (clsmap-methtp/arg ([o] (CM-MT o)) CM-T)
     CM2PM CM-OFL MM2W OFL2P EQV (methtpmatch*/args ([o] MC o)) %{=>}%
     _ (methtp2proctype*/arg ([o] MT2PT o) T2P) (proctypematch/arg ([o] PC o))
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T _ T2P
     <- ({o} methtpmatch-implies-proctypematch* 
	   CM-CM CM-MM (CM-MT o) CM2PM (clsmap-oflist/+ CM-T CM-OFL) MM2W 
	   (oflist2perm/+ T2P OFL2P)
	   (equiv/transitive
	      (equiv/combine (equiv/reflexive) EQV)
	      (equiv/roll2))
	   (MC o) _ (MT2PT o) (PC o)).
	   
%worlds (objvar) (methtpmatch-implies-proctypematch* _ _ _ _ _ _ _ _ _ _ _ _).
%total MC (methtpmatch-implies-proctypematch* _ _ _ _ _ _ _ _ MC _ _ _).


%theorem methtpmatch-implies-proctypematch :
        forall* {CM} {MM} {PM} {MT} {W} {F}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MT: clsmap-methtp CM MT}
                {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}			      
                {MC: methtpmatch CM MM F MT}
        exists  {PT} {MT2PT: methtp2proctype PM MT PT}
                {PC: proctypematch W F PT}
        true.                

- : methtpmatch-implies-proctypematch 
     CM-CM CM-MM CM-MT CM2PM MM2W MC PT MT2PT PC
     <- methtpmatch-implies-proctypematch*
	CM-CM CM-MM CM-MT CM2PM clsmap-oflist/0 MM2W oflist2perm/0
	(equiv/symmetric equiv/identity) MC PT MT2PT PC.

%worlds () (methtpmatch-implies-proctypematch _ _ _ _ _ _ _ _ _).
%total  {} (methtpmatch-implies-proctypematch _ _ _ _ _ _ _ _ _).


%%% some extra theorems about fldmap

%%% trivial theorem
%%% if the results from two lookups are different, then 
%%% these two lookups must be on different entries.

%theorem diff-lookup-implies-ne :
        forall* {FM} {N1} {N2} {C1} {C2}
        forall  {L1:fldmap`lookup FM N1 (nulltp/norm C1 nn/may)}
                {L2:fldmap`lookup FM N2 (nulltp/norm C2 nn/yes)}
        exists  {NE: nat`ne N1 N2}
        true.

- : diff-lookup-implies-ne (fldmap`lookup/= EQ) (fldmap`lookup/> _ P) (nat`ne/< GT')
     <- nat`plus-implies-gt P nat`eq/ GT
     <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> _ P) (fldmap`lookup/= EQ) (nat`ne/> GT')
     <- nat`plus-implies-gt P nat`eq/ GT
     <- nat`gt-respects-eq GT nat`eq/ EQ GT'.

- : diff-lookup-implies-ne (fldmap`lookup/> L1 P1) (fldmap`lookup/> L2 P2) PNE
     <- diff-lookup-implies-ne L1 L2 NE
     <- nat`succ-preserves-ne NE SNE
     <- nat`plus-right-preserves-ne* SNE P1 P2 PNE.
     
%worlds () (diff-lookup-implies-ne _ _ _).
%total (L) (diff-lookup-implies-ne L _ _).


%theorem fldmap-shift-implies-fresh-update :
        forall* {M1} {M2} {F} {T} 
        forall  {SH: fldmap`shift F M1 M2}
        exists  {FS: fldmap`fresh M2 F}
                {UD: fldmap`update M2 F T (fldmap`map/+ F T M1)}
        true.

- : fldmap-shift-implies-fresh-update
     fldmap`shift/0 fldmap`fresh/0 fldmap`update/0.

- : fldmap-shift-implies-fresh-update
     (fldmap`shift/+ SF+N2=N) (fldmap`fresh/< N>F) (fldmap`update/< SN2+F=N)
     <- nat`plus-swap-succ SF+N2=N F+SN2=N
     <- nat`plus-commutative F+SN2=N SN2+F=N
     <- nat`plus-implies-gt SN2+F=N nat`eq/ N>F.

%worlds () (fldmap-shift-implies-fresh-update _ _ _).
%total  SH (fldmap-shift-implies-fresh-update SH _ _).


%theorem fldmap-fresh-update-implies-shift :
        forall* {M1} {M2} {F} {T}
        forall  {FS: fldmap`fresh M2 F}
                {UD: fldmap`update M2 F T (fldmap`map/+ F T M1)}
        exists  {SH: fldmap`shift F M1 M2}
        true.

- : fldmap-fresh-update-implies-shift 
     fldmap`fresh/0 fldmap`update/0 fldmap`shift/0.

- : fldmap-fresh-update-implies-shift
     (fldmap`fresh/< N>F) (fldmap`update/< SN3+F=N) (fldmap`shift/+ SF+N3=N)
     <- nat`plus-swap-succ SN3+F=N N3+SF=N
     <- nat`plus-commutative N3+SF=N SF+N3=N.

%%% impossible cases
- : fldmap-fresh-update-implies-shift F/M2 (fldmap`update/= N=F) SH
     <- nat`eq-symmetric N=F F=N
     <- fldmap`fresh-respects-eq F/M2 fldmap`eq/ F=N N/M2
     <- fldmap`fresh-contradiction N/M2 V
     <- fldmap`false-implies-shift V SH.

- : fldmap-fresh-update-implies-shift 
     (fldmap`fresh/> _ SN3+N=F) (fldmap`update/< SN3+F=N) SH
     <- nat`plus-implies-gt SN3+N=F nat`eq/ F>N
     <- nat`plus-implies-gt SN3+F=N nat`eq/ N>F
     <- nat`gt-anti-symmetric F>N N>F V
     <- fldmap`false-implies-shift V SH.

- : fldmap-fresh-update-implies-shift
     F/M2 (fldmap`update/> N3/M3 SN3+N=F) SH
     <- nat`plus-implies-gt SN3+N=F nat`eq/ F>N
     <- nat`eq-ne-implies-false nat`eq/ (nat`ne/< F>N) V
     <- fldmap`false-implies-shift V SH.

%worlds () (fldmap-fresh-update-implies-shift _ _ _).
%total  UD (fldmap-fresh-update-implies-shift UD _ _).


%%% couldn't find this theorem in fldmap.elf

%theorem fldmap-shift-preserves-fresh :
        forall* {M1} {M2} {N} {F} {T}
        forall  {NM: fldmap`fresh (fldmap`map/+ F T M1) N}
                {SH: fldmap`shift F M1 M2}
        exists  {NM: fldmap`fresh M2 N}
        true.

- : fldmap-shift-preserves-fresh 
     _ fldmap`shift/0 fldmap`fresh/0.

- : fldmap-shift-preserves-fresh FS (fldmap`shift/+ SF+N2=N3) FS1
     <- nat`plus-swap-succ SF+N2=N3 F+SN2=N3
     <- nat`plus-commutative F+SN2=N3 SN2+F=N3
     <- fldmap`update-preserves-fresh-converse FS (fldmap`update/< SN2+F=N3) FS1.

%worlds () (fldmap-shift-preserves-fresh _ _ _).
%total  SH (fldmap-shift-preserves-fresh _ SH _).



%abbrev set-in = [N][S] set`member S N.
%abbrev set-notin = [N][S] set`not-member S N.
%abbrev set-unit-union = [S1][N][S2] set`union S1 (set/+ N set/0) S2.
%abbrev set-unit-remove = [S1][N][S2] set`remove S1 (set/+ N set/0) S2.


%%% bijection between raw field permissions and set members

set-rawfldperm : set -> (object -> permission) -> type.

set-rawfldperm/0 : set-rawfldperm set/0 ([_] empty).

set-rawfldperm/+ 
   : set-rawfldperm S ([t] (unitperm (basic t F null)) , (B t))
      <- set-unit-union S1 F S
      <- set-notin F S1
      <- set-rawfldperm S1 B.


%%% bijection between assembled field permissions and set members

set-fldpred : predmap -> fldmap -> set -> (object -> permission) -> type.

set-fldpred/0 : set-fldpred _ _ set/0 ([_] empty).

set-fldpred/+ 
   : set-fldpred PM FM S ([t] ((W P t) , (R t)))
      <- fldmap`lookup FM F (nulltp/norm C NN)
      <- fldnn2perm F NN ([p][o] W p o)
      <- predmap`lookup PM C P
      <- set-unit-union S1 F S
      <- set-notin F S1
      <- set-fldpred PM FM S1 ([t] R t).


%%% relation between set of fields and expr in constructor
%%% it simply says all fields appeared in the expr must be
%%% in the set.

set-expr : set -> (object -> expr) -> type.

set-expr/0 : set-expr _ ([t] lit t).

set-expr/+
   : set-expr S ([t] (seq (write (lit t) F _)) (B t))
      <- set-in F S
      <- set-expr S B.


%%% property of nonnull set

nonnull-set : fldmap -> set -> type.

nonnull-set/0 : nonnull-set _ set/0.

nonnull-set/+ 
   : nonnull-set FM S 
      <- fldmap`lookup FM F (nulltp/norm _ nn/yes)
      <- set`not-member SP F % this is not necessary, but will make proof easier
      <- set`add SP F S
      <- nonnull-set FM SP.


maynull-set : fldmap -> set -> type.

maynull-set/0 : maynull-set _ set/0.

maynull-set/+ 
   : maynull-set FM S
      <- fldmap`lookup FM F (nulltp/norm _ nn/may)
      <- set`not-member SP F
      <- set`add SP F S
      <- maynull-set FM SP.


%%% a fldmap is good if it doesn't contain null field

good-fldmap : fldmap -> type.

good-fldmap/0 : good-fldmap fldmap`map/0.

good-fldmap/+ : good-fldmap (fldmap`map/+ N (nulltp/norm C NN) M) <- good-fldmap M.


%theorem shift-preserves-good-fldmap :
        forall* {FM} {FM'} {N}
        forall  {GF: good-fldmap FM}
		{SH: fldmap`shift N FM FM'}
        exists  {GF: good-fldmap FM'}
        true.

- : shift-preserves-good-fldmap good-fldmap/0 fldmap`shift/0 good-fldmap/0.

- : shift-preserves-good-fldmap (good-fldmap/+ GF) SH (good-fldmap/+ GF).

%worlds () (shift-preserves-good-fldmap _ _ _).
%total  {} (shift-preserves-good-fldmap _ _ _).


%%% theorems about nonnull-set

%theorem nonnull-set-respects-eq :
     	forall* {FM1} {FM2} {S1} {S2}
	forall  {NNS1: nonnull-set FM1 S1}
		{EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2}
	exists  {NNS2: nonnull-set FM2 S2}
	true.

- : nonnull-set-respects-eq NNS fldmap`eq/ set`eq/ NNS.

%worlds () (nonnull-set-respects-eq _ _ _ _).
%total  {} (nonnull-set-respects-eq _ _ _ _).


%theorem only-nonnull-in-nonnull-set :
        forall* {FM} {S} {F} {C}
        forall  {NNS: nonnull-set FM S}
                {L: fldmap`lookup FM F (nulltp/norm C nn/may)}
        exists  {NM: set`not-member S F}
        true.

- : only-nonnull-in-nonnull-set nonnull-set/0 _ set`not-member/0.

- : only-nonnull-in-nonnull-set (nonnull-set/+ NNSP SP+N=S _ FM#N) FM#F F/S
     <- only-nonnull-in-nonnull-set NNSP FM#F F/SP
     <- diff-lookup-implies-ne FM#F FM#N F!=N
     <- set`update-preserves-not-member F/SP SP+N=S F!=N F/S.

%worlds () (only-nonnull-in-nonnull-set _ _ _).
%total (NNS) (only-nonnull-in-nonnull-set NNS _ _).


%theorem nonnull-set-member-implies-lookup :
        forall* {FM} {S} {F}
        forall  {NNS: nonnull-set FM S}
                {MB: set`member S F} 
        exists  {C} {L: fldmap`lookup FM F (nulltp/norm C nn/yes)}
        true.

%theorem nonnull-set-member-implies-lookup/L :
        forall* {FM} {SP} {S} {F} {N} {B} {C1}
        forall  {NNS: nonnull-set FM SP}
		{NM: set`not-member SP N}
		{AD: set`add SP N S} 
      		{L: fldmap`lookup FM N (nulltp/norm C1 nn/yes)}
		{MB: set`member S F}
		{EQ?: nat`eq? F N B}
	exists  {C2} {L: fldmap`lookup FM F (nulltp/norm C2 nn/yes)}
	true.         

- : nonnull-set-member-implies-lookup/L _ _ _ L _ nat`eq?/yes _ L.

- : nonnull-set-member-implies-lookup/L NNSP _ SP+N=S FM#N S#F (nat`eq?/no F!=N) _ FM#F
    <- set`update-preserves-lookup-converse S#F SP+N=S F!=N SP#F
    <- nonnull-set-member-implies-lookup NNSP SP#F _ FM#F.

- : nonnull-set-member-implies-lookup (nonnull-set/+ NNSP SP+N=S NM FM#N) S#F _ FM#F
    <- nat`eq?-total EQ?
    <- nonnull-set-member-implies-lookup/L NNSP NM SP+N=S FM#N S#F EQ? _ FM#F.

%worlds () (nonnull-set-member-implies-lookup _ _ _ _)
	(nonnull-set-member-implies-lookup/L _ _ _ _ _ _ _ _).

%total  (NNS NNSP) (nonnull-set-member-implies-lookup NNS _ _ _)
	(nonnull-set-member-implies-lookup/L NNSP _ _ _ _ _ _ _).

	
%%% after removing an element from a nonnull set, the result 
%%% should still preserve the property.

%theorem remove-preserves-nonnull-set :
        forall* {FM} {S1} {S2} {F} 
        forall  {NNS: nonnull-set FM S1}
                {RM: set`remove S1 (set/1 F) S2}
        exists  {NNS: nonnull-set FM S2}
        true.

- : remove-preserves-nonnull-set nonnull-set/0 R nonnull-set/0.

%theorem remove-preserves-nonnull-set/L :
	forall* {FM} {SP} {S1} {S2} {F} {N} {C} {B}
 	forall  {NNSP: nonnull-set FM SP}
		{NM: set`not-member SP N}
		{A: set`add SP N S1}
		{L: fldmap`lookup FM N (nulltp/norm C nn/yes)}
		{R: set`remove S1 (set/1 F) S2}
		{EQ?: nat`eq? N F B}
	exists  {NNS: nonnull-set FM S2}
	true.

- : remove-preserves-nonnull-set/L NNSP N/SP SP+N=S1 _ S1/N=S2 nat`eq?/yes NNS2
    <- set`not-member-update-implies-unit-union N/SP SP+N=S1 SPUN=S1
    <- set`union-implies-leq SPUN=S1 SP<=S1 _
    <- set`union-commutative SPUN=S1 NUSP=S1
    <- set`not-member-implies-unit-disjoint N/SP SP^N
    <- set`disjoint-symmetric SP^N N^SP
    <- set`leq-reflexive _ S1<=S1
    <- set`remove-characterization SP<=S1 N^SP NUSP=S1 S1<=S1 S1/N=SP
    <- set`remove-deterministic S1/N=SP S1/N=S2 set`eq/ set`eq/ SP=S2
    <- nonnull-set-respects-eq NNSP fldmap`eq/ SP=S2 NNS2.

- : remove-preserves-nonnull-set/L
     NNSP N/SP SP+N=S1 FM#N S1/F=S2 (nat`eq?/no N!=F) (nonnull-set/+ NNS3 S3+N=S2 N/S3 FM#N)
    <- add-implies-unit-union SP+N=S1 SPUN=S1
    <- set`remove-right-distributes-over-union SPUN=S1 S1/F=S2
	_ _ SP/F=S3 N/F=S4 S3US4=S2
    <- set`ne-implies-disjoint N!=F N^F
    <- set`disjoint-implies-remove-nothing N^F N/F=N
    <- set`remove-implies-leq SP/F=S3 S3<=SP
    <- set`not-member-respects-geq N/SP S3<=SP N/S3
    <- set`remove-unique N/F=S4 N/F=N set`eq/ set`eq/ S4=N
    <- set`union-respects-eq S3US4=S2 set`eq/ S4=N set`eq/ S3UN=S2
    <- set`unit-union-implies-add S3UN=S2 S3+N=S2
    <- remove-preserves-nonnull-set NNSP SP/F=S3 NNS3.

- : remove-preserves-nonnull-set (nonnull-set/+ NNSP A NM L) R NNS2
    <- nat`eq?-total EQ?
    <- remove-preserves-nonnull-set/L NNSP NM A L R EQ? NNS2.

%worlds () (remove-preserves-nonnull-set _ _ _)
           (remove-preserves-nonnull-set/L _ _ _ _ _ _ _).

%total  (NNS1 NNSP) (remove-preserves-nonnull-set NNS1 _ _)
           (remove-preserves-nonnull-set/L NNSP _ _ _ _ _ _).


%%% this theorem says we can use a bigger fldmap 
%%% and still preserve the relation

%theorem fldmap-shift-preserves-nonnull-set :
        forall* {FM1} {FM2} {S} {F} {T}
        forall  {NNS: nonnull-set FM2 S}
                {SH: fldmap`shift F FM1 FM2}
        exists  {NNS: nonnull-set (fldmap`map/+ F T FM1) S}
        true.

- : fldmap-shift-preserves-nonnull-set nonnull-set/0 _ nonnull-set/0.

- : fldmap-shift-preserves-nonnull-set
     (nonnull-set/+ FM2-NQ Q+N=S N/Q FM2#N) F<<FM1=FM2 
     (nonnull-set/+ FM-NQ Q+N=S N/Q (fldmap`lookup/> FM1#N1 SN1+F=N))
     <- fldmap-shift-preserves-nonnull-set FM2-NQ F<<FM1=FM2 FM-NQ
     <- fldmap`shift-preserves-lookup-converse FM2#N F<<FM1=FM2 _ SF+N1=N FM1#N1
     <- nat`plus-swap-succ SF+N1=N F+SN1=N
     <- nat`plus-commutative F+SN1=N SN1+F=N.

%worlds () (fldmap-shift-preserves-nonnull-set _ _ _).
%total NNS (fldmap-shift-preserves-nonnull-set NNS _ _).


%%% if a set is nonnull, then after putting in a nonnull-type field, it 
%%% should still be nonnull.

%theorem union-preserves-nonnull-set :
        forall* {FM} {S1} {S2} {F} {C}
        forall  {NNS: nonnull-set FM S1}
		{NM: set`not-member S1 F}			
                {U: set`union S1 (set/1 F) S2}
                {L: fldmap`lookup FM F (nulltp/norm C nn/yes)}
        exists  {NNS: nonnull-set FM S2}
        true.

- : union-preserves-nonnull-set NS1 NM U L (nonnull-set/+ NS1 A NM L)
     <- set`unit-union-implies-add U A.

%worlds () (union-preserves-nonnull-set _ _ _ _ _).
%total (NS) (union-preserves-nonnull-set NS _ _ _ _).


%theorem filt-nnflds-implies-leq :
	forall* {FM} {S1} {S2}
	forall  {DM: fldmap`domain FM S1}
		{FNN: filt-nnflds FM S2}
	exists  {LE: set`leq S2 S1}
	true.		

- : filt-nnflds-implies-leq fldmap`domain/0 filt-nnflds/0 set`leq/0.

- : filt-nnflds-implies-leq
     (fldmap`domain/+ DM-FM=Q) (filt-nnflds/in SPUN=S2 FMP=>SP N<<FM=FMP) S2<=S1
     <- fldmap`shift-preserves-domain DM-FM=Q N<<FM=FMP _ N<<Q=QP DM-FMP=QP
     <- filt-nnflds-implies-leq DM-FMP=QP FMP=>SP SP<=QP
     <- set`can-construct-unit-union N<<Q=QP QPUN=S1
     <- set`union-right-preserves-leq* SP<=QP SPUN=S2 QPUN=S1 S2<=S1.

- : filt-nnflds-implies-leq
     (fldmap`domain/+ DM-FM=Q) (filt-nnflds/out FMP=>S2 N<<FM=FMP) S2<=S1
     <- fldmap`shift-preserves-domain DM-FM=Q N<<FM=FMP _ N<<Q=QP DM-FMP=QP
     <- filt-nnflds-implies-leq DM-FMP=QP FMP=>S2 S2<=QP
     <- set`can-construct-unit-union N<<Q=QP QPUN=S1
     <- set`union-implies-leq QPUN=S1 QP<=S1 _
     <- set`leq-transitive S2<=QP QP<=S1 S2<=S1.

%worlds () (filt-nnflds-implies-leq _ _ _).
%total (FNN) (filt-nnflds-implies-leq _ FNN _).


%theorem filt-nnflds-implies-nonnull-set :
        forall* {FM} {S}
        forall  {FF: filt-nnflds FM S}
        exists  {NS: nonnull-set FM S}
        true.

- : filt-nnflds-implies-nonnull-set filt-nnflds/0 nonnull-set/0.

- : filt-nnflds-implies-nonnull-set
     (filt-nnflds/in SPUF=S FMP->SP F<<FM=FMP) FM-NN-S
     <- filt-nnflds-implies-nonnull-set FMP->SP FMP-NN-SP
     <- fldmap`shift-implies-fresh F<<FM=FMP F/FMP
     <- fldmap-shift-preserves-nonnull-set FMP-NN-SP F<<FM=FMP FM-NN-SP
     <- filt-nnflds-preserves-fresh FMP->SP F/FMP F/SP
     <- union-preserves-nonnull-set FM-NN-SP F/SP SPUF=S (fldmap`lookup/= nat`eq/) FM-NN-S.

- : filt-nnflds-implies-nonnull-set
     (filt-nnflds/out FMP-S F<<FM=FMP) FM-NN-S
     <- filt-nnflds-implies-nonnull-set FMP-S FMP-NN-S
     <- fldmap-shift-preserves-nonnull-set FMP-NN-S F<<FM=FMP FM-NN-S.

%worlds () (filt-nnflds-implies-nonnull-set _ _).
%total FF (filt-nnflds-implies-nonnull-set FF _).


%%% theorems about maynull-set

%theorem maynull-set-respects-eq :
     	forall* {FM1} {FM2} {S1} {S2}
	forall  {MNS1: maynull-set FM1 S1}
		{EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2}
	exists  {MNS2: maynull-set FM2 S2}
	true.

- : maynull-set-respects-eq MNS fldmap`eq/ set`eq/ MNS.

%worlds () (maynull-set-respects-eq _ _ _ _).
%total  {} (maynull-set-respects-eq _ _ _ _).


%%% theorems about set-fldpred

%theorem set-fldpred-respects-eq :
	forall* {PM1} {PM2} {FM1} {FM2} {S1} {S2} {P1} {P2}
	forall  {SF: set-fldpred PM1 FM1 S1 ([t] P1 t)}
		{EQ: predmap`eq PM1 PM2} {EQ: fldmap`eq FM1 FM2}
		{EQ: set`eq S1 S2} {EQ: {o} permission`eq (P1 o) (P2 o)}
	exists  {SF: set-fldpred PM2 FM2 S2 ([t] P2 t)}
	true.

- : set-fldpred-respects-eq SF predmap`eq/ fldmap`eq/ set`eq/ ([_] permission`eq/) SF.

%worlds () (set-fldpred-respects-eq _ _ _ _ _ _).
%total  {} (set-fldpred-respects-eq _ _ _ _ _ _).


%theorem set-fldpred-shrink-fldmap :
        forall* {PM} {FM1} {FM} {S} {R} {F} {T} 
        forall  {SF: set-fldpred PM FM1 S ([t] (R t))}
                {FS: set`not-member S F}
                {U: fldmap`update FM F T FM1}
        exists  {SF: set-fldpred PM FM S ([t] (R t))}
        true.

- : set-fldpred-shrink-fldmap set-fldpred/0 _ _ set-fldpred/0.

- : set-fldpred-shrink-fldmap
     (set-fldpred/+ S1-R N/S1 S1UN=S PM-L FNN2P FM1-L) F/S FM+F=FM1 
     (set-fldpred/+ S1-R1 N/S1 S1UN=S PM-L FNN2P FM-L)
     <- set`union-preserves-not-member-converse* F/S S1UN=S F/S1 _
     <- set-fldpred-shrink-fldmap S1-R F/S1 FM+F=FM1 S1-R1
     <- set`union-left-preserves-member* (set`lookup/= nat`eq/) S1UN=S N#S
     <- set`not-member-lookup-not-equal F/S N#S F!=N
     <- nat`ne-symmetric F!=N N!=F
     <- fldmap`update-preserves-lookup-converse FM1-L FM+F=FM1 N!=F FM-L.

%worlds (objvar) (set-fldpred-shrink-fldmap _ _ _ _).
%total  SF (set-fldpred-shrink-fldmap SF _ _ _).


%%% this theorem can be extended when N is replaced by a set that is disjoint with S1

%theorem not-member-add-implies-remove :
	forall* {S1} {S2} {N}
	forall  {AD: set`not-member S1 N}
		{NM: set`add S1 N S2}
	exists  {RM: set`remove S2 (set/1 N) S1}
	true.				  

- : not-member-add-implies-remove N/S1 S1+N=S2 S2-N=S1
     <- set`not-member-implies-unit-disjoint N/S1 S1^N
     <- set`disjoint-symmetric S1^N N^S1
     <- set`add-implies-unit-union S1+N=S2 S1UN=S2
     <- set`union-commutative S1UN=S2 NUS1=S2
     <- set`union-implies-leq NUS1=S2 N<=S2 S1<=S2
     <- set`leq-reflexive _ S2<=S2
     <- set`remove-characterization S1<=S2 N^S1 NUS1=S2 S2<=S2 S2-N=S1.

%worlds () (not-member-add-implies-remove _ _ _).
%total  {} (not-member-add-implies-remove _ _ _).


%%% a long lemma about set...


%theorem set-not-member-preserves-leq :
	forall* {A} {B} {C} {N}
	forall  {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
	exists  {LE: set`leq A C}
	true.		

%theorem set-not-member-preserves-leq/L1 :
	forall* {A} {B} {C} {N} {K}
	forall  {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
		{LE?: set`leq? A C K}
	exists  {LE: set`leq A C}
	true.		

- : set-not-member-preserves-leq/L1 A<=B N/A C+N=B A<=C A<=C.

%theorem set-not-member-preserves-leq/L2 :
	forall* {A} {B} {C} {N} {M} {K} 
	forall  {LE: set`leq A B}
		{NM: set`not-member A N}
		{AD: set`add C N B}
		{EQ?: nat`eq? N M K}
		{MB: set`member A M}
		{NM: set`not-member C M}
	exists  {LE: set`leq A C}
	true.

- : set-not-member-preserves-leq/L2 _ N/A _ nat`eq?/yes N<-A _ A<=C
     <- set`member-not-member-contradiction N<-A N/A F
     <- set`false-implies-leq F A<=C.
     
- : set-not-member-preserves-leq/L2
     A<=B N/A C+N=B (nat`eq?/no N!=M) M<-A M/C A<=C
     <- set`member-respects-leq M<-A A<=B M<-B
     <- nat`ne-symmetric N!=M M!=N
     <- set`update-preserves-not-member M/C C+N=B M!=N M/B
     <- set`member-not-member-contradiction M<-B M/B F
     <- set`false-implies-leq F A<=C.
     
%worlds () (set-not-member-preserves-leq/L2 _ _ _ _ _ _ _).
%total  (EQ?) (set-not-member-preserves-leq/L2 _ _ _ EQ? _ _ _).

- : set-not-member-preserves-leq/L1 A<=B N/A C+N=B (set`nle/< M<-A M/C) A<=C
     <- nat`eq?-total N?=M
     <- set-not-member-preserves-leq/L2 A<=B N/A C+N=B N?=M M<-A M/C A<=C.

%worlds () (set-not-member-preserves-leq/L1 _ _ _ _ _).
%total  (LE?) (set-not-member-preserves-leq/L1 _ _ _ LE? _).

- : set-not-member-preserves-leq A<=B N/A C+N=B A<=C
     <- set`leq?-total A<=?C
     <- set-not-member-preserves-leq/L1 A<=B N/A C+N=B A<=?C A<=C.

%worlds () (set-not-member-preserves-leq _ _ _ _).
%total  {} (set-not-member-preserves-leq _ _ _ _).


%theorem fnn-rm-imp-mns/LL2 :
	forall* {A} {B} {C} {D} {E} {F} {N}
	forall  {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
	exists  {LE: set`leq A F}
	true.

%theorem fnn-rm-imp-mns/LL2B1 :
	forall* {A} {B} {C} {D} {E} {F} {N} {K}
	forall  {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
		{LE?: set`leq? A F K}
	exists  {LE: set`leq A F}
	true.

- : fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ A<=F A<=F.

%theorem fnn-rm-imp-mns/LL2B2 :
	forall* {A} {B} {C} {D} {E} {F} {N} {M} {K1} {K2}
	forall  {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
		{U: set`union C E F}
		{MB: set`member A M}
		{NM: set`not-member F M}
		{MB?: set`member? D M K1}
		{EQ?: nat`eq? N M K2}
	exists  {LE: set`leq A F}
	true.

- : fnn-rm-imp-mns/LL2B2 _ _ N/A _ _ _ N<-A _ _ nat`eq?/yes A<=F
     <- set`member-not-member-contradiction N<-A N/A V
     <- set`false-implies-leq V A<=F.

- : fnn-rm-imp-mns/LL2B2 
     A+N=B C+N=D N/A N/C B/D=E CUE=F M<-A M/F (set`member?/in M<-D) (nat`eq?/no N!=M) A<=F
     <- set`not-member-update-implies-leq N/A A+N=B A<=B
     <- set`member-respects-leq M<-A A<=B M<-B
     <- set`add-implies-unit-union C+N=D CUN=D
     <- set`ne-implies-unit-map-not-member N!=M M/N
     <- set`not-member-union-right-preserves-lookup-converse M<-D M/N CUN=D M<-C
     <- set`union-preserves-not-member-converse* M/F CUE=F M/C M/E
     <- set`member-not-member-contradiction M<-C M/C V 
     <- set`false-implies-leq V A<=F.

- : fnn-rm-imp-mns/LL2B2
     A+N=B C+N=D N/A N/C (set`remove/ _ _ DUE=G B<=G)
     CUE=F M<-A M/F (set`member?/out M/D) (nat`eq?/no N!=M) A<=F
     <- set`not-member-update-implies-leq N/A A+N=B A<=B
     <- set`member-respects-leq M<-A A<=B M<-B
     <- set`member-respects-leq M<-B B<=G M<-G
     <- set`not-member-union-left-preserves-member-converse M/D M<-G DUE=G M<-E
     <- set`union-preserves-not-member-converse* M/F CUE=F M/C M/E
     <- set`member-not-member-contradiction M<-E M/E V 
     <- set`false-implies-leq V A<=F.

%worlds (objvar) (fnn-rm-imp-mns/LL2B2 _ _ _ _ _ _ _ _ _ _ _).
%total  {} (fnn-rm-imp-mns/LL2B2 _ _ _ _ _ _ _ _ _ _ _).

- : fnn-rm-imp-mns/LL2B1 
     A+N=B C+N=D N/A N/C B/D=E CUE=F (set`nle/< M<-A M/F) A<=F
     <- set`member?-total M<-D?
     <- nat`eq?-total N=M?
     <- fnn-rm-imp-mns/LL2B2 A+N=B C+N=D N/A N/C B/D=E CUE=F M<-A M/F M<-D? N=M? A<=F.

%worlds () (fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ _ _).
%total  {} (fnn-rm-imp-mns/LL2B1 _ _ _ _ _ _ _ _).

- : fnn-rm-imp-mns/LL2 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F
     <- set`leq?-total A<=F?
     <- fnn-rm-imp-mns/LL2B1 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F? A<=F.
     
%worlds (objvar) (fnn-rm-imp-mns/LL2 _ _ _ _ _ _ _).
%total  {} (fnn-rm-imp-mns/LL2 _ _ _ _ _ _ _).


%theorem fnn-rm-imp-mns/L1 :
	forall* {A} {B} {C} {D} {E} {N}
	forall  {AD: set`add A N B}
		{AD: set`add C N D}
		{NM: set`not-member A N}
		{NM: set`not-member C N}
		{R: set`remove B D E}
	exists  {R: set`remove A C E}
	true.

- : fnn-rm-imp-mns/L1 A+N=B C+N=D N/A N/C B/D=E %{=>}% A/C=E
     <- set`remove-implies-leq B/D=E E<=B
     <- set`add-implies-member C+N=D N<-D
     <- set`remove-implies-disjoint B/D=E D^E
     <- set`disjoint-lookup-implies-not-member N<-D D^E N/E
     <- set-not-member-preserves-leq E<=B N/E A+N=B E<=A
     <- set`not-member-update-implies-leq N/C C+N=D C<=D
     <- set`disjoint-respects-geq* D^E C<=D C^E
     <- set`union-total CUE=F
     <- fnn-rm-imp-mns/LL2 A+N=B C+N=D N/A N/C B/D=E CUE=F A<=F
     <- remove-characterization E<=A C^E CUE=F A<=F A/C=E.

%worlds (objvar) (fnn-rm-imp-mns/L1 _ _ _ _ _ _).
%total  {} (fnn-rm-imp-mns/L1 _ _ _ _ _ _).


%theorem fnn-rm-imp-mns/L2 :
	forall* {A} {B} {C} {D} {E}
	forall  {U: set`union A B C}
		{X: set`disjoint B D}
		{R: set`remove C D E}
	exists  {F} {R: set`remove A D F}
		{U: set`union F B E}
	true.

- : fnn-rm-imp-mns/L2 AUB=C B^D C-D=E F A-D=F FUB=E
     <- set`remove-right-distributes-over-union AUB=C C-D=E F H A-D=F B-D=H FUH=E
     <- set`disjoint-implies-remove-nothing B^D B-D=B
     <- set`remove-deterministic B-D=H B-D=B set`eq/ set`eq/ H=B
     <- set`union-respects-eq FUH=E set`eq/ H=B set`eq/ FUB=E.

%worlds (objvar) (fnn-rm-imp-mns/L2 _ _ _ _ _ _ ).
%total  {} (fnn-rm-imp-mns/L2 _ _ _ _ _ _ ).


%theorem fnn-rm-imp-mns/L3 :
	forall* {FM} {FMP} {S} {N} {T} {F}
	forall  {MNS: maynull-set FMP S}
		{SH: fldmap`shift N FM FMP}
	exists  {SF: maynull-set (fldmap`map/+ F T FM) S}
	true.

%worlds (objvar) (fnn-rm-imp-mns/L3 _ _ _).
%trustme %total {} (fnn-rm-imp-mns/L3 _ _ _).


%theorem fnn-rm-imp-mns :
        forall* {CM} {PM} {FM} {S} {S1} {S2}
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-FM: clsmap-fldmap CM FM}
                {DM: fldmap`domain FM S}
                {FNN: filt-nnflds FM S1}
                {RM: set`remove S S1 S2}
        exists  {MNS: maynull-set FM S2}
        true.

- : fnn-rm-imp-mns _ _ fldmap`domain/0 _ _ maynull-set/0.

- : fnn-rm-imp-mns 
     CM2PM (clsmap-fldmap/+ CM-FM _) (fldmap`domain/+ DM-FM=SS)
     (filt-nnflds/in S1PUN=S1 FMP->S1P N<<FM=FMP) S/S1=S2 %{=>}% MN-S2
     <- fldmap`shift-preserves-domain DM-FM=SS N<<FM=FMP _ N<<SS=SP DM-FMP=SP
     <- shift-preserves-clsmap-fldmap CM-FM N<<FM=FMP CM-FMP
     <- set`shift-implies-not-member N<<SS=SP N/SP
     <- set`can-construct-unit-union N<<SS=SP SPUN=S
     <- set`unit-union-implies-add SPUN=S SP+N=S
     <- set`unit-union-implies-add S1PUN=S1 S1P+N=S1
     <- fldmap`shift-implies-fresh N<<FM=FMP N/FMP
     <- filt-nnflds-preserves-fresh FMP->S1P N/FMP N/S1P
     <- fnn-rm-imp-mns/L1 SP+N=S S1P+N=S1 N/SP N/S1P S/S1=S2 SP/S1P=S2
     <- fnn-rm-imp-mns CM2PM CM-FMP DM-FMP=SP FMP->S1P SP/S1P=S2 FMP-MN-S2
     <- fnn-rm-imp-mns/L3 FMP-MN-S2 N<<FM=FMP MN-S2.

- : fnn-rm-imp-mns
     CM2PM (clsmap-fldmap/+ CM-FM _) (fldmap`domain/+ DM-FM=SS)
     (filt-nnflds/out FMP->S1 N<<FM=FMP) S/S1=S2 
     (maynull-set/+ MN-S3 S3+N=S2 N/S3 (fldmap`lookup/= nat`eq/))
     <- fldmap`shift-preserves-domain DM-FM=SS N<<FM=FMP _ N<<SS=SP DM-FMP=SP
     <- shift-preserves-clsmap-fldmap CM-FM N<<FM=FMP CM-FMP
     <- fldmap`shift-implies-fresh N<<FM=FMP N/FMP
     <- filt-nnflds-preserves-fresh FMP->S1 N/FMP N/S1
     <- set`can-construct-unit-union N<<SS=SP SPUN=S
     <- set`unit-union-implies-add SPUN=S SP+N=S
     <- set`not-member-implies-unit-disjoint N/S1 S1^N
     <- set`disjoint-symmetric S1^N N^S1
     <- fnn-rm-imp-mns/L2 SPUN=S N^S1 S/S1=S2 S3 SP/S1=S3 S3UN=S2
     <- set`unit-union-implies-add S3UN=S2 S3+N=S2
     <- fnn-rm-imp-mns CM2PM CM-FMP DM-FMP=SP FMP->S1 SP/S1=S3 FMP-MN-S3
     <- fnn-rm-imp-mns/L3 FMP-MN-S3 N<<FM=FMP MN-S3
     <- set`shift-implies-not-member N<<SS=SP N/SP
     <- set`remove-implies-leq SP/S1=S3 S3<=SP
     <- set`not-member-respects-geq N/SP S3<=SP N/S3.

%worlds (objvar) (fnn-rm-imp-mns _ _ _ _ _ _).
%total  (FN) (fnn-rm-imp-mns _ _ _ FN _ _).


% theorems about set-rawfldperm

%theorem set-rawfldperm-respects-eq :
	forall* {S1} {P1} {S2} {P2} 
	forall  {SR: set-rawfldperm S1 ([t] P1 t)}
		{EQ: set`eq S1 S2} {EQ: {t} permission`eq (P1 t) (P2 t)}
	exists  {SR: set-rawfldperm S2 ([t] P2 t)}
	true.

- : set-rawfldperm-respects-eq SR set`eq/ ([_] permission`eq/) SR.

%worlds (objvar) (set-rawfldperm-respects-eq _ _ _ _).
%total  {} (set-rawfldperm-respects-eq _ _ _ _).


%theorem allocfields-implies-set-rawfldperm :
	forall* {FM} {S} {P1} 
	forall  {DM: fldmap`domain FM S}
		{SR: {t} allocFields t S (P1 t)}
	exists  {P2} {I: {t} implies (P1 t) (P2 t)}
                {SR: set-rawfldperm S ([t] P2 t)}
	true.

- : allocfields-implies-set-rawfldperm
     fldmap`domain/0 ([_] allocFields/0) _ ([_] implies/reflexive) set-rawfldperm/0.


- : allocfields-implies-set-rawfldperm 
     (fldmap`domain/+ DM-FM) ([t] allocFields/+ F<<S=SP (SP->PP t)) 
     _ ([t] implies/trans
	  (implies/equiv equiv/commute)
	  (implies/combine
	     (implies/reflexive)
	     (I t)))
     (set-rawfldperm/+ SP-B F/SP SPUF=S)
     <- fldmap`shift-total F<<FM=FMP
     <- fldmap`shift-preserves-domain* DM-FM F<<FM=FMP F<<S=SP DM-FMP
     <- allocfields-implies-set-rawfldperm DM-FMP SP->PP _ ([t] I t) SP-B
     <- set`shift-implies-not-member F<<S=SP F/SP
     <- set`shift-implies-update F<<S=SP SP+N=S
     <- set`add-implies-unit-union SP+N=S SPUF=S.

%worlds (objvar) (allocfields-implies-set-rawfldperm _ _ _ _ _).
%total  (SR) (allocfields-implies-set-rawfldperm _ SR _ _ _).


%theorem remove-not-member-implies-same-result :
	forall* {S} {S1} {S2} {N}
	forall  {RM: set`remove S S1 S2}
		{NM: set`not-member S N}
		{MB: set`member S1 N}
	exists  {S3} {NM: set`not-member S3 N}
		{RM: set`remove S S3 S2}
		{AD: set`add S3 N S1}
	true.

- : remove-not-member-implies-same-result 
     S-S1=S2 N/S N<-S1 %{=>}% S3 N/S3 S-S3=S2 S3+N=S1
     <- set`lookup-implies-union N<-S1 S3 N/S3 NUS3=S1
     <- set`union-commutative NUS3=S1 S3UN=S1 
     <- set`unit-union-implies-add S3UN=S1 S3+N=S1
     <- set`remove-associates-union-converse NUS3=S1 S-S1=S2 S4 S-N=S4 S4-S3=S2
     <- set`not-member-implies-unit-disjoint N/S S^N
     <- set`disjoint-implies-remove-nothing S^N S-N=S
     <- set`remove-unique S-N=S4 S-N=S set`eq/ set`eq/ S4=S
     <- set`remove-respects-eq S4-S3=S2 S4=S set`eq/ set`eq/ S-S3=S2.

%worlds () (remove-not-member-implies-same-result _ _ _ _ _ _ _).
%total  {} (remove-not-member-implies-same-result _ _ _ _ _ _ _).


%theorem rm-psv-sfp :
	forall* {S} {S1} {S2} {P}
	forall  {SP: set-rawfldperm S ([t] P t)}
		{LE: set`leq S1 S}
		{RM: set`remove S S1 S2}
	exists  {P1} {P2} {I: {t} implies (P t) ((P1 t) , (P2 t))}
		{S1: set-rawfldperm S1 ([t] P1 t)}
		{SP: set-rawfldperm S2 ([t] P2 t)}
	true.

- : rm-psv-sfp set-rawfldperm/0 _ _ _ _
     ([_] implies/equiv (equiv/symmetric equiv/identity)) 
     set-rawfldperm/0 set-rawfldperm/0.


%theorem rm-psv-sfp/L :
	forall* {B} {SP} {S} {S1} {S2} {S3} {S4} {N} {PP} 
	forall  {MB?: set`member? S1 N B}
		{SR: set-rawfldperm SP ([t] PP t)}
		{NM: set`not-member SP N}
		{U: set`union SP (set/1 N) S}
		{LE: set`leq S1 S}
		{RM: set`remove S S1 S2}
		{R: set`remove SP S1 S3}
		{R: set`remove (set/1 N) S1 S4}
		{U: set`union S3 S4 S2}
	exists  {P1} {S1-P1: set-rawfldperm S1 ([t] P1 t)}
		{P2} {S2-P2: set-rawfldperm S2 ([t] P2 t)}
		{I: {t} implies ((unitperm (basic t N null)) , (PP t)) ((P1 t) , (P2 t))}
	true.

- : rm-psv-sfp/L (set`member?/out N/S1) 
     SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4 S3US4=S2 _ S1-P1 _
     (set-rawfldperm/+ S3-P3 N/S3 S3UN=S2) 
     ([t] implies/trans
	(implies/combine (implies/reflexive) (PP=>P1P3 t))
	(implies/equiv equiv/roll2))
     <- set`unit-union-implies-add SPUN=S SP+N=S
     <- set-not-member-preserves-leq S1<=S N/S1 SP+N=S S1<=SP
     <- rm-psv-sfp SP-PP S1<=SP SP-S1=S3 P1 P3 PP=>P1P3 S1-P1 S3-P3
     <- set`remove-implies-leq SP-S1=S3 S3<=SP
     <- set`not-member-respects-geq N/SP S3<=SP N/S3
     <- set`not-member-implies-unit-disjoint N/S1 S1^N
     <- set`disjoint-symmetric S1^N N^S1
     <- set`disjoint-implies-remove-nothing N^S1 N-S1=N
     <- set`remove-unique N-S1=S4 N-S1=N set`eq/ set`eq/ S4=N
     <- set`union-respects-eq S3US4=S2 set`eq/ S4=N set`eq/ S3UN=S2.

- : rm-psv-sfp/L (set`member?/in N<-S1)
     SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4 S3US4=S2 _ 
     (set-rawfldperm/+ S5-P5 N/S5 S5UN=S1) _ S2-P3 
     ([t] implies/trans
	(implies/combine
	   (implies/reflexive)
	   (PP=>P5P3 t))
	(implies/equiv equiv/associate))
     <- remove-not-member-implies-same-result
	SP-S1=S3 N/SP N<-S1 S5 N/S5 SP-S5=S3 S5+N=S1
     <- set`unit-union-implies-add SPUN=S SP+N=S
     <- set`add-implies-unit-union S5+N=S1 S5UN=S1
     <- not-member-add-implies-remove N/S5 S5+N=S1 S1-N=S5
     <- not-member-add-implies-remove N/SP SP+N=S S-N=SP
     <- set`remove-right-preserves-leq S1<=S S1-N=S5 S-N=SP S5<=SP
     <- rm-psv-sfp SP-PP S5<=SP SP-S5=S3 P5 P3 ([t] PP=>P5P3 t) S5-P5 S3-P3
     <- set`member-implies-unit-leq N<-S1 N<=S1
     <- set`leq-implies-remove-all N<=S1 N-S1=0
     <- set`remove-unique N-S1=S4 N-S1=0 set`eq/ set`eq/ S4=0
     <- set`union-respects-eq S3US4=S2 set`eq/ S4=0 set`eq/ S3U0=S2
     <- set`union-unique S3U0=S2 set`union/R set`eq/ set`eq/ S2=S3
     <- set`eq-symmetric S2=S3 S3=S2
     <- set-rawfldperm-respects-eq S3-P3 S3=S2 ([_] permission`eq/) S2-P3.

- : rm-psv-sfp (set-rawfldperm/+ SP-PP N/SP SPUN=S) S1<=S S-S1=S2 
     _ _ IMP S1-P1 S2-P2
     <- set`remove-right-distributes-over-union
 	SPUN=S S-S1=S2 S3 S4 SP-S1=S3 N-S1=S4 S3US4=S2
     <- set`member?-total N<-S1?
     <- rm-psv-sfp/L N<-S1? SP-PP N/SP SPUN=S S1<=S S-S1=S2 SP-S1=S3 N-S1=S4
	S3US4=S2 _ S1-P1 _ S2-P2 IMP.

%worlds (objvar)
(rm-psv-sfp _ _ _ _ _ _ _ _)
(rm-psv-sfp/L _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total (P1 P2) 
(rm-psv-sfp P1 _ _ _ _ _ _ _)
(rm-psv-sfp/L _ P2 _ _ _ _ _ _ _ _ _ _ _ _).


%%% this theorem says given a bijection between a set and a sequence of bare
%%% field permissions, for any given element in the set, we can reorder the 
%%% permissions and move the corresponding field permission to the front.
%%% the rest of set and rest permission still preserve the bijection property.

%theorem set-rawfldperm-reorder :
        forall* {S} {FP} {F} 
        forall  {S-RP: set-rawfldperm S ([t] FP t)} {IN: set-in F S}
        exists  {R} {IMP: {t} implies (FP t) ((unitperm (basic t F null)) , (R t))}
                {S1} {S1-R: set-rawfldperm S1 ([t] R t)}
                {NM: set-notin F S1} {U: set-unit-union S1 F S}		
	true.			   

%theorem set-rawfldperm-reorder/L :
        forall* {S} {S1} {F} {N} {R} 
        forall  {C} {CMP: nat`compare N F C}
                {S1-R: set-rawfldperm S1 ([t] R t)}
                {N/S1: set-notin N S1}
                {U: set-unit-union S1 N S}
                {IN: set-in F S}
        exists  {RP}
                {IMP: {t} implies ((unitperm (basic t N null)) , (R t))
		       ((unitperm (basic t F null)) , (RP t))}
                {S2} {S2-RP: set-rawfldperm S2 ([t] RP t)}
		{F/S2: set-notin F S2} {U: set-unit-union S2 F S}
	true.			     
		       
- : set-rawfldperm-reorder/L equal
     _ S1-R N/S1 S1UN=S _ _ ([_] implies/reflexive) _ S1-R N/S1 S1UN=S.

- : set-rawfldperm-reorder/L less
     C S1-R N/S1 S1UN=S F&S _ 
     ([t] implies/trans
	(implies/combine
	   (implies/reflexive)
	   (IMP t))
	(implies/equiv equiv/roll2))
     S3 (set-rawfldperm/+ S2-RP N/S2 S2UN=S3) F/S3 S3UF=S
     <- nat`less-implies-lt C F>N
     <- set`ne-implies-unit-map-not-member (nat`ne/< F>N) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-rawfldperm-reorder S1-R F&S1 RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S1
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-rawfldperm-reorder/L greater
     C S1-R N/S1 S1UN=S F&S _ 
     ([t] implies/trans
	(implies/combine
	   (implies/reflexive)
	   (IMP t))
	(implies/equiv equiv/roll2))
     S3 (set-rawfldperm/+ S2-RP N/S2 S2UN=S3) F/S3 S3UF=S
     <- nat`greater-implies-gt C N>F
     <- set`ne-implies-unit-map-not-member (nat`ne/> N>F) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-rawfldperm-reorder S1-R F&S1 RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S1
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-rawfldperm-reorder
     (set-rawfldperm/+ S1-R N/S1 S1UN=S) F&S RP ([t] IMP t) S2 S2-RP F/S2 S2UF=S
     <- nat`compare-total CMP
     <- set-rawfldperm-reorder/L _ CMP S1-R N/S1 S1UN=S F&S RP IMP S2 S2-RP F/S2 S2UF=S.

%worlds (objvar)
(set-rawfldperm-reorder _ _ _ _ _ _ _ _)
(set-rawfldperm-reorder/L _ _ _ _ _ _ _ _ _ _ _ _).

%total (SP1 SP2)
(set-rawfldperm-reorder SP1 _ _ _ _ _ _ _)
(set-rawfldperm-reorder/L _ _ SP2 _ _ _ _ _ _ _ _ _).


%%% we need to show the size is actually decreasing...
%%% this is like the opposite of not-member-update-increase-size

%theorem mns-imp-sfp/LL1 :
	forall* {A} {B} {N} {M}
	forall  {SZ: set`size A (s N)}
		{NM: set`not-member B M}
		{AD: set`add B M A}
	exists  {SZ: set`size B N}
	true.

- : mns-imp-sfp/LL1 SZA M/B B+M=A SZ-B=N
     <- set`add-implies-member B+M=A M<-A
     <- set`can-remove SZA M<-A AP L SZ-AP=L SL=SN AP+M=A M/AP
     <- not-member-add-implies-remove M/AP AP+M=A A-M=AP
     <- not-member-add-implies-remove M/B B+M=A A-M=B
     <- set`remove-unique A-M=AP A-M=B set`eq/ set`eq/ AP=B
     <- nat`succ-cancels SL=SN L=N
     <- set`size-respects-eq SZ-AP=L AP=B L=N SZ-B=N.

%worlds () (mns-imp-sfp/LL1 _ _ _ _).
%total  {} (mns-imp-sfp/LL1 _ _ _ _).


%theorem mns-imp-sfp/LL2 :
	forall* {PM} {F} {W} {P} {C}
	forall  {FNN2P: fldnn2perm F nn/may ([p][o] W p o)}
		{PML: predmap`lookup PM C P}
	exists  {I: {o} implies (unitperm (basic o F null)) (W P o)}
	true.

- : mns-imp-sfp/LL2 fldnn2perm/may _
     ([_] implies/trans3
	(implies/equiv
	   (equiv/symmetric equiv/identity))
	(implies/combine
	   (implies/reflexive)
	   (implies/trans3
	      (implies/equiv
		 (equiv/symmetric equiv/identity)) 
	      (implies/combine
		 (implies/trans
		    (implies/empty2true)
		    (implies/nonlinear
		       (bimplies/objequal-reflexive)))
		 (implies/reflexive))
	      (implies/cond-intro)))
	(implies/pack null)).

%worlds (objvar) (mns-imp-sfp/LL2 _ _ _).
%total  {} (mns-imp-sfp/LL2 _ _ _).


%theorem mns-imp-sfp/L :
	forall* {PM} {CM} {FM} {S} {Pi1}
	forall  {N} {SZ: set`size S N}
		{CM-FM: clsmap-fldmap CM FM}
		{CM2PM: clsmap2predmap CM PM}
		{MNS: maynull-set FM S}
		{SRP: set-rawfldperm S ([t] Pi1 t)}
	exists  {Pi2} {I: {t} implies (Pi1 t) (Pi2 t)}
		{SFP: set-fldpred PM FM S ([t] Pi2 t)}
	true.

- : mns-imp-sfp/L z _ _ _ maynull-set/0 set-rawfldperm/0 _ ([t] implies/reflexive) set-fldpred/0.

- : mns-imp-sfp/L (s N) SZ
     CM-FM CM2PM (maynull-set/+ MN-SP SP+N=S N/SP FM#N)
     SRP _ ([t] implies/trans (I t) (implies/combine (I2 t) (I3 t)))
     (set-fldpred/+ S1-SF-R N/S1 S1UN=S PML FNN2P FM#N)
     <- set`add-implies-member SP+N=S N<-S
     <- set-rawfldperm-reorder SRP N<-S _ ([t] I t) S1 S1-R N/S1 S1UN=S
     <- set`unit-union-implies-add S1UN=S S1+N=S
     <- not-member-add-implies-remove N/SP SP+N=S S-N=SP
     <- not-member-add-implies-remove N/S1 S1+N=S S-N=S1
     <- set`remove-unique S-N=SP S-N=S1 set`eq/ set`eq/ SP=S1
     <- clsmap-fldmap-implies-lookup CM-FM FM#N _ CML
     <- clsmap2predmap-implies-predmap-lookup CM2PM CML _ PML
     <- fldnn2perm-total FNN2P
     <- mns-imp-sfp/LL2 FNN2P PML ([t] I2 t)
     <- maynull-set-respects-eq MN-SP fldmap`eq/ SP=S1 MN-S1
     <- mns-imp-sfp/LL1 SZ N/SP SP+N=S SZP
     <- set`size-respects-eq SZP SP=S1 nat`eq/ SZS1
     <- mns-imp-sfp/L _ SZS1 CM-FM CM2PM MN-S1 S1-R _ ([t] I3 t) S1-SF-R.

%worlds (objvar) (mns-imp-sfp/L _ _ _ _ _ _ _ _ _).
%total (N) (mns-imp-sfp/L N _ _ _ _ _ _ _ _).


%theorem mns-imp-sfp :
	forall* {PM} {CM} {FM} {S} {Pi1}
	forall  {CM-FM: clsmap-fldmap CM FM}
		{CM2PM: clsmap2predmap CM PM}
		{MNS: maynull-set FM S}
		{SRP: set-rawfldperm S ([t] Pi1 t)}
	exists  {Pi2} {I: {t} implies (Pi1 t) (Pi2 t)}
		{SFP: set-fldpred PM FM S ([t] Pi2 t)}
	true.

- : mns-imp-sfp CM-FM CM2PM MNS SRP _ I SFP
     <- set`size-total SZ
     <- mns-imp-sfp/L _ SZ CM-FM CM2PM MNS SRP _ I SFP.

%worlds (objvar) (mns-imp-sfp _ _ _ _ _ _ _).
%total  {} (mns-imp-sfp _ _ _ _ _ _ _).


%%% theorems about set-fldpred

%theorem set-fldpred-imply :
        forall* {PM} {FM} {FP} {S} {F}
        forall  {S-FP: set-fldpred PM FM S ([t] FP t)} {F&S: set-in F S} 
        exists  {C} {NN} {FM-L: fldmap`lookup FM F (nulltp/norm C NN)}
                {W} {FNN2P: fldnn2perm F NN ([p][o] W p o)}
                {P} {PM-L: predmap`lookup PM C P}
                {RP} {TAS: {t} implies (FP t) ((W P t) , (RP t))}
                {S1} {S1-RP: set-fldpred PM FM S1 ([t] RP t)}
                {NM: set-notin F S1} {U: set-unit-union S1 F S} 
        true.

%theorem set-fldpred-imply/L :
        forall* {PM} {FM} {S} {F} {N} 
                {S1} {R} {D1} {P1} {NN1} {W1} 
        forall  {C} {CMP: nat`compare N F C}
                {S1-R: set-fldpred PM FM S1 ([t] R t)}
                {N/S1: set-notin N S1} 
                {S1UN=S: set-unit-union S1 N S}
                {F&S: set-in F S}
                {PM-L: predmap`lookup PM D1 P1}
                {FNN2P: fldnn2perm N NN1 ([p][o] W1 p o)}
                {FM-L: fldmap`lookup FM N (nulltp/norm D1 NN1)}
        exists  {D2} {NN2} {FM-L: fldmap`lookup FM F (nulltp/norm D2 NN2)}
                {W2} {FNN2P: fldnn2perm F NN2 ([p][o] W2 p o)}
                {P2} {PM-L: predmap`lookup PM D2 P2}
                {RP} {IMP: {t} implies ((W1 P1 t) , (R t)) ((W2 P2 t) , (RP t))}
                {S2} {S1-RP: set-fldpred PM FM S2 ([t] RP t)}
                {F/S2: set-notin F S2} {S2UF=S: set-unit-union S2 F S} 
        true.
       
- : set-fldpred-imply/L equal _
     S1-R N/S1 S1UN=S _ PM-L FNN2P FM-L %{=>}%
     _ _ FM-L _ FNN2P _ PM-L _ ([t] implies/reflexive)
     _ S1-R N/S1 S1UN=S.

- : set-fldpred-imply/L less CMP
     S1-R N/S1 S1UN=S F&S PM-L1 FNN2P1 FM-L1 %{=>}%
     _ _ FM-L2 _ FNN2P2 _ PM-L2 _
     ([t] implies/trans
	(implies/combine 
	   (implies/reflexive)
	   (IMP t))
	(implies/equiv equiv/roll2))
     S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 PM-L1 FNN2P1 FM-L1) F/S3 S3UF=S
     <- nat`less-implies-lt CMP F>N
     <- set`ne-implies-unit-map-not-member (nat`ne/< F>N) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-fldpred-imply S1-R F&S1 %{=>}%
	_ _ FM-L2 _ FNN2P2 _ PM-L2 _ ([t] IMP t) _ S2-RP F/S2 S2UF=S1
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-imply/L greater CMP
     S1-R N/S1 S1UN=S F&S PM-L1 FNN2P1 FM-L1 %{=>}%
     _ _ FM-L2 _ FNN2P2 _ PM-L2 _
     ([t] implies/trans
	(implies/combine 
	   (implies/reflexive)
	   (IMP t))
	(implies/equiv equiv/roll2))
     S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 PM-L1 FNN2P1 FM-L1) F/S3 S3UF=S
     <- nat`greater-implies-gt CMP N>F
     <- set`ne-implies-unit-map-not-member (nat`ne/> N>F) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-fldpred-imply S1-R F&S1 %{=>}%
	_ _ FM-L2 _ FNN2P2 _ PM-L2 _ ([t] IMP t) _ S2-RP F/S2 S2UF=S1
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-imply (set-fldpred/+ S1-R N/S1 S1UN=S PM-L1 FNN2P1 FM-L1) F&S %{=>}%
     _ _ FM-L2 _ FNN2P2 _ PM-L2 _ ([t] IMP t) S2 S2-RP F/S2 S2UF=S
     <- nat`compare-total CMP
     <- set-fldpred-imply/L _ CMP S1-R N/S1 S1UN=S F&S PM-L1 FNN2P1 FM-L1 %{=>}%
	_ _ FM-L2 _ FNN2P2 _ PM-L2 _ ([t] IMP t) S2 S2-RP F/S2 S2UF=S.

%worlds () 
(set-fldpred-imply _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(set-fldpred-imply/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (SF1 SF2)
(set-fldpred-imply SF1 _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(set-fldpred-imply/L _ _ SF2 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%%% similar theorem as set-rawfldperm-reorder, except the relation
%%% is between set and sequence of packed field permissions

%theorem set-fldpred-reorder :
        forall* {PM} {FM} {FP} {S} {F}  
        forall  {S-FP: set-fldpred PM FM S ([t] FP t)} {IN: set-in F S}
        exists  {RP} 
                {TAS: {r}{t} transform 
		       (output/expr r (FP t))
		       (output/exists [o] (output/expr r
		       	   ((unitperm (basic t F o)) , (RP t))))}
                {S1} {S1-RP: set-fldpred PM FM S1 ([t] RP t)}
                {NM: set-notin F S1} {U: set-unit-union S1 F S} 
        true.

%theorem set-fldpred-reorder/L :
        forall* {PM} {FM} {S} {F} 
                {S1} {N} {R} {W} {P} {D} {NN} 
        forall  {C} {CMP: nat`compare N F C}
                {S1-R: set-fldpred PM FM S1 ([t] R t)}
                {N/S1: set-notin N S1}
                {U: set-unit-union S1 N S}
                {IN: set-in F S}
                {PM-L: predmap`lookup PM D P}
                {FNN2P: fldnn2perm N NN ([p][o] W p o)}
                {FM-L: fldmap`lookup FM N (nulltp/norm D NN)}
        exists  {RP}
                {TAS: {r}{t} transform
		       (output/expr r ((W P t) , (R t)))
		       (output/exists [o] 
			  (output/expr r ((unitperm (basic t F o)) , (RP t))))}
                {S2} {S2-RP: set-fldpred PM FM S2 ([t] RP t)}
                {F/S2: set-notin F S2} {U: set-unit-union S2 F S}
        true.

- : set-fldpred-reorder/L equal
     _ S1-R N/S1 S1UN=S _ PM-L fldnn2perm/yes _ _ 
     ([r][t] transform/trans3
	(transform/implies
	   (implies/combine 
	      (implies/equiv (equiv/symmetric equiv/one))
	      (implies/reflexive)))
	(transform/skolem)
	(transform/inside [r]
	   (transform/implies
	      (implies/combine
		 (implies/trans
		    (implies/equiv equiv/one)
		    (implies/trans
		       (implies/combine
			  (implies/reflexive)
			  (implies/trans
			     (implies/nonlinear (bimplies/tt))
			     (implies/true2empty)))
		       (implies/equiv equiv/identity)))
		 (implies/reflexive)))))
     _ S1-R N/S1 S1UN=S.

- : set-fldpred-reorder/L equal 
     _ S1-R N/S1 S1UN=S _ _ fldnn2perm/may _ _ 
     ([r][t] transform/trans3
	(transform/implies
	   (implies/combine 
	      (implies/equiv (equiv/symmetric equiv/one))
	      (implies/reflexive)))
	(transform/skolem)
	(transform/inside [r]
	   (transform/implies
	      (implies/combine
		 (implies/trans
		    (implies/equiv equiv/one)
		    (implies/trans
		       (implies/combine
			  (implies/reflexive)
			  (implies/trans
			     (implies/cond-inner
				(bimplies/reflexive)
				(bimplies/reflexive)
				(implies/reflexive)
				(implies/trans
				   (implies/nonlinear bimplies/tt)
				   (implies/true2empty)))
			     (implies/cond-equal)))
		       (implies/equiv equiv/identity)))
		 (implies/reflexive)))))
     _ S1-R N/S1 S1UN=S.

- : set-fldpred-reorder/L less 
     C S1-R N/S1 S1UN=S F&S PM-L FNN2P FM-L _ 
     ([r][t] transform/trans
	(TAS' r t)
	(transform/inside [_] 
	   (transform/implies
	      (implies/equiv equiv/roll2))))
     S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 PM-L (FNN2P:fldnn2perm N NN W) FM-L) F/S3 S3UF=S
     <- nat`less-implies-lt C F>N
     <- set`ne-implies-unit-map-not-member (nat`ne/< F>N) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-fldpred-reorder S1-R F&S1 RP ([r][t] TAS r t) E2 S2-RP F/S2 S2UF=S1
     <- ({r}{t} transform-commutes-envadd*
	   (TAS r t) envadd/expr (envadd/exists [o] envadd/expr) (TAS' r t))
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-reorder/L greater 
     C S1-R N/S1 S1UN=S F&S PM-L FNN2P FM-L _ 
     ([r][t] transform/trans
	(TAS' r t)
	(transform/inside [_] 
	   (transform/implies
	      (implies/equiv equiv/roll2))))
     S3 (set-fldpred/+ S2-RP N/S2 S2UN=S3 PM-L FNN2P FM-L) F/S3 S3UF=S
     <- nat`greater-implies-gt C N>F
     <- set`ne-implies-unit-map-not-member (nat`ne/> N>F) F/N
     <- set`not-member-union-right-preserves-lookup-converse F&S F/N S1UN=S F&S1
     <- set-fldpred-reorder S1-R F&S1 RP ([r][t] TAS r t) _ S2-RP F/S2 S2UF=S1
     <- ({r}{t} transform-commutes-envadd*
	   (TAS r t) envadd/expr (envadd/exists [_] envadd/expr) (TAS' r t))
     <- set`union-preserves-not-member-converse* N/S1 S2UF=S1 N/S2 _
     <- set`union-commutative S2UF=S1 FUS2=S1
     <- set`union-associative FUS2=S1 S1UN=S S3 S2UN=S3 FUS3=S
     <- set`union-commutative FUS3=S S3UF=S
     <- set`union-preserves-not-member* F/S2 F/N S2UN=S3 F/S3.

- : set-fldpred-reorder (set-fldpred/+ S1-R N/S1 S1UN=S PM-L FNN2P FM-L) IN
     RP ([r][t] TAS r t) S2 S2-RP F/S2 S2UF=S
     <- nat`compare-total CMP
     <- set-fldpred-reorder/L _ CMP S1-R N/S1 S1UN=S IN PM-L FNN2P FM-L
	RP ([r][t] TAS r t) S2 S2-RP F/S2 S2UF=S.

%worlds (objvar) 
(set-fldpred-reorder _ _ _ _ _ _ _ _)
(set-fldpred-reorder/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (SF1 SF2)
(set-fldpred-reorder SF1 _ _ _ _ _ _ _)
(set-fldpred-reorder/L _ _ SF2 _ _ _ _ _ _ _ _ _ _ _ _).


%theorem false-implies-implies-var :
        forall* {P1: object -> permission} {P2}
        forall  {V:void}
        exists  {IMP: {o} implies (P1 o) (P2 o)}
        true.

%worlds (objvar) (false-implies-implies-var _ _).
%total  {} (false-implies-implies-var _ _).


%theorem set-fldpred-implies-fldmap2conj/L1 :
        forall* {FM} {S1} {S} {F} {T} {N}
        forall  {SZ: fldmap`size FM (s N)}
                {DM: fldmap`domain FM S}
                {L: fldmap`lookup FM F T}
                {U: set`union S1 (set/+ F set/0) S}
                {FS: set`not-member S1 F}
        exists  {FM1} {SZ: fldmap`size FM1 N} 
                {DM: fldmap`domain FM1 S1}
                {FS: fldmap`fresh FM1 F}
                {U: fldmap`update FM1 F T FM}
        true.

- : set-fldpred-implies-fldmap2conj/L1 SZ-FM DM-FM=S FM-L S1UF=S F/S1 %{=>}%
     FM1 SZ-FM1=N DM-FM1=S1 F/FM1 FM1+F=FM
     <- fldmap`can-remove SZ-FM FM-L %{=>}% FM1 N1 SZ-FM1=N1 SN1=SN FM1+F=FM F/FM1
     <- nat`succ-cancels SN1=SN N1=N
     <- fldmap`size-respects-eq SZ-FM1=N1 fldmap`eq/ N1=N SZ-FM1=N
     <- fldmap`domain-total DM-FM1=S2
     <- fldmap`domain-preserves-fresh F/FM1 DM-FM1=S2 F/S2
     <- fldmap`update-commute-domain FM1+F=FM DM-FM1=S2 DM-FM=S S2+F=S
     <- set`not-member-update-implies-unit-union F/S2 S2+F=S S2UF=S
     <- set`union-implies-leq S1UF=S S1<=S F<=S
     <- set`union-implies-leq S2UF=S S2<=S _
     <- set`not-member-implies-unit-disjoint F/S1 S1XF
     <- set`not-member-implies-unit-disjoint F/S2 S2XF
     <- set`disjoint-symmetric S1XF FXS1
     <- set`disjoint-symmetric S2XF FXS2
     <- set`union-commutative S1UF=S FUS1=S
     <- set`union-commutative S2UF=S FUS2=S
     <- set`leq-reflexive _ S<=S
     <- set`remove-characterization S1<=S FXS1 FUS1=S S<=S S/F=S1
     <- set`remove-characterization S2<=S FXS2 FUS2=S S<=S S/F=S2
     <- set`remove-deterministic S/F=S1 S/F=S2 set`eq/ set`eq/ S1=S2
     <- set`eq-symmetric S1=S2 S2=S1
     <- fldmap`domain-respects-eq DM-FM1=S2 fldmap`eq/ S2=S1 DM-FM1=S1.

%worlds () (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).
%total  {} (set-fldpred-implies-fldmap2conj/L1 _ _ _ _ _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L2 :
        forall* {CM} {PM} {FM} {FM1} {G1} {F} {C} {P} {NN} {W} 
        forall  {F2C: fldmap2conj CM PM FM1 ([o] G1 o) PM}
                {FS: fldmap`fresh FM1 F} 
                {U: fldmap`update FM1 F (nulltp/norm C NN) FM}
                {PM-L: predmap`lookup PM C P} 
		{FNN2P: fldnn2perm F NN ([p][o] W p o)}
        exists  {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
                {IMP: {o} implies 
		       (unitperm
			  (nonlinear
			     (conj (nested (W P o) null own) (G1 o))))
		       (unitperm (nonlinear (G o)))}
        true.

- : set-fldpred-implies-fldmap2conj/L2 
     fldmap2conj/0 fldmap`fresh/0 fldmap`update/0 PM-L FNN2P _
     (fldmap2conj/norm/in fldmap2conj/0 FNN2P fldmap`shift/0 PM-L)
     ([_] implies/reflexive).

- : set-fldpred-implies-fldmap2conj/L2 (fldmap2conj/null F2C-FM3 N<<FM2=FM3)
     F/FM1 (fldmap`update/> FM2+N0=FM4 SN0+N=F) PM-L FNN2P _
     (fldmap2conj/null F2C-FM5 N<<FM4=FM5) ([t] IMP t)
     <- fldmap`shift-total N<<FM4=FM5
     <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
     <- nat`plus-swap-succ SN0+N=F N0+SN=F 
     <- nat`plus-commutative N0+SN=F SN+N0=F
     <- fldmap`shift-preserves-update* FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
     <- set-fldpred-implies-fldmap2conj/L2
	F2C-FM3 F/FM3 FM3+F=FM5 PM-L FNN2P _ F2C-FM5 ([t] IMP t).

- : set-fldpred-implies-fldmap2conj/L2 F2C
     F/FM1 (fldmap`update/< SN3+F=N) PM-L FNN2P _
     (fldmap2conj/norm/in F2C FNN2P (fldmap`shift/+ SF+N3=N) PM-L) ([_] implies/reflexive)
     <- nat`plus-swap-succ SN3+F=N N3+SF=N
     <- nat`plus-commutative N3+SF=N SF+N3=N.

- : set-fldpred-implies-fldmap2conj/L2 
     (fldmap2conj/norm/in F2C-FM3 FNN2P1 N<<FM2=FM3 PM-L1) F/FM1 
     (fldmap`update/> FM2+N0=FM4 SN0+N=F) PM-L2 FNN2P2 _
     (fldmap2conj/norm/in F2C-FM5 FNN2P1 N<<FM4=FM5 PM-L1) 
     ([o] implies/trans5
	(implies/conj2combine)
	(implies/combine
	   (implies/reflexive)
	   (implies/conj2combine))
	(implies/equiv equiv/roll2)
	(implies/combine
	   (implies/reflexive)
	   (implies/trans
	      (implies/combine2conj)
	      (IMP o)))
	(implies/combine2conj))
     <- fldmap`shift-total N<<FM4=FM5
     <- fldmap-shift-preserves-fresh F/FM1 N<<FM2=FM3 F/FM3
     <- nat`plus-swap-succ SN0+N=F N0+SN=F
     <- nat`plus-commutative N0+SN=F SN+N0=F
     <- fldmap`shift-preserves-update*
	FM2+N0=FM4 N<<FM2=FM3 SN+N0=F N<<FM4=FM5 FM3+F=FM5
     <- set-fldpred-implies-fldmap2conj/L2
	F2C-FM3 F/FM3 FM3+F=FM5 PM-L2 FNN2P2 _ F2C-FM5 ([t] IMP t).

%%% impossible cases

%theorem set-fldpred-implies-fldmap2conj/L2L :
        forall* {CM} {PMin} {FM} {PMout}
        forall  {F:void}
        exists  {G} {F2C: fldmap2conj CM PMin FM ([t] G t) PMout}
        true.

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L2L _ _ _).
%total  {} (set-fldpred-implies-fldmap2conj/L2L _ _ _).


- : set-fldpred-implies-fldmap2conj/L2 _ F/FM1 (fldmap`update/= N=F) _ _ _ F2C BIMP
     <- nat`eq-symmetric N=F F=N
     <- fldmap`fresh-respects-eq F/FM1 fldmap`eq/ F=N N/FM1
     <- fldmap`fresh-contradiction N/FM1 V
     <- set-fldpred-implies-fldmap2conj/L2L V G F2C
     <- false-implies-implies-var V ([o] BIMP o).

- : set-fldpred-implies-fldmap2conj/L2 
     (fldmap2conj/norm/out F2C1
	(F2CF:{p:nullpred} fldmap2conj _ _ _ ([o:object] CJ p o) _)
	([p] PM-U p) _ _ _ PM-FS) _ _ _ _ %{=>}% G F2C IMP
     <- ({p} predmap`update-implies-lookup (PM-U p) (PME-L p))
     <- ({p} fldmap2conj-implies-predmap-leq (F2CF p) (PME<=PMF p))
     <- ({p} predmap`lookup-respects-leq (PME-L p) (PME<=PMF p) _ (PMF-L p) _)
     <- fldmap2conj-implies-predmap-leq F2C1 PMF<=PM
     <- predmap`lookup-respects-leq (PMF-L (conj2pred CJ)) PMF<=PM _ PM-L _
     <- predmap`fresh-lookup-not-equal PM-FS PM-L NE
     <- nat`eq-ne-implies-false nat`eq/ NE V
     <- set-fldpred-implies-fldmap2conj/L2L V G F2C
     <- false-implies-implies-var V ([o] IMP o).

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L2 _ _ _ _ _ _ _ _).
%total F2C (set-fldpred-implies-fldmap2conj/L2 F2C _ _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj/L : 
        forall* {CM} {PM} {FM:fldmap} {S} {FP} 
        forall  {N} {SZ: fldmap`size FM N} {DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
        exists  {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
                {TAS: {t} transform 
		       (output/expr t (FP t))
		       (output/expr t (unitperm (nonlinear (G t))))}
        true.

- : set-fldpred-implies-fldmap2conj/L z _ 
     fldmap`domain/0 set-fldpred/0 %{=>}% 
     _ fldmap2conj/0 ([t] transform/implies implies/empty2true).

- : set-fldpred-implies-fldmap2conj/L (s N) SZ DM
     (set-fldpred/+ S1-R F/S1 S1UF=S PM-L FNN2P FM-L) %{=>}% _ F2C 
     ([t] transform/trans
	(TAS1 t)
	(transform/trans
	   (transform/nest)
	   (transform/implies
	      (implies/trans
		 (implies/combine2conj)
		 (IMP t)))))
     <- set-fldpred-implies-fldmap2conj/L1 SZ DM FM-L S1UF=S F/S1 _ SZ1 DM1 F/FM1 FM1+F=FM
     <- set-fldpred-shrink-fldmap S1-R F/S1 FM1+F=FM S1-R1
     <- set-fldpred-implies-fldmap2conj/L N SZ1 DM1 S1-R1 _ F2C1 ([t] TAS t)
     <- set-fldpred-implies-fldmap2conj/L2 F2C1 F/FM1 FM1+F=FM PM-L FNN2P _ F2C IMP
     <- ({t} transform-commutes-envadd* (TAS t) envadd/expr envadd/expr (TAS1 t)).

%worlds (objvar) (set-fldpred-implies-fldmap2conj/L _ _ _ _ _ _ _).
%total  N (set-fldpred-implies-fldmap2conj/L N _ _ _ _ _ _).


%theorem set-fldpred-implies-fldmap2conj : 
        forall* {CM} {PM} {FM} {S} {FP} 
        forall  {CM2PM: clsmap2predmap CM PM}
		{DM: fldmap`domain FM S}
		{SF: set-fldpred PM FM S ([t] FP t)}
        exists  {G} {F2C: fldmap2conj CM PM FM ([t] G t) PM}
                {TAS: {t} transform 
		       (output/expr t (FP t))
		       (output/expr t (unitperm (nonlinear (G t))))}
        true.
       
- : set-fldpred-implies-fldmap2conj _ DM SF G F2C TAS
     <- fldmap`size-total SZ
     <- set-fldpred-implies-fldmap2conj/L _ SZ DM SF G F2C TAS.

%worlds (objvar) (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).
%total  {} (set-fldpred-implies-fldmap2conj _ _ _ _ _ _).


%%% R - bare field permissions
%%% Q - assembled field permissions

%theorem constyping-implies-typing/L :
        forall* {PM} {CM} {MM} {FM} {E} {W}
                {S} {S1} {S2} {L} {Pi} {R0} {Q0}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S1 L ([t] E t)}
                {NNS: nonnull-set FM S1}
                {S/S1=S2: set`remove S S1 S2}
                {S1US2=S: set`union S1 S2 S}
                {S-E: set-expr S E}
		{S1-R0: set-rawfldperm S1 R0}			
                {S2-Q0: set-fldpred PM FM S2 Q0}
        exists  {Q1} 
                {TYP: {t} typing W ((R0 t) , ((Q0 t) , Pi)) (E t) 
		       (output/expr t ((Q1 t) , Pi))}
                {S-Q1: set-fldpred PM FM S Q1}
        true.

%theorem constyping-implies-typing/LMB :
        forall* {PM} {CM} {MM} {FM} {E} {W} {B} {C} {NN}
                {S} {S1} {S2} {L} {Pi} {R0} {Q0} {F} {S3}
        forall  {G} {MB?: set`member? S1 F G}
                {RM: set-unit-remove S1 F S3}
                {F&S: set`member S F}
                {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S3 L ([t] B t)}
                {NTYP: nullTyping CM MM L E (result/expr (nulltp/norm C NN))}
                {FM-L: fldmap`lookup FM F (nulltp/norm C NN)}
                {NNS1: nonnull-set FM S1}
                {S/S1=S2: set`remove S S1 S2}
                {S1US2=S: set`union S1 S2 S}
                {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}			
                {S2-Q0: set-fldpred PM FM S2 Q0}
        exists  {Q1} 
                {TYP: {t} typing W ((R0 t) , ((Q0 t) , Pi))
		       ((seq (write (lit t) F E) (B t)))
		       (output/expr t ((Q1 t) , Pi))}
                {S-Q1: set-fldpred PM FM S Q1}
        true.

%theorem constyping-implies-typing/LL :
        forall* {PM} {CM} {MM} {FM} {E} {W} {B} {F} {S3}
                {S} {S1} {S2} {L} {Pi} {R0} {Q0} {C} {NN}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S3 L ([t] B t)}
		{NTYP: nullTyping CM MM L E (result/expr (nulltp/norm C NN))}
                {FM-L: fldmap`lookup FM F (nulltp/norm C NN)}
                {NNS1: nonnull-set FM S1}
                {F&S1: set-in F S1}
                {RM: set-unit-remove S1 F S3}
                {S/S1=S2: set`remove S S1 S2}
                {S1US2=S: set`union S1 S2 S}
                {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}			
                {S2-Q0: set-fldpred PM FM S2 Q0}
        exists  {Q1} 
                {TYP: {t} typing W ((R0 t) , ((Q0 t) , Pi)) 
		       (seq (write (lit t) F E) (B t)) 
		       (output/expr t ((Q1 t) , Pi))}
                {S-Q1: set-fldpred PM FM S Q1}
        true.

%theorem constyping-implies-typing/LR :
        forall* {PM} {CM} {MM} {FM} {E} {W} {B} {F}
                {S} {S1} {S2} {L} {Pi} {R0} {Q0} {C} {NN}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-OFL: clsmap-oflist CM L}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {OFL2P: oflist2perm PM L Pi}
                {CTYP: constyping CM MM FM S1 L ([t] B t)}
		{NTYP: nullTyping CM MM L E (result/expr (nulltp/norm C NN))}			 
                {FM-L: fldmap`lookup FM F (nulltp/norm C NN)}
                {NNS: nonnull-set FM S1}
                {F&S2: set-in F S2}
                {S/S1=S2: set`remove S S1 S2}
                {S1US2=S: set`union S1 S2 S}
                {S-B: set-expr S B}
		{S1-R0: set-rawfldperm S1 R0}			
                {S2-Q0: set-fldpred PM FM S2 Q0}
        exists  {Q1} 
                {TYP: {t} typing W ((R0 t) , ((Q0 t) , Pi)) 
		       (seq (write (lit t) F E) (B t)) 
		       (output/expr t ((Q1 t) , Pi))}
                {S-Q1: set-fldpred PM FM S Q1}
        true.

- : constyping-implies-typing/L 
     _ _ _ _ _ _ constyping/0 _ _ _
     set-expr/0 set-rawfldperm/0 S-Q _ 
     ([_] tTrans2
	(tObjLoc)
	(transform/implies
	   (implies/equiv
	      (equiv/transitive
		 (equiv/commute) 
		 (equiv/identity))))) S-Q.

- : constyping-implies-typing/L 
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P (constyping/mn CTYP MNTYP FM-L)
     NNS1 S/S1=S2 S1US2=S (set-expr/+ S-B F&S) S1-R0 S2-Q0 Q1 TYP S-Q1
     <- only-nonnull-in-nonnull-set NNS1 FM-L F/S1
     <- set`not-member-union-left-preserves-lookup-converse F/S1 F&S S1US2=S F&S2
     <- constyping-implies-typing/LR 
	CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP MNTYP FM-L 
	NNS1 F&S2 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1.

- : constyping-implies-typing/L 
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P (constyping/nn CTYP NTYP S1/F=S3 FM-L)
     NNS1 S/S1=S2 S1US2=S (set-expr/+ S-B F&S) S1-R0 S2-Q0 Q1 TYP S-Q1
     <- set`member?-total MB?
     <- constyping-implies-typing/LMB _ MB? S1/F=S3 
	F&S CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P
	CTYP NTYP FM-L NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1.

- : constyping-implies-typing/LR
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P 
     CTYP NTYP FM-L NNS F&S2 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 _ 
     ([t] tTrans2
	(tLet
	   (tWrite2
	      (tTrans
		 (transform/implies
		    (implies/equiv equiv/associate))
		 (letTyping/base null (TYPE' t))
		 (transform/inside [r]
		    (transform/trans3
		       (transform/implies
			  (implies/trans2
			     (implies/combine
				(implies/equiv equiv/commute)
				(implies/reflexive))
			     (implies/equiv
				(equiv/transitive
				   (equiv/symmetric equiv/associate)
				   (equiv/commute)))))
		       (TRANS' r t)
		       (transform/inside [o]
			  (transform/implies
			     (implies/equiv
				(equiv/transitive
				   (equiv/commute)
				   (equiv/symmetric equiv/associate))))))))
	      (letTyping/exists [r]
		 (letTyping/exists [o]
		    (letTyping/base r
		       (tTrans2
			  (tWrite:typing _ _ (write (lit t) _ (lit r)) _)
			  (transform/implies
			     (implies/trans5
				(implies/combine
				   (implies/reflexive)
				   (implies/equiv equiv/roll3))
				(implies/equiv equiv/associate)
				(implies/combine
				   (IMP r t)
				   (implies/reflexive))
				(implies/equiv equiv/associate)
				(implies/equiv equiv/roll2))))))))
	   (letTyping/exists [r]
	      (letTyping/exists [o]
		 (letTyping/base r (TYPB t)))))
	(transform/trans
	   (transform/rem-unused)
	   (transform/rem-unused)))
     S-Q1
     <- set-fldpred-reorder S2-Q0 F&S2 RP ([r][t] TRANS r t) S3 S3-RP F/S3 S3UF=S2
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP
	_ (nulltp2perm/norm PM-L NN2P) TYPE
     <- nn2perm-implies-fldnn2perm NN2P PM-L _ FNN2P ([r][t] IMP r t)
     <- ({t} typing-frame* TYPE (envadd/exists ([r] envadd/expr)) (TYPE' t))
     <- constyping-implies-typing/L CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP
	NNS S/S1=S2 S1US2=S S-B S1-R0
	(set-fldpred/+ S3-RP F/S3 S3UF=S2 PM-L FNN2P FM-L) _ TYPB S-Q1
     <- ({r}{t} transform-commutes-envadd*
	   (TRANS r t) envadd/expr (envadd/exists [_] envadd/expr) (TRANS' r t)).

- : constyping-implies-typing/LL
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP NTYP FM-L
     NNS1 F&S1 S1/F=S3' S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 _ 
     ([t] tTrans2
	(tLet 
	   (tWrite2
	      (tTrans
		 (transform/implies
		    (implies/equiv equiv/associate))
		 (letTyping/base null (TYPE' t))
		 (transform/inside [r]
		    (transform/implies
		       (implies/trans3
			  (implies/equiv 
			     (equiv/symmetric equiv/associate))
			  (implies/combine
			     (IMP t) (implies/reflexive))
			  (implies/equiv 
			     (equiv/symmetric equiv/associate))))))
	      (letTyping/exists [r]
		 (letTyping/base r
		    (tTrans2
		       (tWrite:typing _ _ (write (lit t) _ (lit r)) _)
		       (transform/implies
			  (implies/trans5
			     (implies/combine
				(implies/reflexive)
				(implies/equiv equiv/roll3))
			     (implies/equiv equiv/associate)
			     (implies/combine
				(IMP2 r t)
				(implies/reflexive))
			     (implies/equiv equiv/roll2)
			     (implies/combine
				(implies/reflexive)
				(implies/equiv equiv/associate))))))))
	   (letTyping/exists [r]
	      (letTyping/base r (TYPB t))))
	(transform/rem-unused)) S-Q1
     <- set-rawfldperm-reorder S1-R0 F&S1 RP ([t] IMP t) S3 S3-RP F/S3 S3UF=S1
     <- convert/expr-ok CM2PM CM-CM CM-MM CM-OFL MM2W OFL2P NTYP 
	_ (nulltp2perm/norm PM-L NNTP) TYPE
     <- nn2perm-implies-fldnn2perm NNTP PM-L _ FNN2P ([r][t] IMP2 r t)
     <- ({t} typing-frame* TYPE (envadd/exists ([r] envadd/expr)) (TYPE' t))
     <- set`remove-implies-disjoint S/S1=S2 S1^S2
     <- set`disjoint-lookup-implies-not-member F&S1 S1^S2 F/S2
     <- set`union-associative S3UF=S1 S1US2=S S4 FUS2=S4 S3US4=S
     <- set`union-commutative FUS2=S4 S2UF=S4
     <- set`union-commutative S3UF=S1 FUS3=S1
     <- set`union-implies-leq S1US2=S S1<=S S2<=S
     <- set`union-implies-leq S3UF=S1 S3<=S1 F<=S1
     <- set`union-implies-leq S2UF=S4 S2<=S4 F<=S4
     <- set`leq-transitive F<=S1 S1<=S F<=S
     <- set`union-is-lub S2UF=S4 S2<=S F<=S S4<=S
     <- set`not-member-implies-unit-disjoint F/S3 S3^F
     <- set`leq-reflexive _ S2<=S2
     <- set`disjoint-respects-geq S1^S2 S3<=S1 S2<=S2 S3^S2
     <- set`disjoint-symmetric S3^F F^S3
     <- set`disjoint-symmetric S3^S2 S2^S3
     <- set`union-preserves-disjoint* F^S3 S2^S3 FUS2=S4 S4^S3
     <- set`disjoint-symmetric S4^S3 S3^S4
     <- set`leq-reflexive _ S<=S
     <- set`leq-reflexive _ S1<=S1
     <- set`remove-characterization S4<=S S3^S4 S3US4=S S<=S S/S3=S4
     <- set`remove-characterization S3<=S1 F^S3 FUS3=S1 S1<=S1 S1/F=S3
     <- set`remove-deterministic S1/F=S3' S1/F=S3 set`eq/ set`eq/ S3'=S3
     <- constyping-respects-eq CTYP S3'=S3 CTYP'
     <- remove-preserves-nonnull-set NNS1 S1/F=S3 NNS3
     <- constyping-implies-typing/L CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP'
	NNS3 S/S3=S4 S3US4=S S-B S3-RP 
	(set-fldpred/+ S2-Q0 F/S2 S2UF=S4 PM-L FNN2P FM-L) _ TYPB S-Q1.

- : constyping-implies-typing/LMB false OUT S1/F=S3 F&S 
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP NTYP FM-L
     NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1
     <- set`out-implies-not-member OUT F/S1
     <- set`not-member-implies-unit-disjoint F/S1 S1^F
     <- set`disjoint-implies-remove-nothing S1^F S1/F=S1
     <- set`remove-deterministic S1/F=S3 S1/F=S1 set`eq/ set`eq/ S3=S1
     <- constyping-respects-eq CTYP S3=S1 CTYP'
     <- set`not-member-union-left-preserves-lookup-converse F/S1 F&S S1US2=S F&S2
     <- constyping-implies-typing/LR 
	CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP' NTYP FM-L 
	NNS1 F&S2 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1.

- : constyping-implies-typing/LMB true IN S1/F=S3 _
     CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP NTYP FM-L 
     NNS1 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1
     <- set`in-implies-member IN _ F&S1
     <- constyping-implies-typing/LL
	CM-CM CM-MM CM-OFL CM2PM MM2W OFL2P CTYP NTYP FM-L 
	NNS1 F&S1 S1/F=S3 S/S1=S2 S1US2=S S-B S1-R0 S2-Q0 Q1 TYP S-Q1.

%worlds (objvar) 
(constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LMB _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LL _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
(constyping-implies-typing/LR _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).

%total (T2 T3 T4 T1)
(constyping-implies-typing/L _ _ _ _ _ _ _ _ _ _ T1 _ _ _ _ _)
(constyping-implies-typing/LR _ _ _ _ _ _ _ _ _ _ _ _ _ T3 _ _ _ _ _)
(constyping-implies-typing/LL _ _ _ _ _ _ _ _ _ _ _ _ _ _ T4 _ _ _ _ _)
(constyping-implies-typing/LMB _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ T2 _ _ _ _ _).


%theorem constyping-implies-set-expr :
        forall* {CM} {MM} {FM} {S} {R} {L} {E}
        forall  {CTYP: constyping CM MM FM R L ([t] E t)}
                {DM: fldmap`domain FM S}
        exists  {S-E: set-expr S E}
        true.

- : constyping-implies-set-expr constyping/0 _ set-expr/0.

- : constyping-implies-set-expr
     (constyping/nn CTYP _ R/F=R1 FM#F) FM->S (set-expr/+ S-B S#F)
     <- constyping-implies-set-expr CTYP FM->S S-B 
     <- fldmap`domain-preserves-lookup FM#F FM->S S#F.

- : constyping-implies-set-expr
     (constyping/mn CTYP NTYP FM#F) FM->S (set-expr/+ S-B S#F)
     <- constyping-implies-set-expr CTYP FM->S S-B
     <- fldmap`domain-preserves-lookup FM#F FM->S S#F.

%worlds (objvar) (constyping-implies-set-expr _ _ _).
%total  (T) (constyping-implies-set-expr T _ _).


%theorem allocfields-total/L :
	forall* {S}
	forall  {N} {SZ: set`size S N} 
	exists  {Pi} {AF: {t} allocFields t S (Pi t)}
	true.

- : allocfields-total/L z _ _ ([t] allocFields/0).

- : allocfields-total/L (s N) (set`size/+ SZ) _ ([t] (allocFields/+ SH (AF t)))
     <- set`shift-total SH
     <- set`shift-preserves-size SZ SH SZP
     <- allocfields-total/L N SZP _ ([t] AF t).

%worlds (objvar) (allocfields-total/L _ _ _ _).
%total  (N) (allocfields-total/L N _ _ _).


%theorem allocfields-total :
	forall* {S} 
	exists  {Pi} {AF: {t} allocFields t S (Pi t)}
	true.

- : allocfields-total Pi ([t] AF t)
     <- set`size-total SZ
     <- allocfields-total/L _ SZ Pi ([t] AF t).

%worlds (objvar) (allocfields-total _ _).
%total  {} (allocfields-total _ _).


%theorem fldmap2conj-format/L :
	forall* {CM} {PM} {FM} 
	forall  {V: void}
	exists  {CJ} {F2C: fldmap2conj CM PM FM ([t] CJ (conj2pred CJ) t) PM}
	true.

%worlds (objvar | predvar) (fldmap2conj-format/L _ _ _).
%total  {} (fldmap2conj-format/L _ _ _).


%theorem fldmap2conj-format :
	forall* {CM} {PM} {FM} {G}
	forall  {F2C: fldmap2conj CM PM FM ([t] G t) PM}
	exists  {CJ} {F2C: fldmap2conj CM PM FM ([t] CJ (conj2pred CJ) t) PM}
	true.

- : fldmap2conj-format fldmap2conj/0 ([_][_] t) fldmap2conj/0.

- : fldmap2conj-format (fldmap2conj/null F2C SH) CJ (fldmap2conj/null F2CP SH)
     <- fldmap2conj-format F2C CJ F2CP.

- : fldmap2conj-format
     (fldmap2conj/norm/in F2C
	(FNN2P:fldnn2perm _ _ W) SH (PML:predmap`lookup _ _ P)) 
     ([_][o] conj (nested (W P o) null own) (CJ (conj2pred CJ) o))
	(fldmap2conj/norm/in F2CP FNN2P SH PML) 
     <- fldmap2conj-format F2C CJ F2CP.

%%% this case is not possible
- : fldmap2conj-format 
     (fldmap2conj/norm/out F2C (F2CF:{f} fldmap2conj _ _ _ ([o] CJ f o) _)
	([f] PM-UD f) FNN2P SH CML PM-FS) CJ2 F2Cout
     <- ({f} predmap`update-implies-lookup (PM-UD f) (PM1L f))
     <- ({f} fldmap2conj-implies-predmap-leq (F2CF f) (PM1<=PM2 f))
     <- fldmap2conj-implies-predmap-leq F2C PM2<=PM
     <- predmap`leq-transitive (PM1<=PM2 (conj2pred CJ)) PM2<=PM PM1<=PM
     <- predmap`lookup-respects-leq (PM1L (conj2pred CJ)) PM1<=PM _ PMLP D=DP
     <- nullpred`eq-symmetric D=DP DP=D
     <- predmap`lookup-respects-eq PMLP predmap`eq/ nat`eq/ DP=D PML
     <- predmap`fresh-lookup-not-equal PM-FS PML NE
     <- nat`eq-ne-implies-false nat`eq/ NE V
     <- fldmap2conj-format/L V CJ2 F2Cout.

%worlds (objvar | predvar) (fldmap2conj-format _ _ _).
%total  (CJ) (fldmap2conj-format CJ _ _).
     

%theorem fldmap2conj-implies-predmap-lookup :
	forall* {PM} {CM} {FM} {CJ} {C}
	forall  {CM2PM: clsmap2predmap CM PM}
		{CML: clsmap`lookup CM C FM}
		{F2C: fldmap2conj CM PM FM ([t] CJ (conj2pred CJ) t) PM}
	exists  {PML: predmap`lookup PM C (conj2pred CJ)}
	true.

%worlds (objvar) (fldmap2conj-implies-predmap-lookup _ _ _ _).
%trustme %total  {} (fldmap2conj-implies-predmap-lookup _ _ _ _).


%theorem constyping-implies-typing/L2 :
	forall* {G1:object -> formula} {G2} {P} {Q}
	forall  {E: {o} permission`eq (G1 o) (G2 o)}
		{T: {o} transform (output/expr o (P o))
			 (output/expr o (unitperm (nonlinear (G1 o))))}
	exists  {T: {o} transform (output/expr o ((P o) , Q))
			 (output/expr o (unitperm (nonlinear (G2 o)) , Q))}
	true.

- : constyping-implies-typing/L2 ([_] permission`eq/) T1
     ([o] transform/trans3
	(transform/implies (implies/equiv equiv/commute))
	(T2 o)
	(transform/implies (implies/equiv equiv/commute)))
     <- ({o} transform-commutes-envadd* (T1 o) envadd/expr envadd/expr (T2 o)).

%worlds (objvar) (constyping-implies-typing/L2 _ _ _).
%total  {} (constyping-implies-typing/L2 _ _ _).


%theorem constyping-implies-typing :
	forall* {PM} {CM} {MM} {FM} {L} {C} {W}
		{PP} {S} {S1} {E}
	forall  {CM-CM: clsmap-clsmap CM CM}
		{CM-MM: clsmap-methmap CM MM}
		{CM-L: clsmap-oflist CM L}
		{CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}
		{L2P: oflist2perm PM L PP}
		{CML: clsmap`lookup CM C FM}
		{FM-DM: fldmap`domain FM S}
		{FM=>S: filt-nnflds FM S1}
		{CTYP: constyping CM MM FM S1 L ([t] E t)}
	exists  {RFP} {AF: {t} allocFields t S (RFP t)}
		{PF} {T2P: nulltp2perm PM (nulltp/norm C nn/yes) PF}
	        {TYP: {t} typing W ((RFP t) , PP) (E t)
		       (output/exists ([t] (output/expr t (PP , (PF t)))))}
	true.

- : constyping-implies-typing CM-CM CM-MM CM-L CM2PM MM2W L2P
     CML DM-FM=S FM=>S1 CTYP %{=>}% _ ([t] AF t) _
     (nulltp2perm/norm PML nn2perm/yes)
     ([t] tTrans
	(transform/implies
	   (implies/trans
	      (implies/combine
		 (implies/trans3
		    (PP=>P t)
		    (P=>P1P2 t)
		    (implies/combine
		       (implies/reflexive) 
		       (R2=>P2 t)))
		 (implies/reflexive))
	      (implies/equiv (equiv/symmetric equiv/associate))))
	(letTyping/base null (TYP t))
	(transform/trans3
	   (TRANS3 t)
	   (transform/implies
	      (implies/trans2
		 (implies/combine
		    (implies/nonlinear
		       (bimplies/trans
			  (bimplies/predcall/0/extract)
			  (bimplies/trans
			     (bimplies/predcall/+/extract _ _)
			     (bimplies/predcall/Y/extract))))
		    (implies/reflexive))
		 (implies/equiv equiv/commute)))
	   (transform/gen-exists t)))
     <- allocfields-total _ ([t] AF t)
     <- lookup-implies-clsmap-fldmap CM-CM CML CM-FM
     <- filt-nnflds-implies-leq DM-FM=S FM=>S1 S1<=S
     <- set`remove-total S/S1=S2
     <- set`remove-subset-implies-union S/S1=S2 S1<=S S1US2=S
     <- filt-nnflds-implies-nonnull-set FM=>S1 NN-S1
     <- constyping-implies-set-expr CTYP DM-FM=S S-E
     <- allocfields-implies-set-rawfldperm DM-FM=S ([t] AF t) _ ([t] PP=>P t) S-P
     <- rm-psv-sfp S-P S1<=S S/S1=S2 _ _ ([t] P=>P1P2 t) S1-P1 S2-R2
     <- fnn-rm-imp-mns CM2PM CM-FM DM-FM=S FM=>S1 S/S1=S2 MN-S2
     <- mns-imp-sfp CM-FM CM2PM MN-S2 S2-R2 _ ([t] R2=>P2 t) S2-P2
     <- constyping-implies-typing/L CM-CM CM-MM CM-L CM2PM MM2W L2P CTYP 
	NN-S1 S/S1=S2 S1US2=S S-E S1-P1 S2-P2 _ TYP S-Q
     <- set-fldpred-implies-fldmap2conj CM2PM DM-FM=S S-Q _ F2C ([t] TRANS t)
     <- fldmap2conj-format F2C CJ F2C2
     <- fldmap2conj-deterministic* F2C F2C2 clsmap`eq/ fldmap`eq/ predmap`eq/ G=CJ
     <- constyping-implies-typing/L2 G=CJ TRANS TRANS3
     <- fldmap2conj-implies-predmap-lookup 
	CM2PM CML F2C2 (PML:predmap`lookup _ _ (conj2pred CJ))
     <- writeshared-can-move-front L2P _ EQV.

%worlds (objvar) (constyping-implies-typing _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  {} (constyping-implies-typing _ _ _ _ _ _ _ _ _ _ _ _ _ _ _).


%theorem constpmatch-implies-proctypematch :
        forall* {CM} {MM} {PM} {FM} {CTF} {W} {F} {L} 
		{Pi} {Pi2} {S} 
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
		{CM-CT: {t} clsmap-methtp CM (CTF t)}
                {CM2PM: clsmap2predmap CM PM}
		{CM-L: clsmap-oflist CM L}			       
		{MM2W: methmap2progtype PM CM MM W}			      
                {L2P: oflist2perm PM L Pi}
		{EQV: equiv Pi (sharedPerm , Pi2)}
                {FNN: filt-nnflds FM S}
                {MC: constypematch* CM MM FM S L F CTF}
        exists  {PTF} {CT2PT: constp2proctype* PM FM Pi2 CTF PTF}
                {PC: {t} proctypematch W (F t) (PTF t)}
        true.                

- : constpmatch-implies-proctypematch
     CM-CM CM-MM _ CM2PM CM-L MM2W L2P EQV FNN (constypematch*/base CTYP CML) 
     _ (constp2proctype*/base T2P ([t] AF t) FM-DM) 
     ([t] proctypematch/base
	(tTrans
	   (transform/implies
	      (implies/trans3
		 (implies/equiv equiv/associate)
		 (implies/combine
		    (implies/equiv (equiv/symmetric EQV))
		    (implies/reflexive))
		 (implies/equiv equiv/commute)))
	   (letTyping/base null (TYPE t))
	   (transform/inside
	      ([t] 
		 (transform/trans
		    (transform/implies
			     (implies/trans
				(implies/combine
				   (implies/trans
				      (implies/equiv EQV)
				      (implies/equiv equiv/commute))
				   (implies/reflexive))
				(implies/equiv (equiv/symmetric equiv/associate))))
		    (transform/drop))))))
     <- fldmap`domain-total FM-DM
     <- constyping-implies-typing CM-CM CM-MM CM-L CM2PM MM2W L2P CML
	FM-DM FNN CTYP _ ([t] AF t) _ T2P ([t] TYPE t).

- : constpmatch-implies-proctypematch
     CM-CM CM-MM ([t] clsmap-methtp/arg ([o] CM-CT t o) CM-T)
     CM2PM CM-L MM2W L2P EQV FNN (constypematch*/args ([o] MC o)) 
     ([t] proctype/arg ([o] PTF t o))  (constp2proctype*/arg ([o] CT2PT o) T2P) 
     ([t] (proctypematch/arg ([o] PC t o)))
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T ZZZ T2P
     <- ({o} constpmatch-implies-proctypematch 
	   CM-CM CM-MM ([t] CM-CT t o)
	   CM2PM (clsmap-oflist/+ CM-T CM-L) MM2W (oflist2perm/+ T2P L2P)
	   (equiv/transitive
	      (equiv/combine equiv/reflexive EQV)
	      (equiv/roll2))
	   FNN (MC o) ([t] PTF t o) (CT2PT o) ([t] PC t o)).

%worlds (objvar) (constpmatch-implies-proctypematch _ _ _ _ _ _ _ _ _ _ _ _ _).
%total  (M) (constpmatch-implies-proctypematch _ _ M _ _ _ _ _ _ _ _ _ _).


	
%%% theorems about methmapmatch-progtypematch

%%% some lemmas

%theorem shift-preserves-progtypematch :
        forall* {W} {W1} {W2} {G1} {G2} {N}
        forall  {PM: progtypematch* W W1 G1}
                {SH: progtype`shift N W1 W2}
                {SH: prog`shift N G1 G2}
        exists  {PM: progtypematch* W W2 G2}
        true.

- : shift-preserves-progtypematch PM progtype`shift/0 prog`shift/0 PM.

- : shift-preserves-progtypematch (progtypematch/+ PM PTM) _ _ (progtypematch/+ PM PTM).

%worlds () (shift-preserves-progtypematch _ _ _ _).
%total  {} (shift-preserves-progtypematch _ _ _ _).
                

%theorem shift-preserves-progtypematch-converse :
        forall* {W} {W1} {W2} {G1} {G2} {N}
        forall  {PM: progtypematch* W W2 G2}
		{SH: progtype`shift N W1 W2} 
                {SH: prog`shift N G1 G2}
        exists  {PM: progtypematch* W W1 G1}
        true.

- : shift-preserves-progtypematch-converse PM progtype`shift/0 prog`shift/0 PM.

%worlds () (shift-preserves-progtypematch-converse _ _ _ _).
%trustme %total PM (shift-preserves-progtypematch-converse PM _ _ _).


%theorem methmap2progtype-preserves-fresh :
        forall* {PM} {CM} {MM} {W} {N}
        forall  {MM2W: methmap2progtype PM CM MM W}
                {FS: methmap`fresh MM N}
        exists  {FS: progtype`fresh W N}
        true.

- : methmap2progtype-preserves-fresh 
     methmap2progtype/0 methmap`fresh/0 progtype`fresh/0.

- : methmap2progtype-preserves-fresh 
     (methmap2progtype/c _ _ _ _ _)
     (methmap`fresh/< M>N) (progtype`fresh/< M>N).

- : methmap2progtype-preserves-fresh 
     (methmap2progtype/m _ _ _ _ _)
     (methmap`fresh/< M>N) (progtype`fresh/< M>N).

- : methmap2progtype-preserves-fresh 
     (methmap2progtype/c M<<W=WP M<<MM=MMP MMP=>WP _ _)
     (methmap`fresh/> M1/M P) (progtype`fresh/> M/W P)
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-fresh M1/M P2 _ M<<MM=MMP1 M/MMP1
     <- methmap`shift-deterministic
	M<<MM=MMP1 M<<MM=MMP nat`eq/ methmap`eq/ MMP1=MMP
     <- methmap`fresh-respects-eq M/MMP1 MMP1=MMP nat`eq/ M/MMP
     <- methmap2progtype-preserves-fresh MMP=>WP M/MMP M/WP
     <- progtype`shift-preserves-fresh-converse* M/WP M<<W=WP P2 M/W.

- : methmap2progtype-preserves-fresh 
     (methmap2progtype/m M<<W=WP M<<MM=MMP MMP=>WP _ _)
     (methmap`fresh/> M1/M P) (progtype`fresh/> M/W P)
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-fresh M1/M P2 _ M<<MM=MMP1 M/MMP1
     <- methmap`shift-deterministic
	M<<MM=MMP1 M<<MM=MMP nat`eq/ methmap`eq/ MMP1=MMP
     <- methmap`fresh-respects-eq M/MMP1 MMP1=MMP nat`eq/ M/MMP
     <- methmap2progtype-preserves-fresh MMP=>WP M/MMP M/WP
     <- progtype`shift-preserves-fresh-converse* M/WP M<<W=WP P2 M/W.

%worlds () (methmap2progtype-preserves-fresh _ _ _).
%total  (MW) (methmap2progtype-preserves-fresh MW _ _).


%%% same lemma as fldmap-fresh-update-implies-shift 

%theorem progtype-fresh-update-implies-shift :
        forall* {M1} {M2} {F} {T}
        forall  {FS: progtype`fresh M2 F}
                {UD: progtype`update M2 F T (progtype`map/+ F T M1)}
        exists  {SH: progtype`shift F M1 M2}
        true.

- : progtype-fresh-update-implies-shift 
     progtype`fresh/0 progtype`update/0 progtype`shift/0.

%%% imaging M2 <=> (map/+ N T M3)
- : progtype-fresh-update-implies-shift
     (progtype`fresh/< N>F) (progtype`update/< SN3+F=N) (progtype`shift/+ SF+N3=N)
     <- nat`plus-swap-succ SN3+F=N N3+SF=N
     <- nat`plus-commutative N3+SF=N SF+N3=N.

%%% impossible cases

- : progtype-fresh-update-implies-shift F/M2 (progtype`update/= N=F) SH
     <- nat`eq-symmetric N=F F=N
     <- progtype`fresh-respects-eq F/M2 progtype`eq/ F=N N/M2
     <- progtype`fresh-contradiction N/M2 V
     <- progtype`false-implies-shift V SH.

- : progtype-fresh-update-implies-shift 
     (progtype`fresh/> _ SN3+N=F) (progtype`update/< SN3+F=N) SH
     <- nat`plus-implies-gt SN3+N=F nat`eq/ F>N
     <- nat`plus-implies-gt SN3+F=N nat`eq/ N>F
     <- nat`gt-anti-symmetric F>N N>F V
     <- progtype`false-implies-shift V SH.

- : progtype-fresh-update-implies-shift
     F/M2 (progtype`update/> N3/M3 SN3+N=F) SH
     <- nat`plus-implies-gt SN3+N=F nat`eq/ F>N
     <- nat`eq-ne-implies-false nat`eq/ (nat`ne/< F>N) V
     <- progtype`false-implies-shift V SH.

%worlds () (progtype-fresh-update-implies-shift _ _ _).
%total  UD (progtype-fresh-update-implies-shift UD _ _).


%theorem methmapmatch-respects-eq :
        forall* {CM1} {CM2} {MMX1} {MMX2} {MM1} {MM2} {G1} {G2}
        forall  {MM1-G1: methmapmatch* CM1 MMX1 MM1 G1}
                {E: clsmap`eq CM1 CM2} {E: methmap`eq MMX1 MMX2}
                {E: methmap`eq MM1 MM2} {E: prog`eq G1 G2}
        exists  {MM2-G2: methmapmatch* CM2 MMX2 MM2 G2}
        true.

- : methmapmatch-respects-eq MM-G clsmap`eq/ methmap`eq/ methmap`eq/ prog`eq/ MM-G.

%worlds () (methmapmatch-respects-eq _ _ _ _ _ _).
%total  {} (methmapmatch-respects-eq _ _ _ _ _ _).


%theorem false-implies-progtypematch :
        forall* {WX} {W} {G}
        forall  {F:void}
        exists  {WTH: progtypematch* WX W G}
        true.

%worlds () (false-implies-progtypematch _ _).
%total  {} (false-implies-progtypematch _ _).


%%% this is the ultimate thing!

%theorem methmapmatch-implies-progtypematch :
        forall* {CM} {MM:methmap} {MM} {PM} {W} {G}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM2PM: clsmap2predmap CM PM}
                {MM2W: methmap2progtype PM CM MM W}
                {MTH: methmapmatch CM MM G}
        exists  {WTH: progtypematch W G}
        true.

%theorem methmapmatch-implies-progtypematch/L :
        forall* {CM} {MM1} {MM} {PM} {W1} {W} {G1}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MM1: clsmap-methmap CM MM1}
                {CM=>PM: clsmap2predmap CM PM}
		{MM=>W: methmap2progtype PM CM MM W}				 
                {MM1=>W1: methmap2progtype PM CM MM1 W1}
                {MM1-G1: methmapmatch* CM MM MM1 G1}
        exists  {W-G: progtypematch* W W1 G1}
	true.					 

- : methmapmatch-implies-progtypematch/L _ _ _ _ _ _ methmapmatch*/0 progtypematch/0.

- : {YY1} {N1:nat} {YY2:methtp} {YY3} {YY4:map} {YY5:proctype} {YY6}
      {YY7} {YY8:term funck} {YY9} {CM-CM:clsmap-clsmap YY1 YY1}
      {CM-MM:clsmap-methmap YY1 YY3} {CM-MT:clsmap-methtp YY1 YY2}
      {CM=>PM:clsmap2predmap* YY1 map/0 YY1 YY4}
      {MM=>W:methmap2progtype YY4 YY1 YY3 YY7} {YY10} {YY11}
      {N<<W=WP:progtype`shift N1 YY6 YY10} {N<<MM=MMP:methmap`shift N1 YY3 YY11}
      {MMP=>WP:methmap2progtype YY4 YY1 YY11 YY10}
      {MT=>PT:methtp2proctype* YY4 empty YY2 YY5} {YY12:clsmap`fresh YY1 N1} {YY13}
      {YY14} {MMP1-GP:methmapmatch* YY1 YY3 YY13 YY14}
      {N<<G=GP:prog`shift N1 YY9 YY14} {N<<MM=MMP1:methmap`shift N1 YY3 YY13}
      {FUN-MT:methtpmatch* YY1 YY3 oflist/0 YY8 YY2} {YY15:clsmap`fresh YY1 N1}
      {YY16:progtypematch* YY7 (progtype`map/+ N1 YY5 YY6) (prog`map/+ N1 YY8 YY9)}
     {MMP1=MMP} {MMP-GP} {CM-MMP} {WP-GP} {W-G} {MT=>PT1} {FUN-PT1} {PT1=PT} {FUN-PT} 
      methmapmatch-implies-progtypematch/L CM-CM CM-MM
         (clsmap-methmap/+ CM-MM CM-MT) CM=>PM MM=>W
         (methmap2progtype/m N<<W=WP N<<MM=MMP MMP=>WP MT=>PT YY12)
         (methmapmatch*/+/meth MMP1-GP N<<G=GP N<<MM=MMP1 FUN-MT YY15) YY16
     <- methmap`shift-deterministic N<<MM=MMP1 N<<MM=MMP nat`eq/ methmap`eq/ MMP1=MMP
     <- methmapmatch-respects-eq MMP1-GP clsmap`eq/ methmap`eq/ MMP1=MMP prog`eq/ MMP-GP
     <- shift-preserves-clsmap-methmap CM-MM N<<MM=MMP CM-MMP
     <- methmapmatch-implies-progtypematch/L 
	CM-CM CM-MM CM-MMP CM=>PM MM=>W MMP=>WP MMP-GP WP-GP
     <- shift-preserves-progtypematch-converse WP-GP N<<W=WP N<<G=GP W-G
     <- methtpmatch-implies-proctypematch
	CM-CM CM-MM CM-MT CM=>PM MM=>W FUN-MT _ MT=>PT1 FUN-PT1
     <- methtp2proctype-deterministic MT=>PT1 MT=>PT predmap`eq/ methtp`eq/ PT1=PT
     <- proctypematch-respects-eq FUN-PT1 progtype`eq/ term`eq/ PT1=PT FUN-PT.

     %{(progtypematch/+ W-G FUN-PT)}%
- : methmapmatch-implies-progtypematch/L CM-CM CM-MM
     (clsmap-methmap/+ CM-MM CM-MT) CM=>PM MM=>W
     (methmap2progtype/m N<<W=WP N<<MM=MMP MMP=>WP MT=>PT YY12)
     (methmapmatch*/+/meth MMP1-GP N<<G=GP N<<MM=MMP1 FUN-MT YY15) 
     (progtypematch/+ W-G FUN-PT)
     <- methmap`shift-deterministic N<<MM=MMP1 N<<MM=MMP nat`eq/ methmap`eq/ MMP1=MMP
     <- methmapmatch-respects-eq MMP1-GP clsmap`eq/ methmap`eq/ MMP1=MMP prog`eq/ MMP-GP
     <- shift-preserves-clsmap-methmap CM-MM N<<MM=MMP CM-MMP
     <- methmapmatch-implies-progtypematch/L 
	CM-CM CM-MM CM-MMP CM=>PM MM=>W MMP=>WP MMP-GP WP-GP
     <- shift-preserves-progtypematch-converse WP-GP N<<W=WP N<<G=GP W-G
     <- methtpmatch-implies-proctypematch
	CM-CM CM-MM CM-MT CM=>PM MM=>W FUN-MT _ MT=>PT1 FUN-PT1
     <- methtp2proctype-deterministic MT=>PT1 MT=>PT predmap`eq/ methtp`eq/ PT1=PT
     <- proctypematch-respects-eq FUN-PT1 progtype`eq/ term`eq/ PT1=PT FUN-PT.

%%% the impossible cases
- : methmapmatch-implies-progtypematch/L _ _ _ _ _
     (methmap2progtype/c _ _ _ _ CM-L) 
     (methmapmatch*/+/meth _ _ _ _ CM-FS) PTMH
     <- clsmap`fresh-lookup-not-equal CM-FS CM-L NE
     <- nat`eq-ne-implies-false nat`eq/ NE V
     <- false-implies-progtypematch V PTMH.

%%% proof for this case seems not to be necessary
- : methmapmatch-implies-progtypematch/L _ _ _ _ _
     (methmap2progtype/m _ _ _ _ CM-FS)
     (methmapmatch*/+/const _ _ _ _ _ CM-L) PTMH
     <- clsmap`fresh-lookup-not-equal CM-FS CM-L NE
     <- nat`eq-ne-implies-false nat`eq/ NE V
     <- false-implies-progtypematch V PTMH.

%worlds () (methmapmatch-implies-progtypematch/L _ _ _ _ _ _ _ _).
%total  (MW) (methmapmatch-implies-progtypematch/L _ _ _ _ _ MW _ _).



%theorem methtpmatch-implies-proctypematch :
        forall* {CM} {MM} {PM} {MT} {W} {F}
        forall  {CM-CM: clsmap-clsmap CM CM}
                {CM-MM: clsmap-methmap CM MM}
                {CM-MT: clsmap-methtp CM MT}
                {CM2PM: clsmap2predmap CM PM}
		{MM2W: methmap2progtype PM CM MM W}			      
                {MC: methtpmatch CM MM F MT}
        exists  {PT} {MT2PT: methtp2proctype PM MT PT}
                {PC: proctypematch W F PT}
        true.                




