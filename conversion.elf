%%%%% conversion.elf
%%%%% Conversion from nonnull type to permission type
%%%%% $Id: conversion.elf,v 1.16 2011/02/13 23:33:51 csun Exp csun $

nn2perm : nn -> (nullpred -> object -> permission) -> type.

nn2perm/yes
   : nn2perm nn/yes
      ([p][o] 
	 (unitperm 
	    (nonlinear 
	       (conj (neg (objequal o null))
		  (predcall p (predargs/1 o)))))).

nn2perm/may
   : nn2perm nn/may
      ([p][o] 
	 (unitperm
	    (conditional (objequal o null)
	       empty 
	       (unitperm (nonlinear (predcall p (predargs/1 o))))))).
			

fldmap2perm : fldmap -> (object -> permission) -> type.

fldmap2perm/0 : fldmap2perm fldmap`map/0 ([o] empty).

fldmap2perm/+ 
   : fldmap2perm (fldmap`map/+ F _ FM) 
      ([o] (unitperm (basic o F null)) , (Pi o))
      <- fldmap`shift F FM FM'
      <- fldmap2perm FM' Pi.


nulltp2perm : predmap -> nulltp -> (object -> permission) -> type.

nulltp2perm/null
   : nulltp2perm _ nulltp/null ([r] unitperm (nonlinear (objequal r null))).

nulltp2perm/norm
   : nulltp2perm PM (nulltp/norm C NN) ([o] (PF PD o))
      <- nn2perm NN PF
      <- predmap`lookup PM C PD.

methtp2proctype* : predmap -> permission -> methtp -> proctype -> type.

%abbrev methtp2proctype = [PM][MT][PT] methtp2proctype* PM empty MT PT.

methtp2proctype*/base 
   : methtp2proctype* PM Pi (methtp/base T) 
      (proctype/base (sharedPerm , Pi)
	 (output/exists ([ret] (output/expr ret (sharedPerm , (PF ret))))))
      <- nulltp2perm PM T PF.

methtp2proctype*/arg
   : methtp2proctype* PM Pi (methtp/arg MTF T) (proctype/arg PTF)
      <- nulltp2perm PM T PF
      <- ({o} methtp2proctype* PM ((PF o) , Pi) (MTF o) (PTF o)).


%abbrev obj-ne-null
   : object -> permission =
	([r] (unitperm (nonlinear (neg (objequal r (object/ z)))))).		     
	       
constp2proctype* : predmap -> fldmap -> permission ->
	(object -> methtp) -> (object -> proctype) -> type.

% constp2proctype/ 
%    : constp2proctype PM FM ([t] MTF t) ([t] PTF t)
%       <- fldmap`domain FM S
%       <- ({t} allocFields t S (OS t))
%       <- ({t} methtp2proctype* PM (OS t) (MTF t) (PTF t)).

%abbrev constp2proctype 
   = [PM][FM][CTF][PTF] constp2proctype* PM FM empty CTF PTF.
	
constp2proctype*/base 
   : constp2proctype* PM FM Pi ([t] methtp/base T)
      ([t] proctype/base
	 (sharedPerm , (Pi , ((obj-ne-null t) , (OS t))))
	 (output/exists ([ret] (output/expr ret (sharedPerm , (PF ret))))))
      <- fldmap`domain FM S
      <- ({t} allocFields t S (OS t)) 
      <- nulltp2perm PM T PF.

constp2proctype*/arg 
   : constp2proctype* PM FM Pi ([t] methtp/arg (CTF t) T) ([t] proctype/arg (PTF t))
      <- nulltp2perm PM T PF
      <- ({o} constp2proctype* PM FM ((PF o) , Pi) ([t] CTF t o) ([t] PTF t o)).


%%% convert a methmap to a progtype 

methmap2progtype : predmap -> clsmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap`map/0 progtype`map/0.

methmap2progtype/c 
   : methmap2progtype PM CM 
      (methmap`map/+ N (methtp/arg CTF (nulltp/norm N nn/yes)) MM)
      (progtype`map/+ N (proctype/arg PTF) W)
      <- clsmap`lookup CM N FM
      <- constp2proctype PM FM CTF PTF
      <- methmap2progtype PM CM MMP WP
      <- methmap`shift N MM MMP
      <- progtype`shift N W WP.

methmap2progtype/m 
   : methmap2progtype PM CM
      (methmap`map/+ N MT MM) (progtype`map/+ N PT W)
      <- clsmap`fresh CM N
      <- methtp2proctype PM MT PT
      <- methmap2progtype PM CM MMP WP
      <- methmap`shift N MM MMP
      <- progtype`shift N W WP.


oflist2perm : predmap -> oflist -> permission -> type.

oflist2perm/0 : oflist2perm _ oflist/0 sharedPerm.

oflist2perm/+ 
   : oflist2perm PM (oflist/+ O T L) ((PF O) , Pi)
      <- oflist2perm PM L Pi
      <- nulltp2perm PM T PF.


perm-output : predmap -> permission -> result K -> output K -> type.

perm-output/exists* 
   : {Out: gterm objectk -> output condk} 
      perm-output PM Pi Rslt (output/exists ([v] Out v))
      <- ({v:object} perm-output PM Pi Rslt (Out v)).
		   
%abbrev perm-output/exists = [PO] perm-output/exists* _ PO.

perm-output/expr
   : perm-output PM Pi (result/expr T) 
      (output/exists ([v] (output/expr v ((PF v) , Pi))))
      <- nulltp2perm PM T PF.

perm-output/cond : perm-output _ Pi result/cond (output/cond _ Pi Pi).
	    
perm-output/args/0
   : perm-output PM Pi result/args/0 (output/args/0 Pi).

perm-output/args/+ 
   : perm-output PM Pi  (result/args/+ T Rslt)
      (output/exists ([v] (output/args/+ v (Out v))))
      <- nulltp2perm PM T PF
      <- ({o} perm-output PM ((PF o) , Pi) Rslt (Out o)).



%%% basic theorems

%%% theorems about equality


%theorem allocFields-respects-eq :
        forall* {S1} {S2} {OS1} {OS2}
        forall  {AF: {t} allocFields t S1 (OS1 t)}
                {EQ: set`eq S1 S2}
                {EQ: {t} permission`eq (OS1 t) (OS2 t)}
        exists  {AF: {t} allocFields t S2 (OS2 t)}
        true.

- : allocFields-respects-eq ([t] AF t) set`eq/ ([_] permission`eq/) ([t] AF t).

%worlds (objvar) (allocFields-respects-eq _ _ _ _).
%total  {} (allocFields-respects-eq _ _ _ _).


%%% theorems about nn2perm

%theorem false-implies-nn2perm :
	forall* {NN} {PF}
	forall  {F:void}
	exists  {NN2P: nn2perm NN ([o] PF o)}
	true.

%worlds () (false-implies-nn2perm _ _).
%total  {} (false-implies-nn2perm _ _).


% %theorem nn2perm-deterministic :
%         forall* {NN} {PF} {PD1} {PD2}
%         forall  {NN2P: nn2perm NN PF}
%                 {EQ: nullpred`eq PD1 PD2}
%         exists  {EQ: {o} permission`eq (PF PD1 o) (PF PD2 o)}
%         true.

% - : nn2perm-deterministic _ nullpred`eq/ ([_] permission`eq/).

% %worlds (objvar) (nn2perm-deterministic _ _ _).
% %total  {} (nn2perm-deterministic _ _ _).



%theorem nn2perm-deterministic :
        forall* {NN1} {NN2} {FF1} {FF2}
        forall  {NN2P1: nn2perm NN1 FF1}
                {NN2P2: nn2perm NN2 FF2}
                {NNEQ: nn`eq NN1 NN2}
        exists  {EQ: {p}{o} permission`eq (FF1 p o) (FF2 p o)}
        true.

- : nn2perm-deterministic nn2perm/yes nn2perm/yes _ ([_][_] permission`eq/).
- : nn2perm-deterministic nn2perm/may nn2perm/may _ ([_][_] permission`eq/).

%worlds (objvar) (nn2perm-deterministic _ _ _ _).
%total  {} (nn2perm-deterministic _ _ _ _).


%theorem nn2perm-total :
        forall {NN}
        exists {PF} {NN2P: nn2perm NN PF}
        true.

- : nn2perm-total nn/may _ nn2perm/may.
- : nn2perm-total nn/yes _ nn2perm/yes.

%worlds (objvar) (nn2perm-total _ _ _).
%total  {} (nn2perm-total _ _ _).


%theorem clsmap-nulltp-implies-nulltp2perm :
	forall* {CM} {PM} {T}
	forall  {CM2PM: clsmap2predmap CM PM}
		{CM-T: clsmap-nulltp CM T}
	exists  {PF} {T2P: nulltp2perm PM T PF}
	true.					 

- : clsmap-nulltp-implies-nulltp2perm _ clsmap-nulltp/null _ nulltp2perm/null.

- : clsmap-nulltp-implies-nulltp2perm 
     CM2PM (clsmap-nulltp/norm (clsmap`domain?/in CM-LP)) 
     _ (nulltp2perm/norm PM-LP NN2P)
     <- nn2perm-total _ _ NN2P
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP.

%worlds (objvar) (clsmap-nulltp-implies-nulltp2perm _ _ _ _).
%total  {} (clsmap-nulltp-implies-nulltp2perm _ _ _ _).


%theorem oflist2perm-total :
        forall* {PM} {CM} {OFL} 
        forall  {CM2PM: clsmap2predmap CM PM}
                {CM-OFL: clsmap-oflist CM OFL}
        exists  {Pi} {OFL2P: oflist2perm PM OFL Pi}
        true.

- : oflist2perm-total CM2PM CM-OFL _ oflist2perm/0.

- : oflist2perm-total CM2PM (clsmap-oflist/+ CM-T CM-OFL) _ (oflist2perm/+ T2P OFL2P) 
     <- clsmap-nulltp-implies-nulltp2perm CM2PM CM-T _ T2P
     <- oflist2perm-total CM2PM CM-OFL _ OFL2P.

%worlds (objvar) (oflist2perm-total _ _ _ _).
%total CO (oflist2perm-total _ CO _ _).


%%% theorems about nulltp2perm

%theorem nulltp2perm-respects-eq :
        forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
        forall  {T2P1: nulltp2perm PM1 T1 PF1}
                {MEQ: predmap`eq PM1 PM2}
                {TEQ: nulltp`eq T1 T2}
                {FEQ: {o} permission`eq (PF1 o) (PF2 o)}
        exists  {T2P2: nulltp2perm PM2 T2 PF2}
        true.

- : nulltp2perm-respects-eq T2P predmap`eq/ nulltp`eq/ ([_] permission`eq/) T2P.

%worlds (objvar) (nulltp2perm-respects-eq _ _ _ _ _).
%total  {} (nulltp2perm-respects-eq _ _ _ _ _).


%theorem nulltp2perm-deterministic/L :
        forall* {PF1: nullpred -> object -> permission} {PF2} {PD1} {PD2} 
        forall  {FEQ: {p}{o} permission`eq (PF1 p o) (PF2 p o)}
                {PEQ: predicate`eq PD1 PD2}
        exists  {PEQ: {o} permission`eq (PF1 PD1 o) (PF2 PD2 o)}
        true.

- : nulltp2perm-deterministic/L
     ([_][_] permission`eq/) predicate`eq/ ([_] permission`eq/).

%worlds (objvar) (nulltp2perm-deterministic/L _ _ _).
%total  {} (nulltp2perm-deterministic/L _ _ _).


%theorem nulltp2perm-deterministic :
        forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
        forall  {T2P1: nulltp2perm PM1 T1 PF1}
                {T2P2: nulltp2perm PM2 T2 PF2}
                {MEQ: predmap`eq PM1 PM2}
                {TEQ: nulltp`eq T1 T2}
	exists  {PEQ: {o} permission`eq (PF1 o) (PF2 o)}
        true.
			      
- : nulltp2perm-deterministic
     nulltp2perm/null nulltp2perm/null _ _ ([_] permission`eq/).

- : nulltp2perm-deterministic
     (nulltp2perm/norm PM-L1 NN2P1)
     (nulltp2perm/norm PM-L2 NN2P2)
     predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- predmap`lookup-deterministic
	PM-L1 PM-L2 predmap`eq/ nat`eq/ EQ
     <- nn2perm-deterministic NN2P1 NN2P2 nn`eq/ FFEQ
     <- nulltp2perm-deterministic/L
	([p][o] FFEQ p o) EQ ([o] PFEQ o).

%worlds (objvar) (nulltp2perm-deterministic _ _ _ _ _).
%total  {} (nulltp2perm-deterministic _ _ _ _ _).


%%% theorem about methmap2progtype

%theorem false-implies-methtp2proctype :
        forall* {PM} {MT}
        forall  {F: void}
        exists  {PT} {MT2PT: methtp2proctype PM MT PT}
        true.

%worlds (objvar) (false-implies-methtp2proctype _ _ _).
%total  {} (false-implies-methtp2proctype _ _ _).


%theorem false-implies-constp2proctype :
	forall* {PM} {CTF} {FM}
        forall  {F: void}
        exists  {PTF} {CT2PT: constp2proctype PM FM CTF PTF}
        true.
				
%worlds (objvar) (false-implies-constp2proctype _ _ _).
%total  {} (false-implies-constp2proctype _ _ _).
  

%theorem methtp2proctype-respects-eq* :
        forall* {PM1} {PM2} {Pi1} {Pi2} {MT1} {MT2} {PT1} {PT2}
        forall  {MT2PT: methtp2proctype* PM1 Pi1 MT1 PT1}
                {MEQ: predmap`eq PM1 PM2}
                {PEQ: permission`eq Pi1 Pi2}
                {MTEQ: methtp`eq MT1 MT2}
                {PTEQ: proctype`eq PT1 PT2}
        exists  {MT2PT: methtp2proctype* PM2 Pi2 MT2 PT2}
        true.

- : methtp2proctype-respects-eq* 
     M2P predmap`eq/ permission`eq/ methtp`eq/ proctype`eq/ M2P.

%worlds (objvar) (methtp2proctype-respects-eq* _ _ _ _ _ _).
%total  {} (methtp2proctype-respects-eq* _ _ _ _ _ _).


%theorem constp2proctype-respects-eq* :
        forall* {PM1} {PM2} {FM1} {FM2} {Pi1} {Pi2} {MTF1} {MTF2} 
		{PTF1} {PTF2}
        forall  {CT2PT: constp2proctype* PM1 FM1 Pi1 ([t] MTF1 t) ([t] PTF1 t)}
                {MEQ: predmap`eq PM1 PM2} {MEQ: fldmap`eq FM1 FM2}
                {PEQ: permission`eq Pi1 Pi2}
                {MTEQ: {t} methtp`eq (MTF1 t) (MTF2 t)}
                {PTEQ: {t} proctype`eq (PTF1 t) (PTF2 t)}
        exists  {CT2PT: constp2proctype* PM2 FM2 Pi2 ([t] MTF2 t) ([t] PTF2 t)}
        true.

- : constp2proctype-respects-eq* C2P predmap`eq/ fldmap`eq/
     permission`eq/ ([_] methtp`eq/) ([_] proctype`eq/) C2P.

%worlds (objvar) (constp2proctype-respects-eq* _ _ _ _ _ _ _).
%total  {} (constp2proctype-respects-eq* _ _ _ _ _ _ _).


%theorem constp2proctype-respects-eq :
        forall* {PM1} {PM2} {FM1} {FM2} {MTF1} {MTF2} {PTF1} {PTF2}
        forall  {CT2PT: constp2proctype PM1 FM1 ([t] MTF1 t) ([t] PTF1 t)}
                {MEQ: predmap`eq PM1 PM2} {MEQ: fldmap`eq FM1 FM2}
                {MTEQ: {t} methtp`eq (MTF1 t) (MTF2 t)}
                {PTEQ: {t} proctype`eq (PTF1 t) (PTF2 t)}
        exists  {CT2PT: constp2proctype PM2 FM2 ([t] MTF2 t) ([t] PTF2 t)}
        true.

- : constp2proctype-respects-eq C2P predmap`eq/ fldmap`eq/
     ([_] methtp`eq/) ([_] proctype`eq/) C2P.

%worlds () (constp2proctype-respects-eq _ _ _ _ _ _).
%total  {} (constp2proctype-respects-eq _ _ _ _ _ _).


%theorem methtp2proctype-respects-eq :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2}
        forall  {MT2PT: methtp2proctype PM1 MT1 PT1}
		{MEQ: predmap`eq PM1 PM2}
		{MTEQ: methtp`eq MT1 MT2}
		{PTEQ: proctype`eq PT1 PT2}
	exists  {MT2PT: methtp2proctype PM2 MT2 PT2}
	true.				

- : methtp2proctype-respects-eq M2P predmap`eq/ methtp`eq/ proctype`eq/ M2P.

%worlds () (methtp2proctype-respects-eq _ _ _ _ _).
%total  {} (methtp2proctype-respects-eq _ _ _ _ _).


%theorem constp2proctype-respects-eq :
	forall* {PM1} {PM2} {FM1} {FM2} 
                {CTF1} {CTF2} {PTF1} {PTF2}
        forall  {C2P: constp2proctype PM1 FM1 CTF1 PTF1}
                {E: predmap`eq PM1 PM2}
                {E: fldmap`eq FM1 FM2}
                {E: {o} methtp`eq (CTF1 o) (CTF2 o)}
                {E: proctype`eq (proctype/arg PTF1) (proctype/arg PTF2)}
        exists  {C2P: constp2proctype PM2 FM2 CTF2 PTF2}
        true.

- : constp2proctype-respects-eq 
     C2P predmap`eq/ fldmap`eq/ ([_] methtp`eq/) proctype`eq/ C2P.
     
%worlds (objvar) (constp2proctype-respects-eq _ _ _ _ _ _).
%total  {} (constp2proctype-respects-eq _ _ _ _ _ _).


%theorem proctype/base-preserves-eq :
        forall* {Pi1} {Pi2} {Out1} {Out2}
        forall  {EQ: permission`eq Pi1 Pi2}
                {EQ: environment`eq Out1 Out2}
        exists  {EQ: proctype`eq
		      (proctype/base Pi1 Out1) 
		      (proctype/base Pi2 Out2)}
        true.
        
- : proctype/base-preserves-eq permission`eq/ environment`eq/ proctype`eq/.

%worlds (objvar) (proctype/base-preserves-eq _ _ _).
%total  {} (proctype/base-preserves-eq _ _ _).


%theorem proctype/arg-preserves-eq :
        forall* {PTF1} {PTF2}
        forall  {EQ: {o} proctype`eq (PTF1 o) (PTF2 o)}
        exists  {EQ: proctype`eq (proctype/arg PTF1) (proctype/arg PTF2)}
        true.

- : proctype/arg-preserves-eq ([_] proctype`eq/)  proctype`eq/.

%worlds (objvar) (proctype/arg-preserves-eq _ _).
%total  {} (proctype/arg-preserves-eq _ _).


%theorem combine-preserves-eq :
        forall* {Pi1} {Pi2} {Pi3} {Pi4}
        forall  {E1: permission`eq Pi1 Pi2}
                {E2: permission`eq Pi3 Pi4}
        exists  {E3: permission`eq (Pi1 , Pi3) (Pi2 , Pi4)}
        true.

- : combine-preserves-eq permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (combine-preserves-eq _ _ _).
%total  {} (combine-preserves-eq _ _ _).


%theorem methtp2proctype-deterministic/L :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2} {Pi1} {Pi2}
        forall  {MT2PT: methtp2proctype* PM1 Pi1 MT1 PT1}
                {MT2PT: methtp2proctype* PM2 Pi2 MT2 PT2}
                {EQ: predmap`eq PM1 PM2}
                {EQ: permission`eq Pi1 Pi2}
                {EQ: methtp`eq MT1 MT2}
        exists  {EQ: proctype`eq PT1 PT2}
        true.

- : methtp2proctype-deterministic/L
     (methtp2proctype*/base T2P1) (methtp2proctype*/base T2P2) 
     PMEQ permission`eq/ MTEQ PTEQ
     <- base-eq-implies-nulltp-eq MTEQ TEQ
     <- nulltp2perm-deterministic T2P1 T2P2 PMEQ TEQ ([o] PFEQ o)
     <- ({o} combine-preserves-eq permission`eq/ (PFEQ o) (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- envadd-deterministic/exists OEQ OEQ'
     <- proctype/base-preserves-eq permission`eq/ OEQ' PTEQ.
     
- : methtp2proctype-deterministic/L
     (methtp2proctype*/arg ([o] MT2PT1 o) T2P1)
     (methtp2proctype*/arg ([o] MT2PT2 o) T2P2)
     PMEQ PiEQ MTEQ PTEQ
     <- arg-eq-implies-nulltp-eq MTEQ ([o] MTFEQ o) TEQ
     <- nulltp2perm-deterministic T2P1 T2P2 PMEQ TEQ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) PiEQ (PiEQ' o))
     <- ({o} methtp2proctype-deterministic/L 
	   (MT2PT1 o) (MT2PT2 o) PMEQ (PiEQ' o) (MTFEQ o) (PTFEQ o))
     <- proctype/arg-preserves-eq PTFEQ PTEQ.

%worlds (objvar) (methtp2proctype-deterministic/L _ _ _ _ _ _).
%total  MT2PT (methtp2proctype-deterministic/L MT2PT _ _ _ _ _).


%theorem methtp2proctype-deterministic :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2} 
        forall  {MT2PT: methtp2proctype PM1 MT1 PT1}
                {MT2PT: methtp2proctype PM2 MT2 PT2}
                {EQ: predmap`eq PM1 PM2}
                {EQ: methtp`eq MT1 MT2}
        exists  {EQ: proctype`eq PT1 PT2}
        true.

- : methtp2proctype-deterministic MT2PT1 MT2PT2 PMEQ MTEQ PTEQ
     <- methtp2proctype-deterministic/L MT2PT1 MT2PT2 PMEQ permission`eq/ MTEQ PTEQ.

%worlds (objvar) (methtp2proctype-deterministic _ _ _ _ _).
%total  {} (methtp2proctype-deterministic _ _ _ _ _).


%theorem methmap2progtype-implies-methtp2proctype :
	forall* {PM} {CM} {MM} {W} {M} {MT} 
	forall  {MM2W: methmap2progtype PM CM MM W}
                {CM-FS: clsmap`fresh CM M}			      
		{MM-LP: methmap`lookup MM M MT}
	exists  {PT} {W-LP: progtype`lookup W M PT}
		{MT2PT: methtp2proctype PM MT PT}			      
	true.

- : methmap2progtype-implies-methtp2proctype
     (methmap2progtype/m _ _ _ CT2PT _) _
     (methmap`lookup/= N=C) _ (progtype`lookup/= N=C) CT2PT.

- : methmap2progtype-implies-methtp2proctype
     (methmap2progtype/m N<<W=WP N<<MM=MMP MMP=>WP _ _) CML
     (methmap`lookup/> MML P) _ (progtype`lookup/> WL P) CT2PT
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P2 MMPL
     <- methmap2progtype-implies-methtp2proctype MMP=>WP CML MMPL _ WPL CT2PT
     <- progtype`shift-preserves-lookup-converse* WPL N<<W=WP P2 WL.

- : methmap2progtype-implies-methtp2proctype	
     (methmap2progtype/c N<<W=WP N<<MM=MMP MMP=>WP _ _) CML
     (methmap`lookup/> MML P) _ (progtype`lookup/> WL P) CT2PT
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P2 MMPL
     <- methmap2progtype-implies-methtp2proctype MMP=>WP CML MMPL _ WPL CT2PT
     <- progtype`shift-preserves-lookup-converse* WPL N<<W=WP P2 WL.

%%% impossible case
- : methmap2progtype-implies-methtp2proctype
     (methmap2progtype/c _ _ _ _ CML) CMFS
     (methmap`lookup/= N=C) _ WL MT2PT
     <- clsmap`fresh-lookup-not-equal CMFS CML C!=N
     <- nat`ne-symmetric C!=N N!=C
     <- nat`eq-ne-implies-false N=C N!=C F
     <- false-implies-methtp2proctype F _ MT2PT
     <- progtype`false-implies-lookup F WL.

%worlds (objvar) (methmap2progtype-implies-methtp2proctype _ _ _ _ _ _).
%total  (MM2W) (methmap2progtype-implies-methtp2proctype MM2W _ _ _ _ _).


%theorem methmap2progtype-implies-constp2proctype :
	forall* {PM} {CM} {MM} {W} {C} {CTF} {FM} {T}
	forall  {MM2W: methmap2progtype PM CM MM W}
                {CML: clsmap`lookup CM C FM}			      
		{MML: methmap`lookup MM C (methtp/arg CTF T)}
	exists  {PTF} {WL: progtype`lookup W C (proctype/arg PTF)}
		{MT2PT: constp2proctype PM FM ([o] CTF o) ([o] PTF o)}
 	true.

- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/c _ _ _ CT2PT CML) CML1
     (methmap`lookup/= N=C) _ (progtype`lookup/= N=C) CT2PT1
     <- clsmap`lookup-deterministic CML CML1 clsmap`eq/ N=C FM=FM1
     <- constp2proctype-respects-eq CT2PT predmap`eq/ 
	FM=FM1 ([_] methtp`eq/) proctype`eq/ CT2PT1.

- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/m N<<W=WP N<<MM=MMP MMP=>WP _ _) CML
     (methmap`lookup/> MML P) _ (progtype`lookup/> WL P) CT2PT
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P2 MMPL
     <- methmap2progtype-implies-constp2proctype MMP=>WP CML MMPL _ WPL CT2PT
     <- progtype`shift-preserves-lookup-converse* WPL N<<W=WP P2 WL.

- : methmap2progtype-implies-constp2proctype	
     (methmap2progtype/c N<<W=WP N<<MM=MMP MMP=>WP _ _) CML
     (methmap`lookup/> MML P) _ (progtype`lookup/> WL P) CT2PT
     <- nat`plus-swap-succ P P1
     <- nat`plus-commutative P1 P2
     <- methmap`shift-preserves-lookup* MML N<<MM=MMP P2 MMPL
     <- methmap2progtype-implies-constp2proctype MMP=>WP CML MMPL _ WPL CT2PT
     <- progtype`shift-preserves-lookup-converse* WPL N<<W=WP P2 WL.

%%% impossible case
- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/m _ _ _ _ CMFS) CML
     (methmap`lookup/= N=C) _ WL CT2PT
     <- clsmap`fresh-lookup-not-equal CMFS CML C!=N
     <- nat`ne-symmetric C!=N N!=C
     <- nat`eq-ne-implies-false N=C N!=C F
     <- false-implies-constp2proctype F _ CT2PT
     <- progtype`false-implies-lookup F WL.

%worlds (objvar) (methmap2progtype-implies-constp2proctype _ _ _ _ _ _).
%total  (MM2W) (methmap2progtype-implies-constp2proctype MM2W _ _ _ _ _).
