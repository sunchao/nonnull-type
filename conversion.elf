%%%%% conversion.elf
%%%%% Conversion from nonnull type to permission type
%%%%% $Id: conversion.elf,v 1.12 2010/10/21 03:11:16 csun Exp csun $

%abbrev null-perm = [o] unitperm 
	(conditional (objequal o null) empty (unitperm (nonlinear f))).	     

nn2perm : nn -> (nullpred -> object -> permission) -> type.

nn2perm/yes : nn2perm nn/yes
	([p][o] 
	   (unitperm 
	      (nonlinear 
		 (conj (neg (objequal o null))
		    (conj (nestInShared o) 
		       (predcall p (predargs/1 o))))))).

nn2perm/may : nn2perm nn/may
	([p][o] unitperm (conditional (objequal o null)
		empty 
		(unitperm (nonlinear 
			(conj (nestInShared o) (predcall p (predargs/1 o))))))).
     

fldmap2perm : fldmap -> (object -> permission) -> type.

% fldmap2perm/0 
%    : fldmap2perm fldmap`map/0 ([o] (unitperm (basic o all null))).

fldmap2perm/0 : fldmap2perm fldmap`map/0 ([o] empty).

fldmap2perm/+ 
   : fldmap2perm (fldmap`map/+ F _ FM) 
      ([o] (unitperm (basic o F null)) , (Pi o))
      <- fldmap`shift F FM FM'
      <- fldmap2perm FM' Pi.


nulltp2perm : predmap -> nulltp -> (object -> permission) -> type.

nulltp2perm/null
   : nulltp2perm _ nulltp/null ([r] unitperm (nonlinear (objequal r null))).

nulltp2perm/norm
   : nulltp2perm PM (nulltp/norm C NN) ([o] (PF PD o))
      <- nn2perm NN PF
      <- predmap`lookup PM C PD.

methtp2proctype* : predmap -> permission -> methtp -> proctype -> type.

%abbrev methtp2proctype = [PM][MT][PT] methtp2proctype* PM empty MT PT.

methtp2proctype*/base 
   : methtp2proctype* PM Pi (methtp/base T) 
      (proctype/base (sharedPerm , Pi)
	 (output/exists ([ret] (output/expr ret (sharedPerm , (PF ret))))))
      <- nulltp2perm PM T PF.

methtp2proctype*/arg
   : methtp2proctype* PM Pi (methtp/arg MTF T) (proctype/arg PTF)
      <- nulltp2perm PM T PF
      <- ({o} methtp2proctype* PM ((PF o) , Pi) (MTF o) (PTF o)).


constp2proctype : predmap -> fldmap -> 
	(object -> methtp) -> (object -> proctype) -> type.

constp2proctype/ 
   : constp2proctype PM FM ([t] MTF t) ([t] PTF t)
      <- fldmap`domain FM S
      <- ({t} allocFields t S (OS t))
      <- ({t} methtp2proctype* PM (OS t) (MTF t) (PTF t)).


% %abbrev constp2proctype 
%    = [PM][FM][CTF][PTF] constp2proctype* PM FM empty CTF PTF.
	
% constp2proctype*/base 
%    : constp2proctype* PM FM Pi ([t] methtp/base T)
%       ([t] proctype/base (sharedPerm , (Pi , (F t)))
% 	 (output/exists ([ret] (output/expr ret (sharedPerm , (PF ret))))))
%       <- fldmap2perm FM F
%       <- nulltp2perm PM T PF.

% constp2proctype*/arg 
%    : constp2proctype* 
%       PM FM Pi ([t] methtp/arg (CTF t) T) ([t] proctype/arg (PTF t))
%       <- nulltp2perm PM T PF
%       <- ({o} constp2proctype* PM FM (Pi , (PF o)) ([t] CTF t o) ([t] PTF t o)).


%%% convert a methmap to a progtype 

methmap2progtype : predmap -> clsmap -> methmap -> progtype -> type.

methmap2progtype/0 : methmap2progtype _ _ methmap`map/0 progtype`map/0.

methmap2progtype/c 
   : methmap2progtype PM CM 
      (methmap`map/+ N (methtp/arg CTF _) MM) W'
      <- clsmap`lookup CM N FM
      <- constp2proctype PM FM CTF PTF
      <- methmap`shift N MM MM'
      <- methmap2progtype PM CM MM' W
      <- progtype`update W N (proctype/arg PTF) W'.

methmap2progtype/m 
   : methmap2progtype PM CM
      (methmap`map/+ N MT MM) W'
      <- clsmap`fresh CM N
      <- methtp2proctype PM MT PT
      <- methmap`shift N MM MM'
      <- methmap2progtype PM CM MM' W
      <- progtype`update W N PT W'.


oflist2perm : predmap -> oflist -> permission -> type.

oflist2perm/0 : oflist2perm _ oflist/0 sharedPerm.

oflist2perm/+ 
   : oflist2perm PM (oflist/+ O T L) ((PF O) , Pi)
      <- oflist2perm PM L Pi
      <- nulltp2perm PM T PF.


perm-output : predmap -> permission -> result K -> output K -> type.

perm-output/exists* 
   : {Out: gterm objectk -> output condk} 
      perm-output PM Pi Rslt (output/exists ([v] Out v))
      <- ({v:object} perm-output PM Pi Rslt (Out v)).
		   
%abbrev perm-output/exists = [PO] perm-output/exists* _ PO.

perm-output/expr
   : perm-output PM Pi (result/expr T) 
      (output/exists ([v] (output/expr v ((PF v) , Pi))))
      <- nulltp2perm PM T PF.

perm-output/cond : perm-output _ Pi result/cond (output/cond _ Pi Pi).
	    
perm-output/args/0
   : perm-output PM Pi result/args/0 (output/args/0 Pi).

perm-output/args/+ 
   : perm-output PM Pi  (result/args/+ T Rslt)
      (output/exists ([v] (output/args/+ v (Out v))))
      <- nulltp2perm PM T PF
      <- ({o} perm-output PM ((PF o) , Pi) Rslt (Out o)).


%%% basic theorems


%%% theorems about equality

%theorem output/exists-preserves-eq :
        forall* {K} {Out1: object -> output K} {Out2: object -> output K}
        forall  {E: {o} environment`eq (Out1 o) (Out2 o)}
        exists  {E: environment`eq
		     (output/exists [o] (Out1 o)) (output/exists [o] (Out2 o))}
        true.

- : output/exists-preserves-eq ([o] environment`eq/) environment`eq/.

%worlds (objvar) (output/exists-preserves-eq _ _).
%total  {} (output/exists-preserves-eq _ _).


%theorem combine-preserves-eq :
        forall* {Pi1} {Pi2} {Pi3} {Pi4}
        forall  {E1: permission`eq Pi1 Pi2}
                {E2: permission`eq Pi3 Pi4}
        exists  {E3: permission`eq (Pi1 , Pi3) (Pi2 , Pi4)}
        true.

- : combine-preserves-eq permission`eq/ permission`eq/ permission`eq/.

%worlds (objvar) (combine-preserves-eq _ _ _).
%total  {} (combine-preserves-eq _ _ _).


%theorem permission`eq-implies-equiv :
        forall* {Pi1} {Pi2}
        forall  {EQ: permission`eq Pi1 Pi2}
        exists  {EQV: equiv Pi1 Pi2}
        true.

- : permission`eq-implies-equiv permission`eq/ equiv/reflexive.

%worlds (objvar) (permission`eq-implies-equiv _ _).
%total  {} (permission`eq-implies-equiv _ _).


%theorem allocFields-respects-eq :
        forall* {S1} {S2} {OS1} {OS2}
        forall  {AF: {t} allocFields t S1 (OS1 t)}
                {EQ: set`eq S1 S2}
                {EQ: {t} permission`eq (OS1 t) (OS2 t)}
        exists  {AF: {t} allocFields t S2 (OS2 t)}
        true.

- : allocFields-respects-eq ([t] AF t) set`eq/ ([_] permission`eq/) ([t] AF t).

%worlds (objvar) (allocFields-respects-eq _ _ _ _).
%total  {} (allocFields-respects-eq _ _ _ _).


%theorem no-variable-lookup :
	forall* {PM} {C} {PDF: object -> nullpred} 
	forall  {PMLP: {o} predmap`lookup PM C (PDF o)}
	exists  {PD} {PMLP: predmap`lookup PM C PD}
                {EQ: {o} predicate`eq (PDF o) PD}
	true.		       
			  
- : no-variable-lookup ([_] predmap`lookup/= N1=N2) 
     _ (predmap`lookup/= N1=N2) ([_] predicate`eq/).

- : no-variable-lookup ([o] predmap`lookup/> (PMLP o) P)
     PD (predmap`lookup/> PMLP' P) EQF
     <- no-variable-lookup PMLP PD PMLP' EQF.

%worlds (objvar) (no-variable-lookup _ _ _ _).
%total  PMLP (no-variable-lookup PMLP _ _ _).


%%% theorems about totality

%theorem nn2perm-total :
        forall {NN}
        exists {PF} {NN2P: nn2perm NN PF}
        true.

- : nn2perm-total nn/may _ nn2perm/may.
- : nn2perm-total nn/yes _ nn2perm/yes.

%worlds (objvar) (nn2perm-total _ _ _).
%total  {} (nn2perm-total _ _ _).


%theorem nn2perm-deterministic :
        forall* {NN1} {NN2} {FF1} {FF2}
        forall  {NN2P1: nn2perm NN1 FF1}
                {NN2P2: nn2perm NN2 FF2}
                {NNEQ: nn`eq NN1 NN2}
        exists  {EQ: {p}{o} permission`eq (FF1 p o) (FF2 p o)}
        true.

- : nn2perm-deterministic nn2perm/yes nn2perm/yes _ ([_][_] permission`eq/).
- : nn2perm-deterministic nn2perm/may nn2perm/may _ ([_][_] permission`eq/).

%worlds (objvar) (nn2perm-deterministic _ _ _ _).
%total  {} (nn2perm-deterministic _ _ _ _).

%theorem clsmap-nulltp-implies-nulltp2perm :
	forall* {CM} {PM} {T}
	forall  {CM2PM: clsmap2predmap CM PM}
		{CM-T: clsmap-nulltp CM T}
	exists  {PF} {T2P: nulltp2perm PM T PF}
	true.					 

- : clsmap-nulltp-implies-nulltp2perm _ clsmap-nulltp/null _ nulltp2perm/null.

- : clsmap-nulltp-implies-nulltp2perm 
     CM2PM (clsmap-nulltp/norm (clsmap`domain?/in CM-LP)) 
     _ (nulltp2perm/norm PM-LP NN2P)
     <- nn2perm-total _ _ NN2P
     <- clsmap2predmap-implies-predmap-lookup CM2PM CM-LP _ PM-LP.

%worlds (objvar) (clsmap-nulltp-implies-nulltp2perm _ _ _ _).
%total  {} (clsmap-nulltp-implies-nulltp2perm _ _ _ _).


%theorem nulltp2perm-respects-eq :
        forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
        forall  {T2P1: nulltp2perm PM1 T1 PF1}
                {MEQ: predmap`eq PM1 PM2}
                {TEQ: nulltp`eq T1 T2}
                {FEQ: {o} permission`eq (PF1 o) (PF2 o)}
        exists  {T2P2: nulltp2perm PM2 T2 PF2}
        true.

- : nulltp2perm-respects-eq T2P predmap`eq/ nulltp`eq/ ([_] permission`eq/) T2P.

%worlds (objvar) (nulltp2perm-respects-eq _ _ _ _ _).
%total  {} (nulltp2perm-respects-eq _ _ _ _ _).


%theorem nulltp2perm-deterministic/L :
        forall* {PF1: nullpred -> object -> permission} {PF2} {PD1} {PD2} 
        forall  {FEQ: {p}{o} permission`eq (PF1 p o) (PF2 p o)}
                {PEQ: predicate`eq PD1 PD2}
        exists  {PEQ: {o} permission`eq (PF1 PD1 o) (PF2 PD2 o)}
        true.

- : nulltp2perm-deterministic/L
     ([_][_] permission`eq/) predicate`eq/ ([_] permission`eq/).

%worlds (objvar) (nulltp2perm-deterministic/L _ _ _).
%total  {} (nulltp2perm-deterministic/L _ _ _).


%theorem nulltp2perm-deterministic :
        forall* {PM1} {PM2} {T1} {T2} {PF1} {PF2}
        forall  {T2P1: nulltp2perm PM1 T1 PF1}
                {T2P2: nulltp2perm PM2 T2 PF2}
                {MEQ: predmap`eq PM1 PM2}
                {TEQ: nulltp`eq T1 T2}
	exists  {PEQ: {o} permission`eq (PF1 o) (PF2 o)}
        true.
			      
- : nulltp2perm-deterministic
     nulltp2perm/null nulltp2perm/null _ _ ([_] permission`eq/).

- : nulltp2perm-deterministic
     (nulltp2perm/norm PM-L1 NN2P1)
     (nulltp2perm/norm PM-L2 NN2P2)
     predmap`eq/ nulltp`eq/ ([o] PFEQ o)
     <- predmap`lookup-deterministic
	PM-L1 PM-L2 predmap`eq/ nat`eq/ EQ
     <- nn2perm-deterministic NN2P1 NN2P2 nn`eq/ FFEQ
     <- nulltp2perm-deterministic/L
	([p][o] FFEQ p o) EQ ([o] PFEQ o).

%worlds (objvar) (nulltp2perm-deterministic _ _ _ _ _).
%total  {} (nulltp2perm-deterministic _ _ _ _ _).


%%% theorem about methmap2progtype

%theorem false-implies-methtp2proctype :
        forall* {PM} {MT}
        forall  {F: void}
        exists  {PT} {MT2PT: methtp2proctype PM MT PT}
        true.

%worlds (objvar) (false-implies-methtp2proctype _ _ _).
%total  {} (false-implies-methtp2proctype _ _ _).


%theorem false-implies-constp2proctype :
	forall* {PM} {CTF} {FM}
        forall  {F: void}
        exists  {PTF} {CT2PT: constp2proctype PM FM CTF PTF}
        true.
				
%worlds (objvar) (false-implies-constp2proctype _ _ _).
%total  {} (false-implies-constp2proctype _ _ _).
  

%theorem methtp2proctype-respects-eq* :
        forall* {PM1} {PM2} {Pi1} {Pi2} {MT1} {MT2} {PT1} {PT2}
        forall  {MT2PT: methtp2proctype* PM1 Pi1 MT1 PT1}
                {MEQ: predmap`eq PM1 PM2}
                {PEQ: permission`eq Pi1 Pi2}
                {MTEQ: methtp`eq MT1 MT2}
                {PTEQ: proctype`eq PT1 PT2}
        exists  {MT2PT: methtp2proctype* PM2 Pi2 MT2 PT2}
        true.

- : methtp2proctype-respects-eq* 
     M2P predmap`eq/ permission`eq/ methtp`eq/ proctype`eq/ M2P.

%worlds (objvar) (methtp2proctype-respects-eq* _ _ _ _ _ _).
%total  {} (methtp2proctype-respects-eq* _ _ _ _ _ _).


%theorem methtp2proctype-respects-eq :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2}
        forall  {MT2PT: methtp2proctype PM1 MT1 PT1}
		{MEQ: predmap`eq PM1 PM2}
		{MTEQ: methtp`eq MT1 MT2}
		{PTEQ: proctype`eq PT1 PT2}
	exists  {MT2PT: methtp2proctype PM2 MT2 PT2}
	true.				

- : methtp2proctype-respects-eq M2P predmap`eq/ methtp`eq/ proctype`eq/ M2P.

%worlds () (methtp2proctype-respects-eq _ _ _ _ _).
%total  {} (methtp2proctype-respects-eq _ _ _ _ _).


%theorem proctype/base-preserves-eq :
        forall* {Pi1} {Pi2} {Out1} {Out2}
        forall  {EQ: permission`eq Pi1 Pi2}
                {EQ: environment`eq Out1 Out2}
        exists  {EQ: proctype`eq
		      (proctype/base Pi1 Out1) 
		      (proctype/base Pi2 Out2)}
        true.
        
- : proctype/base-preserves-eq permission`eq/ environment`eq/ proctype`eq/.

%worlds (objvar) (proctype/base-preserves-eq _ _ _).
%total  {} (proctype/base-preserves-eq _ _ _).


%theorem proctype/arg-preserves-eq :
        forall* {PTF1} {PTF2}
        forall  {EQ: {o} proctype`eq (PTF1 o) (PTF2 o)}
        exists  {EQ: proctype`eq (proctype/arg PTF1) (proctype/arg PTF2)}
        true.

- : proctype/arg-preserves-eq ([_] proctype`eq/)  proctype`eq/.

%worlds (objvar) (proctype/arg-preserves-eq _ _).
%total  {} (proctype/arg-preserves-eq _ _).


%theorem methtp2proctype-deterministic/L :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2} {Pi1} {Pi2}
        forall  {MT2PT: methtp2proctype* PM1 Pi1 MT1 PT1}
                {MT2PT: methtp2proctype* PM2 Pi2 MT2 PT2}
                {EQ: predmap`eq PM1 PM2}
                {EQ: permission`eq Pi1 Pi2}
                {EQ: methtp`eq MT1 MT2}
        exists  {EQ: proctype`eq PT1 PT2}
        true.

- : methtp2proctype-deterministic/L
     (methtp2proctype*/base T2P1) (methtp2proctype*/base T2P2) 
     PMEQ permission`eq/ MTEQ PTEQ
     <- base-eq-implies-nulltp-eq MTEQ TEQ
     <- nulltp2perm-deterministic T2P1 T2P2 PMEQ TEQ ([o] PFEQ o)
     <- ({o} combine-preserves-eq permission`eq/ (PFEQ o) (PEQ o))
     <- ({o} output/expr-preserves-eq object`eq/ (PEQ o) (OEQ o))
     <- output/exists-preserves-eq OEQ OEQ'
     <- proctype/base-preserves-eq permission`eq/ OEQ' PTEQ.
     
- : methtp2proctype-deterministic/L
     (methtp2proctype*/arg ([o] MT2PT1 o) T2P1)
     (methtp2proctype*/arg ([o] MT2PT2 o) T2P2)
     PMEQ PiEQ MTEQ PTEQ
     <- arg-eq-implies-nulltp-eq MTEQ ([o] MTFEQ o) TEQ
     <- nulltp2perm-deterministic T2P1 T2P2 PMEQ TEQ ([o] PFEQ o)
     <- ({o} combine-preserves-eq (PFEQ o) PiEQ (PiEQ' o))
     <- ({o} methtp2proctype-deterministic/L 
	   (MT2PT1 o) (MT2PT2 o) PMEQ (PiEQ' o) (MTFEQ o) (PTFEQ o))
     <- proctype/arg-preserves-eq PTFEQ PTEQ.

%worlds (objvar) (methtp2proctype-deterministic/L _ _ _ _ _ _).
%total  MT2PT (methtp2proctype-deterministic/L MT2PT _ _ _ _ _).


%theorem methtp2proctype-deterministic :
        forall* {PM1} {PM2} {MT1} {MT2} {PT1} {PT2} 
        forall  {MT2PT: methtp2proctype PM1 MT1 PT1}
                {MT2PT: methtp2proctype PM2 MT2 PT2}
                {EQ: predmap`eq PM1 PM2}
                {EQ: methtp`eq MT1 MT2}
        exists  {EQ: proctype`eq PT1 PT2}
        true.

- : methtp2proctype-deterministic MT2PT1 MT2PT2 PMEQ MTEQ PTEQ
     <- methtp2proctype-deterministic/L MT2PT1 MT2PT2 PMEQ permission`eq/ MTEQ PTEQ.

%worlds (objvar) (methtp2proctype-deterministic _ _ _ _ _).
%total  {} (methtp2proctype-deterministic _ _ _ _ _).

% constp2proctype : predmap -> fldmap -> 
% 	(object -> methtp) -> (object -> proctype) -> type.

% constp2proctype/ 
%    : constp2proctype PM FM ([t] MTF t) ([t] PTF t)
%       <- fldmap`domain FM S
%       <- ({t} allocFields t S (OS t))
%       <- ({t} methtp2proctype* PM (OS t) (MTF t) (PTF t)).


% %theorem constp2proctype-deterministic :
%         forall* {PM1} {PM2} {CT1} {CT2} {PT1} {PT2}
%         forall  {CT2PT: constp2proctype PM1 CT1 PT1}
%                 {CT2PT: constp2proctype PM2 CT2 PT2}
%                 {EQ: predmap`eq PM1 PM2}
%                 {EQ: ({o} methtp`eq CT1 CT2}
%         exists  {EQ: proctype`eq PT1 PT2}
%         true.

        
%theorem constp2proctype-respects-eq :
	forall* {PM1} {PM2} {FM1} {FM2} 
                {CTF1} {CTF2} {PTF1} {PTF2}
        forall  {C2P: constp2proctype PM1 FM1 CTF1 PTF1}
                {E: predmap`eq PM1 PM2}
                {E: fldmap`eq FM1 FM2}
                {E: {o} methtp`eq (CTF1 o) (CTF2 o)}
                {E: proctype`eq (proctype/arg PTF1) (proctype/arg PTF2)}
        exists  {C2P: constp2proctype PM2 FM2 CTF2 PTF2}
        true.

- : constp2proctype-respects-eq C2P predmap`eq/ fldmap`eq/ ([_] methtp`eq/) proctype`eq/ C2P.
     
%worlds (objvar) (constp2proctype-respects-eq _ _ _ _ _ _).
%total  {} (constp2proctype-respects-eq _ _ _ _ _ _).


%theorem methmap2progtype-implies-methtp2proctype :
	forall* {PM} {CM} {MM} {W} {M} {MT} 
	forall  {MM2W: methmap2progtype PM CM MM W}
                {CM-FS: clsmap`fresh CM M}			      
		{MM-LP: methmap`lookup MM M MT}
	exists  {PT} {W-LP: progtype`lookup W M PT}
		{MT2PT: methtp2proctype PM MT PT}			      
	true.

%%% impossible case
- : methmap2progtype-implies-methtp2proctype  
     (methmap2progtype/c _ _ _ _ CM-LP) CM-FS
     (methmap`lookup/= N=M) _ W-LP MT2PT
     <- clsmap`fresh-lookup-not-equal CM-FS CM-LP M!=N
     <- nat`ne-symmetric M!=N N!=M
     <- nat`eq-ne-implies-false N=M N!=M F
     <- false-implies-methtp2proctype F _ MT2PT
     <- progtype`false-implies-lookup F W-LP.

- : methmap2progtype-implies-methtp2proctype 
     (methmap2progtype/c W-UD MM2W MM-SH CT2PT CM-LP) CM-FS
     (methmap`lookup/> MM-LP P) _ W-LP MT2PT
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- nat`plus-implies-gt P nat`eq/ GT
     <- methmap`shift-preserves-lookup* MM-LP MM-SH P'' MM-LP'
     <- methmap2progtype-implies-methtp2proctype MM2W CM-FS MM-LP' PT W-LP' MT2PT
     <- nat`ne-symmetric (nat`ne/< GT) NE
     <- progtype`update-preserves-lookup W-LP' W-UD NE W-LP.

- : methmap2progtype-implies-methtp2proctype 
     (methmap2progtype/m W-UD _ _ MT2PT CM-FS) CM-FS'
     (methmap`lookup/= N=M) _ W-LP MT2PT
     <- progtype`update-implies-lookup W-UD W-LP'
     <- progtype`lookup-respects-eq W-LP' progtype`eq/ N=M proctype`eq/ W-LP.

- : methmap2progtype-implies-methtp2proctype 
     (methmap2progtype/m W-UD MM2W MM-SH _ _) CM-FS
     (methmap`lookup/> MM-LP P) _ W-LP MT2PT
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- nat`plus-implies-gt P nat`eq/ GT
     <- methmap`shift-preserves-lookup* MM-LP MM-SH P'' MM-LP'
     <- methmap2progtype-implies-methtp2proctype MM2W CM-FS MM-LP' PT W-LP' MT2PT
     <- nat`ne-symmetric (nat`ne/< GT) NE
     <- progtype`update-preserves-lookup W-LP' W-UD NE W-LP.

%worlds (objvar) (methmap2progtype-implies-methtp2proctype _ _ _ _ _ _).
%total MM2W (methmap2progtype-implies-methtp2proctype MM2W _ _ _ _ _).


%theorem methmap2progtype-implies-constp2proctype :
	forall* {PM} {CM} {MM} {W} {C} {CTF} {FM} {T}
	forall  {MM2W: methmap2progtype PM CM MM W}
                {CM-LP: clsmap`lookup CM C FM}			      
		{MM-LP: methmap`lookup MM C (methtp/arg CTF T)}
	exists  {PTF} {W-LP: progtype`lookup W C (proctype/arg PTF)}
		{MT2PT: constp2proctype PM FM ([o] CTF o) ([o] PTF o)}			      
	true.

%%% impossible case
- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/m _ _ _ _ CM-FS) CM-LP
     (methmap`lookup/= N=C) _ W-LP CT2PT
     <- clsmap`fresh-lookup-not-equal CM-FS CM-LP C!=N
     <- nat`ne-symmetric C!=N N!=C
     <- nat`eq-ne-implies-false N=C N!=C F
     <- false-implies-constp2proctype F _ CT2PT
     <- progtype`false-implies-lookup F W-LP.

- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/m W-UD MM2W MM-SH _ _) CM-LP
     (methmap`lookup/> MM-LP P) _ W-LP CT2PT
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- nat`plus-implies-gt P nat`eq/ GT
     <- methmap`shift-preserves-lookup* MM-LP MM-SH P'' MM-LP'
     <- methmap2progtype-implies-constp2proctype MM2W CM-LP MM-LP' PT W-LP' CT2PT
     <- nat`ne-symmetric (nat`ne/< GT) NE
     <- progtype`update-preserves-lookup W-LP' W-UD NE W-LP.

- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/c W-UD _ _ CT2PT CM-LP) CM-LP' 
     (methmap`lookup/= N=C) _ W-LP CT2PT'
     <- progtype`update-implies-lookup W-UD W-LP'
     <- clsmap`lookup-deterministic CM-LP CM-LP' clsmap`eq/ N=C FM=FM'
     <- progtype`lookup-respects-eq W-LP' progtype`eq/ N=C proctype`eq/ W-LP
     <- constp2proctype-respects-eq
	CT2PT predmap`eq/ FM=FM' ([_] methtp`eq/) proctype`eq/ CT2PT'.
	
- : methmap2progtype-implies-constp2proctype
     (methmap2progtype/c W-UD MM2W MM-SH _ _) CM-LP
     (methmap`lookup/> MM-LP P) PTF W-LP CT2PT
     <- nat`plus-swap-succ P P'
     <- nat`plus-commutative P' P''
     <- nat`plus-implies-gt P nat`eq/ GT
     <- methmap`shift-preserves-lookup* MM-LP MM-SH P'' MM-LP'
     <- methmap2progtype-implies-constp2proctype MM2W CM-LP MM-LP' PTF W-LP' CT2PT
     <- nat`ne-symmetric (nat`ne/< GT) NE
     <- progtype`update-preserves-lookup W-LP' W-UD NE W-LP.

%worlds (objvar) (methmap2progtype-implies-constp2proctype _ _ _ _ _ _).
%total MM2W (methmap2progtype-implies-constp2proctype MM2W _ _ _ _ _).
